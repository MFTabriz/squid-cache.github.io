<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ClientStreams</title><revhistory><revision><revnumber>5</revnumber><date>2021-06-22 23:10:07</date><authorinitials>FrancescoChemolli</authorinitials></revision><revision><revnumber>4</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>3</revnumber><date>2006-02-10 13:09:38</date><authorinitials>kinkie</authorinitials></revision><revision><revnumber>2</revnumber><date>2005-10-23 08:49:39</date><authorinitials>kinkie</authorinitials><revremark>Added explicit formatting of irc session</revremark></revision><revision><revnumber>1</revnumber><date>2005-01-03 05:17:53</date><authorinitials>RobertCollins</authorinitials><revremark>upload raw transcript</revremark></revision></revhistory></articleinfo><para>ClientStreams provides an API to retrieve and manipulate data from squid, from inside squid. Squid's ClientSide processing uses ClientStreams to fulfill standard client HTTP requests. </para><para>What follows is a very slightly edited transcript (with permission) of an IRC chat about ClientStreams, it needs to be cleaned up and made more organised... </para><programlisting format="linespecific" language="irc" linenumbering="numbered" startinglinenumber="1"><![CDATA[14:48 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Hi. I'm working on bug 1160 (analyze HTML to prefetch embedded objects). I can't figure out why, but even though it ]]>
<![CDATA[                  fetches the pages, it doesn't cache the result! The fetch is initiated with "fwdState(-1, entry, request);".]]>
<![CDATA[14:49 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[I'd use the same mechanism ESI does.]]>
<![CDATA[14:49 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Ok, that's client streams.]]>
<![CDATA[14:49 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[the fwdState api is on the wrong side of the store]]>
<![CDATA[14:49 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[doh!]]>
<![CDATA[14:49 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so it doesn't have any of the required logic - cachability, vary handling, updates of existing opbjects...]]>
<![CDATA[14:50 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[things like store digests just haven't been updated to use client streams yet.]]>
<![CDATA[14:50 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[What, concisely, is a store digest?]]>
<![CDATA[14:51 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[a bitmap that lossilly represents the contents of an entire squid cache, biased to hits.]]>
<![CDATA[14:51 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[uses a thing called a bloom filter]]>
<![CDATA[14:52 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[it lets squid predict that another cache will have a given object, for predictive routing (as opposed to ICP which is ]]>
<![CDATA[                  reactive)]]>
<![CDATA[14:52 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[That's strange, but ok. I suppose it's necessary for performance when you have a large number of cached objects.]]>
<![CDATA[14:52 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[well its an optional feature.]]>
<![CDATA[14:53 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Ok, I tried to track a standard request through the code and it runs through http.cc. Http.cc uses the store, but it ]]>
<![CDATA[                  doesn't actually insert the object into the cache?]]>
<![CDATA[14:53 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[right.]]>
<![CDATA[14:54 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[http.cc just retrieves http objects, like ftp.cc retrieves ftp objects.]]>
<![CDATA[14:54 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[I'm on the wrong side of the fence. Gotcha.]]>
<![CDATA[14:54 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Honestly, I spent about 5 days trying to understand the client stream API.]]>
<![CDATA[14:55 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Concisely, what is a client stream? I suggested that they're a chain of observers to the results of a request. Is that ]]>
<![CDATA[                  accurate?]]>
<![CDATA[14:56 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[http://www.squid-cache.org/Doc/FAQ/FAQ-16.html]]>
<![CDATA[14:57 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[client streams..]]>
<![CDATA[14:57 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[they are a 'chain of responsibility' pattern.]]>
<![CDATA[14:58 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[sortof.]]>
<![CDATA[14:58 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[the clientStream code was started in C in the squid 2.6 timeframe, it needs an overhaul badly, now we can actually ]]>
<![CDATA[                  write this sort of code more cleanly.]]>
<![CDATA[14:59 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Right, I noticed that the code is in flux. Might I add that I don't like CBDATA either ... not that I'm offering to do ]]>
<![CDATA[                  better.]]>
<![CDATA[15:00 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[For a ClientStreamData, I'm supposed to create my own Data class which is derived from, er, Refcountable? Then let the ]]>
<![CDATA[                  ClientStreamData's internal pointer point to my object, then upcast it when my callbacks are called?]]>
<![CDATA[15:01 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[See, I don't really understand what my callbacks are really supposed to do, since I only want "default" behaviour. As ]]>
<![CDATA[                  in, whatever squid normally does to cache/handle a request, expect that there's no sender to send it to.]]>
<![CDATA[15:02 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[well you don't want that.]]>
<![CDATA[15:02 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[because you don't want to parse requests.]]>
<![CDATA[15:02 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[ClientSocketContext is likely to be the closest thing to what you want though.]]>
<![CDATA[15:03 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so your readfunc needs to eat all the data it recieves.]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[you can throw it away.]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[your detach function can just call clientStreamDetach(node, http);]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[so do I add my function into ClientSocketContext's read function?]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[see clientSocketDetach]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[or do I add another node in the clientStream?]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[no, you should have all your stuff in its own .cc file.]]>
<![CDATA[15:04 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[you'll construct a new clientStream to service your requests.]]>
<![CDATA[15:05 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Oh it is, but somebody has to enter my .cc file at some point, right?]]>
<![CDATA[15:05 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[right, you should have that already written though - whatever is doing the parsing should already be a clientStream]]>
<![CDATA[15:06 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Nope. I just hacked it into http.cc.]]>
<![CDATA[15:06 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if its not, then don't worry for now, get it working is the first step.]]>
<![CDATA[15:06 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Not that I can't move it pretty easily.]]>
<![CDATA[15:06 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Everything works, except that it doesn't cache what it fetches. And now I know why.]]>
<![CDATA[15:06 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[your Status calls should always return prev()->status()]]>
<![CDATA[15:07 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[the callback call is the one that is given the data, it too should throw it away.]]>
<![CDATA[15:08 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[and someone else will cache it?]]>
<![CDATA[15:08 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[yes]]>
<![CDATA[15:08 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[ok, I assume you're talking about just the fetching part?]]>
<![CDATA[15:08 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[I'm talking about the clientStream node you need to implement.]]>
<![CDATA[15:09 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[so when I know a URL that I want to prefetch, I create my clientStream with this one node that you just described.]]>
<![CDATA[15:10 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[ESIInclude.cc shows this well]]>
<![CDATA[15:10 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[I've spent a lot of time reading it, but since I didn't understand clientStreams, I never managed to quite figure it ]]>
<![CDATA[                  out.]]>
<![CDATA[15:11 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[ok, start with ESIInclude::Start]]>
<![CDATA[15:11 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[this calls clientBeginRequest]]>
<![CDATA[15:12 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[esiBufferRecipient seems to do a lot of work, including checking whether the HTTP stream succeeded or failed, and ]]>
<![CDATA[                  loading it into the store  (maybe, I'm not clear on the store API either).]]>
<![CDATA[15:12 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[it passes in the clientStream callbacks - esiBufferRecipient, esiBufferDetach, the streamdata (stream.getRaw()), the ]]>
<![CDATA[                  http headers its synthetic request needs.]]>
<![CDATA[15:12 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[oh right, this code. Yes, I cut'n'pasted this in, but I never got it working for me.]]>
<![CDATA[15:12 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[esiBuffer recipient copies the object back into the ESI master document.]]>
<![CDATA[15:12 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so it has to do a bunch more work than you'll need to.]]>
<![CDATA[15:13 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[stream.getRaw() is a pointer to the node, yes? I could the code around that confusing.]]>
<![CDATA[15:14 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[stream is a ESIStreamContext which is a clientStream node that pulls data from a clientstream, instances of which are ]]>
<![CDATA[                  used by both the master esi document and includes]]>
<![CDATA[15:14 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[(different instances, but hte logic is shared by composition)]]>
<![CDATA[15:14 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[that is pased into ESIInclude::Start because ESI includes have a primary include and an 'alternate' include.]]>
<![CDATA[15:16 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so all you need to start the chain is:]]>
<![CDATA[15:16 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[I see. I won't need to worry about any of that.]]>
<![CDATA[15:16 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[HttpHeader tempheaders(hoRequest);]]>
<![CDATA[15:17 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if (clientBeginRequest(METHOD_GET, url, aBufferRecipient, aBufferDetach, aStreamInstance, &tempheaders, ]]>
<![CDATA[                  aStreamInstance->buffer->buf, HTTP_REQBUF_SZ)) ]]>
<![CDATA[15:17 ]]><methodname><![CDATA[< lifeless>   ]]></methodname><![CDATA[{]]>
<![CDATA[15:17 ]]><methodname><![CDATA[< lifeless>   ]]></methodname><![CDATA[/* handle failure */]]>
<![CDATA[15:17 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[}]]>
<![CDATA[15:17 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[httpHeaderClean (&tempheaders);]]>
<![CDATA[15:18 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[that will cause callbacks to aBufferRecipient, aBufferDetach to occur]]>
<![CDATA[15:19 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[then in the buffer recipient you throw them away, just check for status codes etc.]]>
<![CDATA[15:19 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[and I've given you the skeleton for detach above.]]>
<![CDATA[15:20 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[aStreamInstance is just a cbdata class that has your context.]]>
<![CDATA[15:20 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[i.e.]]>
<![CDATA[15:21 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[class myStream {]]>
<![CDATA[15:21 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[public]]>
<![CDATA[15:21 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[:]]>
<![CDATA[15:21 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[static void BufferData (clientStreamNode *, ClientHttpRequest *, HttpReply *, StoreIOBuffer);]]>
<![CDATA[15:21 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[static void Detach (clientStreamNode *, ClientHttpRequest *);]]>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><methodname><![CDATA[private:]]></methodname>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[CBDATA_CLASS2(myStream);]]>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[void buferData (clientStreamNode *, ClientHttpRequest *, HttpReply *, StoreIOBuffer);]]>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[void detach (clientStreamNode *, ClientHttpRequest *);]]>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[}]]>
<![CDATA[15:22 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[;]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[then in your .cc file...]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[CBDATA_CLASS_INIT(myStream);]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[the cbdata init line, i presume?]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[those CBDATA macros setup new and delete to do the right thing.]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[then your static functions are just]]>
<![CDATA[15:23 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[i don't need to write my own void *operator new?]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[no, you don't.]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[void]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[phew. :)]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< lifeless> ]]></methodname><methodname><![CDATA[myStream::]]></methodname><![CDATA[BufferData (clientStreamNode *node, ClientHttpRequest *, HttpReply *, StoreIOBuffer)]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[{]]>
<![CDATA[15:24 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if (!cbdataReferenceValid(node->data))]]>
<![CDATA[15:25 ]]><methodname><![CDATA[< lifeless>  ]]></methodname><![CDATA[/* something weird has happened - your data has been freed, but a callback has still been issued. deal here */]]>
<![CDATA[15:25 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[static_cast<myStream *>(node->data)->bufferData(node, ...);]]>
<![CDATA[15:25 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[}]]>
<![CDATA[15:25 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[and likewise for the Detach static method]]>
<![CDATA[15:26 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[is this making sense ?]]>
<![CDATA[15:27 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[yes, but just let me reread a litt.e]]>
<![CDATA[15:27 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[ok, theres one more important thing :)]]>
<![CDATA[15:27 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA["static_cast<myStream *>(node->data)->bufferData(node, ...)" calls myStream::BufferData doesn't it? So why am I calling ]]>
<![CDATA[                  myself?]]>
<![CDATA[15:28 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[lowercase bufferData :)]]>
<![CDATA[15:28 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[oh man, i thought that was just a typo. now i have to reread all of it!]]>
<![CDATA[15:28 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[the static functions (denoted with the initial Capital) are thunks into the actual instance methods.]]>
<![CDATA[15:29 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[which makes sense. yes.]]>
<![CDATA[15:29 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[http://www.squid-cache.org/~robertc/squid-3-style.txt]]>
<![CDATA[15:29 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[but what does bufferData actually do? let's see if i do understand this ...]]>
<![CDATA[15:29 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[... it'll receive the contents of the page that I requested from clientBeginRequest, so I just discard them. check?]]>
<![CDATA[15:29 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[bufferData needs to do two things. it needs to check the status of node->next()]]>
<![CDATA[15:30 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[and on everything other than error or end-of-stream, it needs to issue a new read.]]>
<![CDATA[15:30 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[hm, ok.]]>
<![CDATA[15:31 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if something like a 404 occurs, you'll get that as the HttpReply in the first call to bufferData.]]>
<![CDATA[15:31 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[and it will already be (negatively) entered into the cache for me]]>
<![CDATA[15:31 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[so i just ... don't do anything.]]>
<![CDATA[15:31 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[exactly.]]>
<![CDATA[15:31 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[just swallow the data until node->next()->status() returns an error.]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[if it was a successful read, but the connection is still open, i read more.]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[ok.]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[now let me ask you about the other half: analyzing pages that come in.]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if its not an error, to swallow more data you call ->readfunc()]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[you'll need a buffer area in your class instance.]]>
<![CDATA[15:32 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[(although to be tricky you could use a static buffer in your class, as you don't care about the data)]]>
<![CDATA[15:33 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[(ah, nice trick! didn't think of that.)]]>
<![CDATA[15:33 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[I told you earlier that I just hacked my analyzer into http.cc. While this works for me, is there a better place to put ]]>
<![CDATA[                  it? Especially if I want you devs to accept the patch?]]>
<![CDATA[15:34 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[wbut I wouldn't worry about that - just have a HTTP_REQBUF_SZ char array in your private data.]]>
<![CDATA[15:34 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[I was using SM_PAGE_SIZE.]]>
<![CDATA[15:35 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[ok, where to put the analyzer ? we've got some rework we want to do in the request flow that would make this a lot ]]>
<![CDATA[                  easier to answer.]]>
<![CDATA[15:35 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[I think that the right place for now, is exactly where esi goes, and after esi in the chain.]]>
<![CDATA[15:35 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[the problem with where you are is that ftp pages won't be analysed. and if its an esi upstream then the urls could be ]]>
<![CDATA[                  wrong (for instance)]]>
<![CDATA[15:35 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[http requests that come in from clients have a client stream chain?]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[yup]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[hunh. i didn't even notice.]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[client_side_reply.cc line 1927]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[who installs ESIs ...]]>
<![CDATA[15:36 ]]><token><![CDATA[-!- ]]></token><phrase><![CDATA[Irssi: ]]></phrase><lineannotation><![CDATA[Pasting 11 lines to #squiddev. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.]]></lineannotation>
<lineannotation></lineannotation><![CDATA[15:36 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[#if ESI]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>     ]]></methodname><![CDATA[if (http->flags.accel && rep->sline.status != HTTP_FORBIDDEN &&]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>             ]]></methodname><![CDATA[!alwaysAllowResponse(rep->sline.status) &&]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>             ]]></methodname><![CDATA[esiEnableProcessing(rep)) {]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>         ]]></methodname><![CDATA[debug(88, 2) ("Enabling ESI processing for %s\n", http->uri);]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>         ]]></methodname><![CDATA[clientStreamInsertHead(&http->client_stream, esiStreamRead,]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>                                ]]></methodname><![CDATA[esiProcessStream, esiStreamDetach, esiStreamStatus, NULL);]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless>     ]]></methodname><![CDATA[}]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[#endif]]>
<![CDATA[15:36 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[yep, i've got the code up here.]]>
<![CDATA[15:37 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[clientStreamInsertHead. awesome.]]>
<![CDATA[15:37 ]]><methodname><![CDATA[< lifeless>  ]]></methodname><![CDATA[this says - if its an accelerated request that isn't an deny-error page, and its a response that is amenable to ]]>
<![CDATA[                  processing, and it passes the esi logic checks.. then add a new head.]]>
<![CDATA[15:37 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Nod. For me, I just need to know whether the mime-type is HTML or not.]]>
<![CDATA[15:38 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[you'll want to add your head before esi, so that you come after esi in the processing.]]>
<![CDATA[15:38 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[So the headers need to be complete and processed before I know whether to add myself.]]>
<![CDATA[15:38 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so right before that #if ESI line.]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Oh, I see it has the body at this point already?]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Or does it just have a partial body?]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[it may have some body, but it definately has the reply metadata]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Because my code is rigged to work with partial data.]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[ok, good.]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Then that's *exactly* right.]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so you can just look in rep-> to get the headers already parsed.]]>
<![CDATA[15:39 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[yep.]]>
<![CDATA[15:40 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[and you'll get called with whatever data is available in your buffer function.]]>
<![CDATA[15:40 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Perfect.]]>
<![CDATA[15:40 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[your buffer function should analyse, then call node->next()->callback(node->next(), ...)]]>
<![CDATA[15:41 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[when a read is issued, there is one complication :]]>
<![CDATA[15:41 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[So that ESI or whomever can do it.]]>
<![CDATA[15:41 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[s/it/their thing/]]>
<![CDATA[15:41 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[if the client wants a range request, the read issued to you may be for partial data.]]>
<![CDATA[15:41 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Will there be a flag on those? So I can avoid them?]]>
<![CDATA[15:42 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[so you have a choice. like ESI you can force ranges off for what you request, and filter out what you supply according ]]>
<![CDATA[                  to what is requested from you.]]>
<![CDATA[15:42 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[alternatively, and for you I think better, just don't add yourself to the chain at all if its a range request.]]>
<![CDATA[15:42 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[Well, what I request will never be ranged. But, what I analyze isn't necessarily what I requested.]]>
<![CDATA[15:43 ]]><methodname><![CDATA[< nicholas> ]]></methodname><![CDATA[It will normally be the request from the user agent. That's the point.]]>
<![CDATA[15:43 ]]><methodname><![CDATA[< lifeless> ]]></methodname><![CDATA[in your if block in client_side_reply just check http->request->range]]>
</programlisting></article>