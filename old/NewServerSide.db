<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>NewServerSide</title><revhistory><revision><revnumber>4</revnumber><date>2008-05-18 19:38:57</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>3</revnumber><date>2008-02-19 00:07:07</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>2</revnumber><date>2008-02-19 00:06:37</date><authorinitials>AmosJeffries</authorinitials><revremark>this is a wishlist feature</revremark></revision><revision><revnumber>1</revnumber><date>2007-03-18 04:05:52</date><authorinitials>AdrianChadd</authorinitials></revision></revhistory></articleinfo><section><title>Another Server Side?</title><para>.. or, as it actually is, a HTTP client. </para><section><title>Wha?</title><para>A simple HTTP client is required to manage connections to origin servers/peers. </para></section><section><title>What will it do?</title><itemizedlist><listitem><para>Manage the network connections to origin servers/peers. In actuality it should treat them almost the same. </para></listitem><listitem><para>Handle authentication to said origin servers/peers if/where required. </para></listitem><listitem><para>Handle network layer transforms - eg SSL. </para></listitem><listitem><para>Manage persistent connections </para></listitem><listitem><para>Handle pinned connections correctly </para></listitem><listitem><para>Handle simple connection-based load balancing between a number of end servers/peers. </para></listitem><listitem><para>HTTP/HTTPS CONNECT style connections </para></listitem></itemizedlist></section><section><title>What won't it do?</title><itemizedlist><listitem><para>Handle content/transfer encodings (eg gzip/deflate) </para></listitem><listitem><para>Handle any of the cache logic whatsoever </para></listitem><listitem><para>ACL checks </para></listitem><listitem><para>Content filtering/rewriting </para></listitem><listitem><para>Deciding on how to handle the target host - the intermediate layer should make the choice as to the peer IP which includes performing a DNS lookup and selecting an IP to use for the server or upstream peer. </para></listitem><listitem><para>Handling clear-channel TCP connections for proxying non-HTTP stuff (eg Steven Wilton's recent Squid-2 patches to improve transparency.) This should be implemented as another client module that handles stuff clear-channel, not HTTP. Should be pretty simple to implement but will require slightly different messages to be queued. </para></listitem></itemizedlist></section><section><title>What will the general process flow look like?</title><itemizedlist><listitem><para>The queue runner for pending server requests pops off a HTTP request </para></listitem><listitem><para>Is it pinned? Match it against the existing pinned server connection; throw error if that connection isn't valid anymore </para></listitem><listitem><para>Is there a persistent+free connection available? Select that </para></listitem><listitem><para>Else initiate the server connection </para></listitem><listitem><para>Once connection is established build and send the HTTP request and participate in HTTP request body sending if required </para></listitem><listitem><para>Handle the reply back - if it requires authentication which we can locally handle then resubmit the request with authentication credentials, else bounce the status back to the client to handle (and this may require pinning this connection in the case of NTLM authentication) </para></listitem><listitem><para>Pipe data back to the client </para></listitem><listitem><para>If EOF, destroy the instance and tell the HTTP request/client about it </para></listitem><listitem><para>If not EOF then decide whether the connection should be closed or not and either close the connection (doing above), or put into the persistent or pinned pools as required. </para></listitem></itemizedlist></section><section><title>How to handle errors?</title></section><section><title>Threading?</title><para>Threading needs to take into account the idea of pinned/persistent connection pools. A few ideas: </para><itemizedlist><listitem><para>be cheap: implement concurrency through multiple processes and force each process to handle a small set of persistent connections to servers (with relevant BSD hacks to hand off FD's between processes if we really need to migrate stuff.) </para></listitem><listitem><para>Implement multiple threads for handling client and server events; the majority of connections (normal, pinned) will be inside a given thread and so won't need to involve thread locking to queue stuff. Persistent connections could be managed as above to limit thread locking overhead or, well, we could just lock the persistent connection set. </para></listitem><listitem/></itemizedlist><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/NewServerSide/CategoryWish#">CategoryWish</ulink> <ulink url="https://wiki.squid-cache.org/NewServerSide/CategoryFeature#">CategoryFeature</ulink> </para></section></section></article>