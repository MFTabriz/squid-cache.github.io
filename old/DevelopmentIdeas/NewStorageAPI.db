<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>DevelopmentIdeas/NewStorageAPI</title><revhistory><revision><revnumber>7</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>6</revnumber><date>2007-03-02 18:19:28</date><authorinitials>kinkie</authorinitials><revremark>Markup Fixes</revremark></revision><revision><revnumber>5</revnumber><date>2007-02-06 09:29:31</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>4</revnumber><date>2007-02-06 09:28:34</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>3</revnumber><date>2007-02-06 09:22:08</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>2</revnumber><date>2007-02-05 11:15:19</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>1</revnumber><date>2007-02-05 11:09:58</date><authorinitials>AdrianChadd</authorinitials></revision></revhistory></articleinfo><section><title>New Store API for Squid-2</title><section><title>Introduction</title><para>The Storage API in Squid-2 has many serious shortcomings which limits performance and possibilities. The aim of this particular rewrite isn't to make something thats &quot;next generation&quot; but instead is something &quot;better&quot; than what we have. The replacement Store API should enable further development in other areas of the codebase which will then feed into further storage area development. </para></section><section><title>Current API</title><section><title>Object Lookup / Management</title><itemizedlist><listitem><para><code>StoreEntry * new_StoreEntry(int mem_obj_flag, const char *url)</code> </para></listitem><listitem><para><code>void destroy_StoreEntry(void *data)</code> </para></listitem><listitem><para><code>void storeHashInsert(StoreEntry *e, const cache_key *key)</code> </para></listitem><listitem><para><code>void storeLockObject(StoreEntry *e)</code> </para></listitem><listitem><para><code>void storeReleaseRequest(StoreEntry *e)</code> </para></listitem><listitem><para><code>void storeUnlockObject(StoreEntry *e)</code> </para></listitem><listitem><para><code>StoreEntry * storeGet(const cache_key *key)</code> </para></listitem><listitem><para><code>StoreEntry * storeGetPublic(const char *uri, const method_t method)</code> </para></listitem><listitem><para><code>StoreEntry * storeGetPublicByRequestMethod(request_t * req, const method_t method)</code> </para></listitem><listitem><para><code>StoreEntry * storeGetPublicByRequest(request_t * req)</code> </para></listitem><listitem><para><code>void storeSetPrivateKey(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeAddVary(const char *url, const method_t method, const cache_key * key, const char *etag, const char *vary, const char *vary_headers, const char *accept_encoding)</code> </para></listitem><listitem><para><code>void storeLocateVaryDone(VaryData * data)</code> </para></listitem><listitem><para><code>void storeLocateVary(StoreEntry * e, int offset, const char *vary_data, String accept_encoding, STLVCB * callback, void *cbdata)</code> </para></listitem><listitem><para><code>void storeSetPublicKey(StoreEntry * e)</code> </para></listitem><listitem><para><code>StoreEntry * storeCreateEntry(const char *url, request_flags flags, method_t method)</code> </para></listitem><listitem><para><code>void storeExpireNow(StoreEntry * e)</code> </para></listitem><listitem><para><code>int storeCheckCachable(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeComplete(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeAbort(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeRelease(StoreEntry * e)</code> </para></listitem><listitem><para><code>int storeEntryLocked(const StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeNegativeCache(StoreEntry * e)</code> </para></listitem><listitem><para><code>int storeEntryValidToSend(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeTimestampsSet(StoreEntry * entry)</code> </para></listitem><listitem><para><code>void storeRegisterAbort(StoreEntry * e, STABH * cb, void *data)</code> </para></listitem><listitem><para><code>void storeClientUnregisterAbort(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeSetMemStatus(StoreEntry * e, int new_status)</code> </para></listitem><listitem><para><code>const char * storeUrl(const StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeCreateMemObject(StoreEntry * e, const char *url)</code> </para></listitem><listitem><para><code>void storeBuffer(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeBufferFlush(StoreEntry * e)</code> </para></listitem><listitem><para><code>squid_off_t objectLen(const StoreEntry * e)</code> </para></listitem><listitem><para><code>squid_off_t contentLen(const StoreEntry * e)</code> </para></listitem><listitem><para><code>HttpReply * storeEntryReply(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeEntryReset(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeDeferRead(StoreEntry * e, int fd)</code> </para></listitem><listitem><para><code>void storeResumeRead(StoreEntry * e)</code> </para></listitem><listitem><para><code>void storeResetDefer(StoreEntry * e)</code> </para></listitem></itemizedlist></section><section><title>Client-side</title><itemizedlist><listitem><para><code>store_client * storeClientRegister(StoreEntry *e, void *owner)</code> </para></listitem><listitem><para><code>void storeClientUnregster(store_client *sc, StoreEntry *e, void *owner)</code> </para></listitem><listitem><para><code>void storeClientCopy(store_client *sc, StoreEntry *e, squid_off_t seen_offset, squid_off_t copy_offset, size_t *size, char *buf, STCB *callback, void *data)</code> </para></listitem><listitem><para><code>int storeClientCopyPending(store_client * sc, StoreEntry * e, void *data)</code> </para></listitem><listitem><para><code>squid_off_t storeLowestMemReaderOffset(const StoreEntry * entry)</code> </para></listitem><listitem><para><code>void InvokeHandlers(StoreEntry * e)</code> </para></listitem><listitem><para><code>int storePendingNClients(const StoreEntry * e)</code> </para></listitem></itemizedlist></section><section><title>Server-side</title><itemizedlist><listitem><para><code>void storeAppend(StoreEntry *e, const char *buf, int len)</code> </para></listitem><listitem><para><code>void storeAppendPrintf(StoreEntry * e, const char *fmt,...)</code> </para></listitem><listitem><para><code>void storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)</code> </para></listitem></itemizedlist></section></section><section><title>New API, phase 1</title><section><title>Overview</title><para>The first cut of the API should focus on a small set of issues, namely: </para><itemizedlist><listitem><para>Separation of entity body from entity headers; </para></listitem><listitem><para>Handle the concept of 'trailers' from HTTP/1.1 (ie, arbitrary new headers popping up at some point in the dataflow) </para></listitem><listitem><para>Not involve copying of any data into or out of the store (or, if absolutely necessary, hide the copying behind a sane API that lends itself later to reference counted data access) </para></listitem><listitem><para>O(1) streaming access from any particular offset in the store, with O(N) seek performance for now (which can be optimised out later by arranging the object chunks in a tree of some sort rather than a straight list, but that can come later.) </para></listitem></itemizedlist><para>This first round of API modifications won't cover, very specifically: </para><itemizedlist><listitem><para>Async'ing the <code>storeGet*()</code> interface calls </para></listitem><listitem><para>Fixing up the Vary handling code </para></listitem><listitem><para>Doing intrusive changes to the client or server code to take advantage of the new efficient data copying </para></listitem><listitem><para>Any new object stores, just yet. </para></listitem><listitem><para>A way of tagging objects and pages inside objects as being written, not yet written or not going to written; with an aim to be able to submit entire objects to be read from/written to disk rather than the current store method. It'll probably be something for the second cut of the API. </para></listitem></itemizedlist><para>Stuff that might pop up: </para><itemizedlist><listitem><para>The ability for objects that are on disk to re-enter the memory store, rather than being &quot;disk clients&quot;. This is dangerous and risks thrashing the memory cache somewhat so I'll leave it until the rest of the code has been written. (There's ways around it, possibly, like the ZFS page cache maintaining algorithm which looks like a dual-LRU. I need to find the reference for it.) </para></listitem></itemizedlist></section><section><title>API changes: first set</title><itemizedlist><listitem><para><code>storeAppend()</code> is split into two: </para><itemizedlist><listitem><para><code>storeAppendReplyBody()</code> to append reply body data </para></listitem><listitem><para><code>storeAppendReplyStatus()</code> to set reply status </para></listitem><listitem><para><code>storeAppendReplyAddHeader()</code> to add a header </para></listitem><listitem><para>(if needed, a &quot;remove header&quot; and &quot;insert header&quot; primitives) </para></listitem><listitem><para>finally, a <code>storeAppendHeadersDone()</code> routine to signal we've completed appending the first set of headers and data will begin flowing </para></listitem></itemizedlist></listitem><listitem><para><code>storeClientCopyData()</code> will mirror <code>storeClientCopy()</code> but assume the data starts at offset 0, rather than the reply status + headers being at 0. </para></listitem><listitem><para><code>storeClientGetReply()</code> is an async call which will return a cloned reply (status + headers) plus any data requested, if any is available. (This is so small objects in memory can then be written in one <code>write()</code>, as what happens in previous Squid versions, without having to wait for a second trip through the event loop. </para></listitem><listitem><para>the Store Layer will be handed a <code>MemObject</code> to write out and will first be responsible for writing out the headers any way it sees fit. This'll probably involve using the Packer for the time being to pack the reply+headers into a contiguous memory reigon before writing out. I'll investigate the usefulness of <code>writev()</code> for this little task much later on. </para></listitem><listitem><para>Repair the swap-in logic to actually read the whole header set into memory and parse it rather than assuming it'll fit in a 4k page (and fail, as it does now.) This might need a little thought to do efficiently but it doesn't have to be solved now. </para></listitem></itemizedlist></section></section></section></article>