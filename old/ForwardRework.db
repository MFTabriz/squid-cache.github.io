<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ForwardRework</title><revhistory><revision><revnumber>5</revnumber><date>2015-08-31 08:09:43</date><authorinitials>FrancescoChemolli</authorinitials><revremark>fixed links to bugzilla.</revremark></revision><revision><revnumber>4</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>3</revnumber><date>2008-02-19 00:08:28</date><authorinitials>AmosJeffries</authorinitials><revremark>this is a wishlist feature. maybe even done?</revremark></revision><revision><revnumber>2</revnumber><date>2006-09-11 18:45:45</date><authorinitials>kinkie</authorinitials><revremark>CamelCase fixups</revremark></revision><revision><revnumber>1</revnumber><date>2006-09-10 09:14:43</date><authorinitials>RobertCollins</authorinitials><revremark>draft 1</revremark></revision></revhistory></articleinfo><section><title>Overview</title><para>Currently there is confusion within squid between protocols that we can have in a request: </para><itemizedlist><listitem><para>FTP </para></listitem><listitem><para>HTTP </para></listitem><listitem><para>HTTPS </para></listitem><listitem><para>WAIS </para></listitem><listitem><para>URN </para></listitem><listitem><para>GOPHER </para></listitem><listitem><para>CACHEOBJ </para></listitem></itemizedlist><para>And protocols we have a server implementation of: </para><itemizedlist><listitem><para>HTTPS </para></listitem><listitem><para>HTTP </para></listitem><listitem><para>ICP </para></listitem><listitem><para>HTCP </para></listitem></itemizedlist><para>And protocols we have a client implementation of: </para><itemizedlist><listitem><para>HTTP </para></listitem><listitem><para>HTTPS </para></listitem><listitem><para>URN </para></listitem><listitem><para>GOPHER </para></listitem><listitem><para>FTP </para></listitem></itemizedlist><para>Theres a <ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=1763#">patch</ulink> to break out the server implementations - HTTPS, HTTP, ICP, HTCP. This possibly needs more work to be really polished, and is slated for 3.1. </para><para>Some work has been done on breaking out the protocols we can have in a request into a single clean set of classes, making it modular, but its not finished - and probably cant be until the protocols we implement clients of, and the connection between having a request object and actually handing it off to an external server, are decoupled. </para><para>This proposal tries to provide a consistent api for doing this that will allow: </para><itemizedlist><listitem><para>HTTP and HTTPS peers to be cleanly implemented </para></listitem><listitem><para>Additional peer facilities to be implemented in squid, such as RTSP, or a tunnel-via-SSH peer etc. </para></listitem><listitem><para>Additional URL schemes to be handled without interfering with the core. </para></listitem></itemizedlist></section><section><title>Design</title><para>There are three key ways that requests are handled within squid: </para><itemizedlist><listitem><para>Internally generated data </para></listitem><listitem><para>Hand off to a cache peer via that peers wire protocol </para></listitem><listitem><para>Hand off to a implementation of the requests wire protocol </para></listitem></itemizedlist><para>The scheme field of each request is a reasonably good key to drive this: <code>scheme-&gt;startFetch()</code> will hand the request processing of to whatever the module wants to do. The module will be responsible for ensure that errors etc all occur correctly at this point. </para><para>Internally handled URL schemes will implement startFetch themselves. Most schemes however are not internal, and will instead be a subclass of ForwardableURLScheme. ForwardableURLScheme, for its startFetch method, creates a FwdState and initiates the existing FwdState process. </para><para>That is, a set of peers are selected, based on the peers configuration data - acls, netdb, and our data about the peer - cache digests etc, and possibly via an ICP lookup on the wire to the cache. </para><para>We'll modify this lookup slightly. Firstly, we'll add a method to URLScheme - the type of request-&gt;scheme - called 'protocolClientAvailable'. This will return true if and only if squid has a native implementation of that protocol. If it returns false, we'll require that it get forwarded via a peer. (Consider for instance WAIS, which we do not natively implement. We can only satisfy WAIS via a peer that does implement WAIS.) </para><para>At this point we have a set of peers to try. For each peer (including the direct-access one if that was permitted): </para><itemizedlist><listitem><para>We try to grab a cached ProtocolClient object. This is a generalisation of the current pconn facility. The cache lookup will have to take into consideration requirements such as 'only give this ProtocolClient to the same authenticated user' - to support connection pinning's needs. </para></listitem><listitem><para>If we cannot get a cached ProtocolClient, we initiate a connection to the peer using TCP. </para><itemizedlist><listitem><para>When the connection completes, we call peer-&gt;protocolClientFactory() which is a factory to create a ProtocolClient. We provide the FwdState as an object to refcount-lock, so it can callback when the ProtocolClient is ready for use. (See the HTTPS example for the reason why this is async). By calling the peer's protocolClientFactory method, we allow the direct peer to have a different wire protocol implementation to the wire protocol for communicating with our cache peers (which are all HTTP/HTTPS). So for instance, the direct-peer protocolClientFactory for FTP will construct a FTPProtocolClient. </para></listitem></itemizedlist></listitem><listitem><para>Once we have the ProtocolClient, we either put it in the pool (if the request has been aborted), or we hand off the request to it - <code>protocolClient.handleRequest(request, aForwardState)</code>. This call will create a ProtocolClientRequest immediately - i.e.a FTPClientRequest, or GopherClientRequest - which contains the state needed to satisfy this request. This ProtocolClientRequest will be owned by the ProtocolClient, and will have a refcount reference to the ForwardState, so that it can inform the ForwardState when: </para><itemizedlist><listitem><para>There is a response that is being delivered to the client </para></listitem><listitem><para>The ProtocolClientRequest failed to get a response and the request should be reforwarded </para></listitem><listitem><para>The ProtocolClientRequest failed to get a response and the client should be notified. </para></listitem></itemizedlist><para>These three states do not imply *completion* of the request, rather they change state within ForwardState ForwardState will hold a RefCountReference to ProtocolClientRequest, so that it can request an abort of that request. We create a new ProtocolClientRequest here to allow eventual implementation of pipelining - calling handleRequest severaltimes on a ProtocolClient will pipeline, to that clients ability, those requests. The ProtocolClient will have the protocol's state machine, the ProtocolClientRequest will have the sinks and sources for data for the individual request. It has to be specific to the client, because the URL is irrelevant to the wire level encoding needed. </para></listitem><listitem><para>If the request is aborted by our client, the ForwardState object's abort() method will be called. This should call abort on the ProtocolClientRequest, not on the ProtocolClient. For instance, in a pipeline scenario, a pipelined HttpClientRequest might not have been serialised, so abort() on it could just remove it from the ProtocolClient's queue. When the ProtocolClientRequest is aborted there are two possible states as far as the client is concerned: </para><itemizedlist><listitem><para>The client has been sent some data </para><itemizedlist><listitem><para>The client initiated the abort, and will do whatever cleanup is needed. </para></listitem></itemizedlist></listitem><listitem><para>The client has not been sent data </para><itemizedlist><listitem><para>There is no cleanup to do. </para></listitem></itemizedlist></listitem></itemizedlist><para>So, when ProtocolClientRequest is aborted, it will remove itself from the ProtocolClient request queue, in whatever manner is appropriate, and remove its reference to the forward state object - it will never call the object now. This will drop the reference count on the forward state object, and may allow it to free. The ForwardState object will now remove its reference to the ProtocolClientRequest, allowing the ProtocolClientRequest to free (IF its not still owned by the ProtocolClient, which it may be during cleanup). We may need a self-reference within ForwardState::abort to ensure it does not delete itself during its own lifetime. </para></listitem></itemizedlist></section><section><title>Examples</title><section><title>CONNECT</title><para>The ConnectURLScheme will be a subclass of ForwardableURLScheme Connect will return true for <code>protocolClientAvailable()</code> calls. The protocolClientFactory for connect will go straight into tunnel mode and tell the forward state that its sending data to the client and cannot be reforwarded. There is no CONNECT peer type. </para></section><section><title>HTTP</title><para>The HTTPUrlScheme will be a subclass of ForwardableURLScheme HTTPUrlScheme will return true for <code>protocolClientAvailable()</code> calls. The protocolClientFactory for http will be an instance of HTTPClientFactory. This will return an HTTPClient, which is roughly what HTTPServerState is today, but only the wire level aspects. </para><para>There will be an HTTP Peer subclass. its protocolClientFactory attribute will be the same as the one for HTTPUrlScheme by default. </para></section><section><title>HTTPS</title><para>The HTTPSUrlScheme will be a subclass of ForwardableURLSche,e HTTPUrlSchceme will return true for <code>protocolClientAvailable()</code> calls. HTTPSUrlScheme will only be compiled in when SSL support is enabled. The protocolClientFactory will be a SSLClientFactory parameterised with a HTTPClientFactory instance. SSLClientFactory's take a socket and perform SSL handshaking, after which they call the factory they were parameterised with - so the sequence is: </para><itemizedlist><listitem><para><code>aSSLClientFactory(fd, ProtocolClientRequest *requestor)</code> </para></listitem><listitem><para>Create a SSLClientEndpoint(fd) </para></listitem><listitem><para>Create a SSLConnectionRequest(this, requestor) </para></listitem><listitem><para>call endpointer-&gt;connect(theSSLConnectionRequest) </para></listitem><listitem><para>Handshaking occurs </para></listitem><listitem><para>theSSLConnectionRequest-&gt;connected() is called when the handshaking completes, or -&gt;failed() if it fails to complete. </para></listitem><listitem><para>on error we create return a global instance - FailedSSLProtocolClient, which will generate errors. </para></listitem><listitem><para>on connected() we then call <code>this-&gt;nestedProtocolClientFactory(theSSLClientEndpoint-&gt;fd, theSSLConnectionRequest)</code>. This will create the nested ProtocolClient - i.e. for HTTPS, this creates the HTTPClient, that is actually connected to the SSL client. </para></listitem><listitem><para>The SSLClientEndpoint is given the HTTPClient to own as a reference, like the Socket owns the SSLClientEndpoint. </para></listitem><listitem><para>The SSLClientEndpoint then calls the original Requestor with the HTTPClient. </para></listitem></itemizedlist><para>There will be no HTTPSPeer subclass. Instead HTTPS peers will be an instance of HTTPPeer with the protocolClientFactory set to an instance of SSLClientFactory parameterised with a HTTPClientFactory. </para><para>This means that only one code path will create HTTPS wrappers for clients. This also means we can do Gophers or other such things like tls for any protocol. </para></section><section><title>Gopher</title><para>The GopherURLScheme will be a subclass of ForwardableURLScheme Connect will return true for <code>protocolClientAvailable()</code> calls. The protocolClientFactory for gopher will return a GopherClient object. There is no Gopher peer type, because our gopher implementation cannot forward other protocols. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/ForwardRework/CategoryFeature#">CategoryFeature</ulink> <ulink url="https://wiki.squid-cache.org/ForwardRework/CategoryWish#">CategoryWish</ulink> </para></section></section></article>