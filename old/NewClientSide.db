<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>NewClientSide</title><revhistory><revision><revnumber>5</revnumber><date>2008-05-18 19:38:59</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>4</revnumber><date>2008-02-19 00:33:30</date><authorinitials>AmosJeffries</authorinitials><revremark>this is a wishlist item</revremark></revision><revision><revnumber>3</revnumber><date>2007-03-18 04:38:43</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>2</revnumber><date>2007-03-17 16:28:00</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>1</revnumber><date>2007-03-17 16:20:36</date><authorinitials>AdrianChadd</authorinitials></revision></revhistory></articleinfo><section><title>Another Client Side?</title><para>Or, &quot;a new HTTP server side&quot;, as thats what it is. </para><para>A HTTP server side should implement the following: </para><itemizedlist><listitem><para>Network connection management </para></listitem><listitem><para>Parse requests off the wire; build HTTP server requests </para></listitem><listitem><para>Implement the HTTP server data API to send requests+request body and receive reply messages from a HTTP request </para></listitem><listitem><para>Probably implement SSL </para></listitem></itemizedlist><para>What it might implement: </para><itemizedlist><listitem><para>HTTP authentication? Or could that be implemented between the HTTP network server and the HTTP request queue? </para></listitem><listitem><para>SSL. Thats a connection property. </para></listitem></itemizedlist><para>What it won't implement: </para><itemizedlist><listitem><para>ACL checks: that should be done as part of the HTTP request queue </para></listitem><listitem><para>URL rewriting: that should be done as part of the HTTP request queue </para></listitem><listitem><para>Transfer/Content encoding (deflate/gzip); that should be done as part of the data pipeline. </para></listitem></itemizedlist><section><title>How its made up</title><itemizedlist><listitem><para>The connection manager - handle the FD side of things, buffering, etc. </para></listitem><listitem><para>Individual requests - these are the server-side endpoints for the HTTP request, exchanging HTTP messages with a peer. </para><itemizedlist><listitem><para>The requests will get serialised access to the FD, so multiple requests can be outstanding (pipelining) whilst single replies are written in the correct order </para></listitem></itemizedlist></listitem></itemizedlist></section><section><title>What the general process flow will look like</title><itemizedlist><listitem><para>Request will come in; connection manager + initial request is created </para></listitem><listitem><para>Request is parsed and a HTTP request is queued </para></listitem><listitem><para>If the request has a HTTP request body then the connection is put into &quot;bodyreader&quot; mode until all the body data has been sucked out; else reset and parse the next request, pipelining requests into the HTTP request queue </para></listitem><listitem><para>Requests are notified from the HTTP request (hm, I should really use clearer terminology here) and either begin receiving HTTP messages or generate their own content for error conditions </para></listitem><listitem><para>When a request is finished sending data to the connection it decides whether to pass the torch to the next request (so it can write data out to the FD) or to close the connection. Need to keep request bodies in mind here too. </para></listitem></itemizedlist></section><section><title>How to handle errors?</title><para>Its relatively easy to handle errors in a single-process non-threaded setup - just abort all the outstanding requests and delete the object there and then. This probably won't cut it in a threaded setup, so: </para><itemizedlist><listitem><para>The connection closing shouldn't force the object to immediately disappear - it should go into a CLOSED state </para></listitem><listitem><para>It should hang around until the current pending request has completed or aborted - so it should set some abort flag on the request and wait for it to come back. It might come back almost straight away; it might take a little longer as queued events in other threads get notified that the request is being cancelled </para></listitem><listitem><para>Once all pending requests have been cancelled or have returned -then- the object can move to the DEAD state and be deallocated. </para></listitem></itemizedlist></section><section><title>What about threading?</title><para>In theory the server connections should be self-contained; so multiple threads can run multiplexed server connections without any interthread locking needed. This might not be so true for certain 'things' (such as a shared HTTP authentication cache, DNS requests, etc) but these could be seperate message queues. </para><para>The trick is to keep the server side around long enough to receive all the queued messages it has or be able to cancel them. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/NewClientSide/CategoryFeature#">CategoryFeature</ulink> <ulink url="https://wiki.squid-cache.org/NewClientSide/CategoryWish#">CategoryWish</ulink> </para></section></section></article>