<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/CacheMgrApi</title><revhistory><revision><revnumber>2</revnumber><date>2010-12-26 17:03:33</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Added sample of pack and unpack</revremark></revision><revision><revnumber>1</revnumber><date>2010-12-25 23:45:13</date><authorinitials>FrancescoChemolli</authorinitials><revremark>initial version; work in progress</revremark></revision></revhistory></articleinfo><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> This page is a work in progress. It reflects the discoveries by <ulink url="https://wiki.squid-cache.org/ProgrammingGuide/CacheMgrApi/FrancescoChemolli#">FrancescoChemolli</ulink> as it tries to implement the new cachemgr framework. It may contain inaccurate informations. </para><section><title>Cache Manager API</title><para>This document details how to implement a multi-cpu cache manager action for Squid 3.2+, following the API framework implemented by <ulink url="https://wiki.squid-cache.org/ProgrammingGuide/CacheMgrApi/AlexRousskov#">AlexRousskov</ulink>. </para></section><section><title>Overview</title><para>In order to correctly accumulate information across multi-cpu systems, a framework is needed to accumulate the information across instances so that it can be shown in summarized form to the user. </para><para>To that purpose, a few key classes need to be used </para></section><section><title>Cache Manager Action Data</title><para>It is the blob of information that needs to be passed around instances via IPC mechanisms to accumulate data. Its basic signature is: </para><screen><![CDATA[class MyModuleMgrActionData
{
  MyModuleMgrActionData();
  MyModuleMgrActionData& operator += (const MyModuleMgrActionData&)
]]><![CDATA[
  type1 datamember1;
  type2 datamember2;
  //.. etc
};]]></screen><para>While this signature is not strictly mandatory - as it will be mostly used by the couupled CacheManagerAction class, it is however recommended to use it for consistency. </para></section><section><title>Cache Manager Action</title><para>It is the module which gets activated when the cache manager framework receives some action request by the user. Its basic signature is: </para><screen><![CDATA[#include "mgr/Action.h"
class MyModuleMgrAction : public Mgr::Action
{
protected:
    MyModuleMgrAction(const Mgr::CommandPointer &cmd);
    virtual void collect();
    virtual void dump(StoreEntry* entry);
]]><![CDATA[
public:
    static Pointer Create(const Mgr::CommandPointer &); // factorty method
    virtual void add(const Mgr::Action&);
    virtual void pack(Ipc::TypedMsgHdr&) const;
    virtual void unpack(const Ipc::TypedMsgHdr&);
]]><![CDATA[
private:
    MyModuleMgrActionData data;
};]]></screen><para>where <code>Pointer</code> is defined in <code>Mgr::Action</code> as a refcounted pointer to an action; <code>CommandPointer</code> is, likewise, a refcounted pointer to a command. </para><para>The data member is used to accumulate data across squid instances. Execution flow is: </para><orderedlist numeration="arabic"><listitem><para>one instance gets the cachemgr request; it instantiates a MyModuleMgrAction via its static Create function </para></listitem><listitem><para>(without going in too much detail) this Action's <code>run()</code> method calls each worker's <code>collect()</code> method </para></listitem><listitem><para>collect() is supposed to fill in the data member of the MyModuleMgrAction with whatever data is relevant </para></listitem><listitem><para>data is marshaled back to the coordinator process via <code>pack()</code> and <code>unpack()</code> </para></listitem><listitem><para>the Coordinator process uses the Action's <code>add()</code> method to merge in information from all workers. The Action argument is really a polymorphic reference to the MyModuleMgrAction, and it can safely be dynamic_cast to the right type </para></listitem><listitem><para>once data is accumulated, the <code>dump()</code> method is called to print out the information. </para></listitem></orderedlist><para><code>pack()</code> and <code>unpack()</code> can rely on the generic infrastructure available through the IPC libraries, and so they in general will probably look like this: </para><screen><![CDATA[void
MyModuleMgrAction::pack(Ipc::TypedMsgHdr& msg) const
{
    msg.setType(Ipc::mtCacheMgrResponse);
    msg.putPod(data);
}
]]><![CDATA[
void
MyModuleMgrAction::unpack(const Ipc::TypedMsgHdr& msg)
{
    msg.checkType(Ipc::mtCacheMgrResponse);
    msg.getPod(data);
}]]></screen></section><section><title>Registration</title><para>XXX TODO </para><!--rule (<hr>) is not applicable to DocBook--><para> Discuss this page using the &quot;Discussion&quot; link in the main menu </para></section></article>