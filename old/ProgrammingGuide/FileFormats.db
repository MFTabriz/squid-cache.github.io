<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/FileFormats</title><revhistory><revision><revnumber>2</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 09:04:11</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>File Formats</title><section><title>''swap.state''</title><para>NOTE: this information is current as of version 2.2.STABLE4. </para><para>A <emphasis>swap.state</emphasis> entry is defined by the <emphasis>storeSwapLogData</emphasis> structure, and has the following elements: </para><screen><![CDATA[struct _storeSwapLogData {
    char op;
    int swap_file_number;
    time_t timestamp;
    time_t lastref;
    time_t expires;
    time_t lastmod;
    size_t swap_file_sz;
    u_short refcount;
    u_short flags;
    unsigned char key[MD5_DIGEST_CHARS];
};]]></screen><itemizedlist><listitem><para>op </para><itemizedlist><listitem override="none"><para>Either SWAP_LOG_ADD (1) when an object is added to the disk storage, or SWAP_LOG_DEL (2) when an object is deleted. </para></listitem></itemizedlist></listitem><listitem><para>swap_file_number </para><itemizedlist><listitem override="none"><para>The 32-bit file number which maps to a pathname.  Only the low 24-bits are relevant.  The high 8-bits are used as an index to an array of storage directories, and are set at run time because the order of storage directories may change over time. </para></listitem></itemizedlist></listitem><listitem><para>timestamp </para><itemizedlist><listitem override="none"><para>A 32-bit Unix time value that represents the time when the origin server generated this response.  If the response </para><para>has a valid <emphasis>Date:</emphasis> header, this timestamp corresponds to that time.  Otherwise, it is set to the Squid process time when the response is read (as soon as the end of headers are found). </para></listitem></itemizedlist></listitem><listitem><para>lastref </para><itemizedlist><listitem override="none"><para>The last time that a client requested this object. </para><para>Strictly speaking, this time is set whenver the StoreEntry is locked (via <emphasis>storeLockObject()</emphasis>). </para></listitem></itemizedlist></listitem><listitem><para>expires </para><itemizedlist><listitem override="none"><para>The value of the response's <emphasis>Expires:</emphasis> header, if any. If the response does not have an <emphasis>Expires:</emphasis> header, this is set to -1.  If the response has an invalid (unparseable) <emphasis>Expires:</emphasis> header, it is also set to -1.  There are some cases where Squid sets <emphasis>expires</emphasis> to -2.  This happens for the internal netdb<emphasis> object and for FTP URL responses. </emphasis></para></listitem><listitem><para>lastmod </para><itemizedlist><listitem override="none"><para>The value of the response's Last-modified:</para><emphasis> header, if any. This is set to -1 if there is no </emphasis><para>Last-modified:</para><para><emphasis> header, or if it is unparseable. </emphasis></para></listitem><listitem><para>swap_file_sz </para><itemizedlist><listitem override="none"><para>This is the number of bytes that the object occupies on </para><para>disk.  It includes the Squid swap file header. </para></listitem></itemizedlist></listitem><listitem><para>refcount </para><itemizedlist><listitem override="none"><para>The number of times that this object has been accessed (referenced). Since its a 16-bit quantity, it is susceptible to overflow if a single object is accessed 65,536 times before being replaced. </para></listitem></itemizedlist></listitem><listitem><para>flags </para><itemizedlist><listitem override="none"><para>A copy of the <emphasis>StoreEntry</emphasis> flags field.  Used as a sanity check when rebuilding the cache at startup.  Objects that have the KEY_PRIVATE flag set are not added back to the cache. </para></listitem></itemizedlist></listitem><listitem><para>key </para><itemizedlist><listitem override="none"><para>The 128-bit MD5 hash for this object. </para></listitem></itemizedlist></listitem></itemizedlist><para>Note that <emphasis>storeSwapLogData</emphasis> entries are written in native machine byte order.  They are not necessarily portable across architectures. </para></listitem></itemizedlist></listitem></itemizedlist></section></section><section><title>Store swap metadata Description</title><para><emphasis>swap meta</emphasis> refers to a section of meta data stored at the beginning of an object that is stored on disk.  This meta data includes information such as the object's cache key (MD5), URL, and part of the StoreEntry structure. </para><para>The meta data is stored using a TYPE-LENGTH-VALUE format.  That is, each chunk of meta information consists of a TYPE identifier, a LENGTH field, and then the VALUE (which is LENGTH octets long). </para><section><title>Types</title><para>As of Squid-2.3, the following TYPES are defined (from <emphasis>enums.h</emphasis>): </para><itemizedlist><listitem><para>STORE_META_VOID </para><itemizedlist><listitem override="none"><para>Just a placeholder for the zeroth value.   It is never used on disk. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_KEY_URL </para><itemizedlist><listitem override="none"><para>This represents the case when we use the URL as the cache key, as Squid-1.1 does.  Currently we don't support using a URL as a cache key, so this is not used. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_KEY_SHA </para><itemizedlist><listitem override="none"><para>For a brief time we considered supporting SHA (secure hash algorithm) as a cache key.  Nobody liked it, and this type is not currently used. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_KEY_MD5 </para><itemizedlist><listitem override="none"><para>This represents the MD5 cache key that Squid currently uses. When Squid opens a disk file for reading, it can check that this MD5 matches the MD5 of the user's request.  If not, then something went wrong and this is probably the wrong object. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_URL </para><itemizedlist><listitem override="none"><para>The object's URL.  This also may be matched against a user's request for cache hits to make sure we got the right object. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_STD </para><itemizedlist><listitem override="none"><para>This is the <emphasis>standard metadata</emphasis> for an object.  Really its just this middle chunk of the StoreEntry structure: </para><screen><![CDATA[        time_t timestamp;
        time_t lastref;
        time_t expires;
        time_t lastmod;
        size_t swap_file_sz;
        u_short refcount;
        u_short flags;]]></screen></listitem></itemizedlist></listitem><listitem><para>STORE_META_HITMETERING </para><itemizedlist><listitem override="none"><para>Reserved for future hit-metering (RFC 2227) stuff. </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_VALID </para><itemizedlist><listitem override="none"><para>? </para></listitem></itemizedlist></listitem><listitem><para>STORE_META_END </para><itemizedlist><listitem override="none"><para>Marks the last valid META type. </para></listitem></itemizedlist></listitem></itemizedlist></section><section><title>Implementation Notes</title><para>When writing an object to disk, we must first write the meta data. This is done with a couple of functions.  First, <code>storeSwapMetaPack()</code> takes a <emphasis>StoreEntry</emphasis> as a parameter and returns a <emphasis>tlv</emphasis> linked list.  Second, <code>storeSwapMetaPack()</code> converts the <emphasis>tlv</emphasis> list into a character buffer that we can write. </para><para>Note that the <emphasis>MemObject</emphasis> has a member called <emphasis>swap_hdr_sz</emphasis>. This value is the size of that character buffer; the size of the swap file meta data.  The <emphasis>StoreEntry</emphasis> has a member named <emphasis>swap_file_sz</emphasis> that represents the size of the disk file. Thus, the size of the object content<emphasis> is <screen><![CDATA[StoreEntry->swap_file_sz  - MemObject->swap_hdr_sz;]]></screen><para>Note that the swap file content includes the HTTP reply headers and the HTTP reply body (if any). </para><para>When reading a swap file, there is a similar process to extract the swap meta data.  First, <code>storeSwapMetaUnpack()</code> converts a character buffer into a </para>tlv<emphasis> linked list.  It also tells us the value for </emphasis>MemObject-&gt;swap_hdr_sz<emphasis>. </emphasis></emphasis></para></section></section></article>