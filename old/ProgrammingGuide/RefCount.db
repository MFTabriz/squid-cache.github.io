<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/RefCount</title><revhistory><revision><revnumber>2</revnumber><date>2008-05-18 19:38:57</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 09:00:34</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>Refcount Data Allocator (C++ Only)</title><para>Manual reference counting such as cbdata uses is error prone, and time consuming for the programmer. C++'s operator overloading allows us to create automatic reference counting pointers, that will free objects when they are no longer needed. With some care these  objects can be passed to functions needed Callback Data pointers. </para><section><title>API</title><para>There are two classes involved in the automatic refcouting - a <emphasis>RefCountable</emphasis> class that provides the mechanics for reference counting a given derived class. And a 'RefCount' class that is the smart pointer, and handles const correctness, and tells the RefCountable class of references and dereferences. </para><section><title>RefCountable</title><para>The RefCountable base class defines one abstract function - <code>deleteSelf()</code>. You must implement deleteSelf for each concrete class and. deleteSelf() is a workaround for 'operator delete' not being virtual. delete Self typically looks like: </para><screen><![CDATA[void deleteSelf() const {delete this;}]]></screen></section><section><title>RefCount</title><para>The RefCount template class replaces pointers as parameters and  variables of the class being reference counted. Typically one creates a typedef to aid users. </para><screen><![CDATA[class MyConcrete : public RefCountable {
  public:
    typedef RefCount<MyConcrete> Pointer;
    void deleteSelf() const {delete this;}
};]]></screen><para>Now, one can pass objects of MyConcrete::Pointer around. </para></section><section><title>CBDATA</title><para>To make a refcounting CBDATA class, you need to overload new and delete, include a macro in your class definition, and ensure that some everyone who would call you directly (not as a cbdata callback, but as a normal use), holds a RefCount&lt;&gt; smart pointer to you. </para><screen><![CDATA[ class MyConcrete : public RefCountable {
   public:
     typedef RefCount<MyConcrete> Pointer;
     void * operator new(size_t);
     void operator delete (void *);
     void deleteSelf() const {delete this;}
   private:
     CBDATA_CLASS(MyConcrete);
 };
   
 ...
 /* In your .cc file */
 CBDATA_CLASS_INIT(MyConcrete);
 
 void *
 MyConcrete::operator new (size_t)
 {
   CBDATA_INIT_TYPE(MyConcrete);
   MyConcrete *result = cbdataAlloc(MyConcrete);
   /* Mark result as being owned - we want the refcounter to do the
    * delete call
    */
   cbdataReference(result);
   return result;
 }
   
 void
 MyConcrete::operator delete (void *address)
 {
   MyConcrete *t = static_cast<MyConcrete *>(address);
   cbdataFree(address);
   /* And allow the memory to be freed */
   cbdataReferenceDone (t);
 }]]></screen><para>When no RefCount&lt;MyConcrete&gt; smart pointers exist, the objects delete method will be called. This will run the object destructor, freeing any foreign resources it hold. Then cbdataFree will be called, marking the object as invalid for all the cbdata  functions that it may have queued. When they all return, the actual memory will be returned to the pool. </para></section><section><title>Using the Refcounter</title><para>Allocation and deallocation of refcounted objects (including those of the RefCount template class) must be done via new() and delete(). If a class that will hold an instance of a RefCount &lt;foo&gt; variable does not use delete(), you must assign NULL to the variable before it is freed. Failure to do this will result in memory leaks. You HAVE  been warned. </para><para>Never call delete or deleteSelf on a RefCountable object. You will create a large number of dangling references and squid will segfault eventually. </para><para>Always create at least one RefCount smart pointer, so that the reference counting mechanism will delete the object when it's not needed. </para><para>Do not pass RefCount smart pointers outside the squid memory space. They will invariably segfault when copied. </para><para>If, in a method, all other smart pointer holding objects may be deleted or may set their smart pointers to NULL, then you will be deleted  partway through the method (and thus crash). To prevent this, assign a smart pointer to yourself: </para><screen><![CDATA[void
MyConcrete::aMethod(){
  /* This holds a reference to us */
  Pointer aPointer(this);
  /* This is a method that may mean we don't need to exist anymore */
  someObject->someMethod();
  /* This prevents aPointer being optimised away before this point,
   * and must be the last line in our method 
   */
  aPointer = NULL;
}]]></screen><para>Calling methods via smart pointers is easy just dereference via -&gt; </para><screen><![CDATA[void
SomeObject::someFunction() {
  myConcretePointer->someOtherMethod();
}]]></screen><para>When passing RefCount smart pointers, always pass them as their  native type, never as '*' or as '&amp;<!--RAW HTML: &amp;-->'.  </para></section></section></section></article>