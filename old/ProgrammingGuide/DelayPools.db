<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/DelayPools</title><revhistory><revision><revnumber>2</revnumber><date>2008-05-18 19:39:00</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2007-10-09 15:58:30</date><authorinitials>AlexRousskov</authorinitials><revremark>Moving Delay Pools from ClientStreams page</revremark></revision></revhistory></articleinfo><section><title>Delay Pools</title><section><title>Introduction</title><para>A DelayPool is a Composite used to manage bandwidth for any request assigned to the pool by an access expression. DelayId's are a used to manage the bandwidth on a given request, whereas a DelayPool  manages the bandwidth availability and assigned DelayId's. </para></section><section><title>Extending Delay Pools</title><para>A CompositePoolNode is the base type for all members of a DelayPool. Any child must implement the RefCounting primitives, as well as five delay pool functions: </para><itemizedlist><listitem><para>stats() - provide cachemanager statistics for itself. </para></listitem><listitem><para>dump() - generate squid.conf syntax for the current configuration of the item. </para></listitem><listitem><para>update() - allocate more bandwidth to all buckets in the item. </para></listitem><listitem><para>parse() - accept squid.conf syntax for the item, and configure for use appropriately. </para></listitem><listitem><para>id() - return a DelayId entry for the current item. </para></listitem></itemizedlist><para>A DelayIdComposite is the base type for all delay Id's. Concrete Delay Id's must implement the refcounting primitives, as well as two delay id functions: </para><itemizedlist><listitem><para>bytesWanted() - return the largest amount of bytes that this delay id allows by policy. </para></listitem><listitem><para>bytesIn() - record the use of bandwidth by the request(s) that this delayId is monitoring. Composite creation is currently under design review, so see the </para></listitem></itemizedlist><para>DelayPool class and follow the parse() code path for details. </para></section><section><title>Neat things that could be done.</title><para>With the composite structure, some neat things have become possible. For instance: </para><itemizedlist><listitem><para>Dynamically defined pool arrangements - for instance an aggregate (class 1) combined with the per-class-C-net tracking of a class 3 pool, without the individual host tracking. This differs from a class 3 pool with -1/-1 in the host bucket, because no memory or cpu would be used on hosts, whereas with a class 3 pool, they are allocated and used. </para></listitem><listitem><para>Per request bandwidth limits - a delayId that contains it's own bucket could limit each request independently to a given policy, with no aggregate restrictions. </para></listitem></itemizedlist></section></section></article>