<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/RequestFlow</title><revhistory><revision><revnumber>4</revnumber><date>2013-06-03 03:43:02</date><authorinitials>AmosJeffries</authorinitials><revremark>typo.</revremark></revision><revision><revnumber>3</revnumber><date>2013-06-03 03:42:36</date><authorinitials>AmosJeffries</authorinitials><revremark>update request flow for some changes added in squid-3.</revremark></revision><revision><revnumber>2</revnumber><date>2008-05-18 19:38:59</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 08:01:32</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>Flow of a Typical Request</title><para><emphasis>NOTE: this information is a work in progress. Numbered entries have been updated for Squid-3.</emphasis> </para><orderedlist numeration="arabic"><listitem><para>A client connection is accepted by the <emphasis>Comm::<ulink url="https://wiki.squid-cache.org/ProgrammingGuide/RequestFlow/TcpAcceptor#">TcpAcceptor</ulink></emphasis>, passed to <emphasis>client-side socket support</emphasis> and parsed, </para><itemizedlist><listitem><para>or an internal Squid request is directly created via <emphasis>clientBeginRequest</emphasis>. </para></listitem></itemizedlist></listitem><listitem><para>if the traffic was intercepted, the Host: header validation is performed. </para></listitem><listitem><para>The <ulink url="http://www.squid-cache.org/Doc/config/http_access#">http_access</ulink> controls are checked. The client-side-request builds an ACL state data structure and registers a callback function for notification when access control checking is completed. </para><itemizedlist><listitem><para>authentication may be performed </para></listitem><listitem><para>deny_info redirection may be performed </para></listitem></itemizedlist></listitem><listitem><para>ICAP REQMOD adaptation takes place. </para><itemizedlist><listitem><para>an ICAP response may be produced with any HTTP status. </para></listitem></itemizedlist></listitem><listitem><para>URL-rewrite adaptation takes place. </para><itemizedlist><listitem><para>an HTTP redirect may take place using 3xx HTTP status codes. </para></listitem></itemizedlist></listitem></orderedlist><para><emphasis> the following information is outdated and seems to apply to Squid-2</emphasis> </para><itemizedlist><listitem><para>The client-side-request is forwarded up the client stream to <emphasis>GetMoreData</emphasis> which looks for the requested object in the cache, and or Vary: versions of the same. If is a cache hit, then the client-side registers its interest in the  <emphasis>StoreEntry</emphasis>. Otherwise, Squid needs to forward the request, perhaps with an If-Modified-Since header. </para></listitem><listitem><para>The request-forwarding process begins with <code>protoDispatch</code>.  This function begins the peer selection procedure, which may involve sending ICP queries and receiving ICP replies.  The peer selection procedure also involves checking configuration options such as <emphasis>never_direct</emphasis> and <emphasis>always_direct</emphasis>. </para></listitem><listitem><para>When the ICP replies (if any) have been processed, we end up at <emphasis>protoStart</emphasis>.  This function calls an appropriate protocol-specific function for forwarding the request.  Here we will assume it is an HTTP request. </para></listitem><listitem><para>The HTTP module first opens a connection to the origin server or cache peer.  If there is no idle persistent socket available, a new connection request is given to the Network Communication module with a callback function.  The <code>comm.c</code> routines may try establishing a connection multiple times before giving up. </para></listitem><listitem><para>When a TCP connection has been established, HTTP builds a request buffer and submits it for writing on the socket.  It then registers a read handler to receive and process the HTTP reply. </para></listitem><listitem><para>As the reply is initially received, the HTTP reply headers are parsed and placed into a reply data structure.  As reply data is read, it is appended to the <emphasis>StoreEntry</emphasis>.  Every time data is appended to the <emphasis>StoreEntry</emphasis>, the client-side is notified of the new data via a callback function. The rate at which reading occurs is regulated by the delay pools routines, via the deferred read mechanism. </para></listitem><listitem><para>As the client-side is notified of new data, it copies the data from the StoreEntry and submits it for writing on the client socket. </para></listitem><listitem><para>As data is appended to the <emphasis>StoreEntry</emphasis>, and the client(s) read it, the data may be submitted for writing to disk. </para></listitem><listitem><para>When the HTTP module finishes reading the reply from the upstream server, it marks the <emphasis>StoreEntry</emphasis> as <emphasis>complete</emphasis>. The server socket is either closed or given to the persistent connection pool for future use. </para></listitem><listitem><para>When the client-side has written all of the object data, it unregisters itself from the <emphasis>StoreEntry</emphasis>.  At the same time it either waits for another request from the client, or closes the client connection. </para></listitem></itemizedlist></section><section><title>The Main Loop: comm_select()</title><para>At the core of Squid is the <code>select(2)</code> system call. Squid uses <code>select()</code> or <code>poll(2)</code> or <code>kqueue</code> or <code>epoll</code> or <!--transclusion is not implemented in DocBook formatter-->/dev/poll<!--transclusion is not implemented in DocBook formatter--> to process I/O on all open file descriptors.  Hereafter we'll only use <emphasis>select</emphasis> to refer generically to either system call. </para><para>The <code>select()</code> and <code>poll()</code> system calls work by waiting for I/O events on a set of file descriptors.  Squid only checks for <emphasis>read</emphasis> and <emphasis>write</emphasis> events. Squid knows that it should check for reading or writing when there is a read or write handler registered for a given file descriptor.  Handler functions are registered with the <code>commSetSelect</code> function.  For example: </para><screen><![CDATA[commSetSelect(fd, COMM_SELECT_READ, clientReadRequest, conn, 0);]]></screen><para>In this example, <emphasis>fd</emphasis> is a TCP socket to a client connection.  When there is data to be read from the socket, then the select loop will execute </para><screen><![CDATA[clientReadRequest(fd, conn);]]></screen><para>The I/O handlers are reset every time they are called.  In other words, a handler function must re-register itself with <code>commSetSelect</code> if it wants to continue reading or writing on a file descriptor.  The I/O handler may be canceled before being called by providing NULL arguments, e.g.: </para><screen><![CDATA[commSetSelect(fd, COMM_SELECT_READ, NULL, NULL, 0);]]></screen><para>These I/O handlers (and others) and their associated callback data pointers are saved in the <emphasis>fde</emphasis> data structure: </para><screen><![CDATA[struct _fde {
        ...
        PF *read_handler;
        void *read_data;
        PF *write_handler;
        void *write_data;
        close_handler *close_handler;
        DEFER *defer_check;
        void *defer_data;
};]]></screen><para><emphasis>read_handler</emphasis> and <emphasis>write_handler</emphasis> are called when the file descriptor is ready for reading or writing, respectively.  The <emphasis>close_handler</emphasis> is called when the filedescriptor is closed.   The <emphasis>close_handler</emphasis> is actually a linked list of callback functions to be called. </para><para>In some situations we want to defer reading from a filedescriptor, even though it has data for us to read. This may be the case when data arrives from the server-side faster than it can be written to the client-side.  Before adding a filedescriptor to the <emphasis>read set</emphasis> for select, we call <emphasis>defer_check</emphasis> (if it is non-NULL).  If <emphasis>defer_check</emphasis> returns 1, then we skip the filedescriptor for that time through the select loop. </para><para>These handlers are stored in the <emphasis>FD_ENTRY</emphasis> structure as defined in <code>comm.h</code>.  <code>fd_table[]</code> is the global array of <emphasis>FD_ENTRY</emphasis> structures.  The handler functions are of type <emphasis>PF</emphasis>, which is a typedef: </para><screen><![CDATA[    typedef void (*PF) (int, void *);]]></screen><para>The close handler is really a linked list of handler functions.  Each handler also has an associated pointer <code>(void *data)</code> to some kind of data structure. </para><para><code>comm_select()</code> is the function which issues the select() system call.  It scans the entire <code>fd_table[]</code> array looking for handler functions.  Each file descriptor with a read handler will be set in the <code>fd_set</code> read bitmask. Similarly, write handlers are scanned and bits set for the write bitmask.  <code>select()</code> is then called, and the return read and write bitmasks are scanned for descriptors with pending I/O.  For each ready descriptor, the handler is called.  Note that the handler is cleared from the <emphasis>FD_ENTRY</emphasis> before it is called. </para><para>After each handler is called, <code>comm_select_incoming()</code> is called to process new HTTP and ICP requests. </para><para>Typical read handlers are <code>httpReadReply()</code>, <code>diskHandleRead()</code>, <code>icpHandleUdp()</code>, and <code>ipcache_dnsHandleRead()</code>. Typical write handlers are <code>commHandleWrite()</code>, <code>diskHandleWrite()</code>, and <code>icpUdpReply()</code>. The handler function is set with <code>commSetSelect()</code>, with the exception of the close handlers, which are set with <code>comm_add_close_handler()</code>. </para><para>The close handlers are normally called from <code>comm_close()</code>. The job of the close handlers is to deallocate data structures associated with the file descriptor.  For this reason <code>comm_close()</code> must normally be the last function in a sequence to prevent accessing just-freed memory. </para><para>The timeout and lifetime handlers are called for file descriptors which have been idle for too long.  They are further discussed in a following chapter. </para></section></article>