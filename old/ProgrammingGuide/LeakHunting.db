<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/LeakHunting</title><revhistory><revision><revnumber>7</revnumber><date>2016-09-17 23:18:26</date><authorinitials>AlexRousskov</authorinitials><revremark>Point to the attached valgrind suppressions file.</revremark></revision><revision><revnumber>6</revnumber><date>2016-09-17 23:14:54</date><authorinitials>AlexRousskov</authorinitials><revremark>Detailed valgrind usage and polished. TODO: Attach suppressions file.</revremark></revision><revision><revnumber>5</revnumber><date>2012-09-26 22:50:09</date><authorinitials>AmosJeffries</authorinitials><revremark>mention LeakFinder crash.</revremark></revision><revision><revnumber>4</revnumber><date>2009-02-16 11:23:47</date><authorinitials>FrancescoChemolli</authorinitials><revremark>added information on Valgrind</revremark></revision><revision><revnumber>3</revnumber><date>2009-02-16 11:14:21</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Be a bit more generic, include valgrind</revremark></revision><revision><revnumber>2</revnumber><date>2008-05-18 19:38:59</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 09:04:57</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><para>Memory management is a thorny issue in Squid. Its single-process nature makes it very important no to leak memory in any circumstance, as even a single leaked byte per request can grind a proxy to a halt in a few hours of production useage. </para><section><title>leakFinder</title><itemizedlist><listitem override="none"><informaltable><tgroup cols="2"><colspec colname="col_0"/><colspec colname="col_1"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> </para></entry><entry colsep="1" rowsep="1"><para> Leak Finder is known to crash <ulink url="https://wiki.squid-cache.org/ProgrammingGuide/LeakHunting/Squid-3.3#">Squid-3.3</ulink> and older when AUFS or threading is used. Please use valgrind (below) if you need to debug in those components. </para></entry></row></tbody></tgroup></informaltable></listitem></itemizedlist><para><emphasis>src/leakfinder.c</emphasis> contains some routines useful for debugging and finding memory leaks.  It is not enabled by default.  To enable it, use </para><screen><![CDATA[configure --enable-leakfinder ...]]></screen><para>The module has three public functions: <emphasis>leakAdd</emphasis>, <emphasis>leakFree</emphasis>, and <emphasis>leakTouch</emphasis> Note, these are actually macros that insert <code>__FILE__</code> and <code>__LINE__</code> arguments to the real functions. </para><para><emphasis>leakAdd</emphasis> should be called when a pointer is first created. Usually this follows immediately after a call to malloc or some other memory allocation function.  For example: </para><screen><![CDATA[    ...
    void *p;
    p = malloc(100);
    leakAdd(p);
    ...]]></screen><para><emphasis>leakFree</emphasis> is the opposite.  Call it just before releasing the pointer memory, such as a call to free.  For example: </para><screen><![CDATA[    ...
    leakFree(foo);
    free(foo);
    return;]]></screen><para>NOTE: <emphasis>leakFree</emphasis> aborts with an assertion if you give it a pointer that was never added with <emphasis>leakAdd</emphasis>. </para><para>The definition of a leak is memory that was allocated but never freed.  Thus, to find a leak we need to track the pointer between the time it got allocated and the time when it should have been freed.  Use <emphasis>leakTouch</emphasis> to accomplish this.  You can sprinkle <emphasis>leakTouch</emphasis> calls throughout the code where the pointer is used.  For example: </para><screen><![CDATA[void
myfunc(void *ptr)
{
    ...
    leakTouch(ptr);
    ...
}]]></screen><para>NOTE:  <emphasis>leakTouch</emphasis> aborts with an assertion if you give it a pointer that was never added with <emphasis>leakAdd</emphasis>, or if the pointer was already freed. </para><para>For each pointer tracked, the module remembers the filename, line number, and time of last access.  You can view this data with the cache manager by selecting the <emphasis>leaks</emphasis> option.  You can also do it from the command line: </para><screen><![CDATA[% client mgr:leaks | less]]></screen><para>The way to identify possible leaks is to look at the time of last access.  Pointers that haven't been accessed for a long time are candidates for leaks.  The filename and line numbers tell you where that pointer was last accessed.  If there is a leak, then the bug occurs somewhere after that point of the code. </para></section><section><title>Valgrind</title><para><ulink url="http://valgrind.org/">Valgrind</ulink> is an advanced runtime profiler that can be very useful for finding memory leaks. Unfortunately, if you are not a Squid developer, you will need to work with one to correctly interpret valgrind results because Squid memory usage often triggers false valgrind leak reports. </para><para>Squid can be executed within a valgrind environment &quot;as is&quot;, but to reduce the number of false positives, it is best to <code>./configure</code> Squid <code>--with-valgrind-debug</code>. <code>./configure --disable-optimizations</code> helps when interpreting valgrind reports (but slows Squid down). Disabling memory pools (<ulink url="http://www.squid-cache.org/Doc/config/memory_pools#">memory_pools</ulink> off) further reduces the number of false positives. Another essential technique for minimizing false positives, is using valgrind suppressions. The attached suppressions <ulink url="https://wiki.squid-cache.org/ProgrammingGuide/LeakHunting/ProgrammingGuide/LeakHunting?action=AttachFile&amp;do=get&amp;target=valgrind.supp">file</ulink> will probably be out of date when you need to use it (or will not be compatible with your Squid version), so adjust it as needed. Such adjustments require good understanding of Squid code. </para><para>Here is one way to start Squid under valgrind control: </para><screen><![CDATA[valgrind -v \
    --trace-children=yes \
    --num-callers=50 \
    --log-file=valgrind-%p.log \
    --leak-check=full \
    --leak-resolution=high \
    --show-reachable=yes \
    --gen-suppressions=all \
    --suppressions=etc/valgrind.supp \
    sbin/squid ...]]></screen><para>With the above command line options, detected problems (including leaks) are detailed throughout each valgrind report (one report for each process started by Squid). </para><para>There is a useful summary at the end of a report. For example: </para><screen><![CDATA[==11905== LEAK SUMMARY:
==11905==    definitely lost: 0 bytes in 0 blocks
==11905==    indirectly lost: 0 bytes in 0 blocks
==11905==      possibly lost: 36 bytes in 1 blocks
==11905==    still reachable: 1,905,982 bytes in 111 blocks
==11905==         suppressed: 1,026,644 bytes in 10,263 blocks]]></screen><para>When Squid is <code>./configure</code>d <code>--with-valgrind-debug</code>, the memory usage information reported via the cache manager interface (e.g., <code>squidclient mgr:mem</code>) includes a valgrind report. </para></section></article>