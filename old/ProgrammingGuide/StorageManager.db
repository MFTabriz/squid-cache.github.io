<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/StorageManager</title><revhistory><revision><revnumber>5</revnumber><date>2008-11-02 00:27:39</date><authorinitials>AmosJeffries</authorinitials><revremark>grammer</revremark></revision><revision><revnumber>4</revnumber><date>2008-05-18 19:38:59</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>3</revnumber><date>2006-09-26 14:41:05</date><authorinitials>rpivato</authorinitials><revremark>disabled line numbers with cplusplus parser</revremark></revision><revision><revnumber>2</revnumber><date>2006-09-26 14:02:46</date><authorinitials>rpivato</authorinitials><revremark>add cplusplus wiki-parser</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 08:33:04</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>Storage Manager</title><section><title>Introduction</title><para>The Storage Manager is the glue between client and server sides.  Every object saved in the cache is allocated a <emphasis>StoreEntry</emphasis> structure.  While the object is being accessed, it also has a <emphasis>MemObject</emphasis> structure. </para><para>Squid can quickly locate cached objects because it keeps (in memory) a hash table of all <emphasis>StoreEntry</emphasis>.  The keys for the hash table are MD5 checksums of the objects URI.  In addition there is also a storage policy such as LRU that keeps track of the objects and determines the removal order when space needs to be reclaimed. For the LRU policy this is implemented as a doubly linked list. </para><para>For each object the <emphasis>StoreEntry</emphasis> maps to a cache_dir and location via sdirn and sfilen. For the &quot;ufs&quot; store this file number (sfilen) is converted to a disk pathname by a simple modulo of L2 and L1, but other storage drivers may map sfilen in other ways.  A cache swap file consists of two parts: the cache metadata, and the object data. Note the object data includes the full HTTP reply---headers and body.  The HTTP reply headers are not the same as the cache metadata. </para><para>Client-side requests register themselves with a <emphasis>StoreEntry</emphasis> to be notified when new data arrives.  Multiple clients may receive data via a single <emphasis>StoreEntry</emphasis>.  For POST and PUT request, this process works in reverse.  Server-side functions are notified when additional data is read from the client. </para></section><section><title>Object storage</title><para>To be written... </para></section><section><title>Object retrieval</title><para>To be written... </para></section></section><section><title>Storage Interface</title><section><title>Introduction</title><para>Traditionally, Squid has always used the Unix filesystem (UFS) to store cache objects on disk.  Over the years, the poor performance of UFS has become very obvious.  In most cases, UFS limits Squid to about 30-50 requests per second. Our work indicates that the poor performance is mostly due to the synchronous nature of <code>open()</code> and <code>unlink()</code> system calls, and perhaps thrashing of inode/buffer caches. </para><para>We want to try out our own, customized filesystems with Squid. In order to do that, we need a well-defined interface for the bits of Squid that access the permanent storage devices. We also require tighter control of the replacement policy by each storage module, rather than a single global replacement policy. </para></section><section><title>Build structure</title><para>The storage types live in squid/src/fs/ . Each subdirectory corresponds to the name of the storage type. When a new storage type is implemented configure.in must be updated to autogenerate a Makefile in squid/src/fs/$type/ from a Makefile.in file. </para><para>configure will take a list of storage types through the <emphasis>--enable-store-io</emphasis> parameter. This parameter takes a list of space seperated storage types. For example, --enable-store-io=&quot;ufs coss&quot; . </para><para>Each storage type must create an archive file <code>in squid/src/fs/$type.a</code> . This file is automatically linked into squid at compile time. </para><para>Each storefs must export a function named <code>storeFsSetup_$type()</code>. This function is called at runtime to initialise each storage type. The list of storage types is passed through <code>store_modules.sh</code> to generate the initialisation function <code>storeFsSetup()</code>. This function lives in <code>store_modules.c</code>. </para><para>An example of the automatically generated file: </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><lineannotation><![CDATA[/* automatically generated by ./store_modules.sh ufs coss]]></lineannotation>
<lineannotation><![CDATA[ * do not edit]]></lineannotation>
<lineannotation><![CDATA[ */]]></lineannotation>
<![CDATA[#include ]]><lineannotation><![CDATA["squid.h"]]></lineannotation>

<token><![CDATA[extern]]></token><![CDATA[ ]]><methodname><![CDATA[STSETUP]]></methodname><![CDATA[ ]]><methodname><![CDATA[storeFsSetup_ufs]]></methodname><![CDATA[;]]>
<token><![CDATA[extern]]></token><![CDATA[ ]]><methodname><![CDATA[STSETUP]]></methodname><![CDATA[ ]]><methodname><![CDATA[storeFsSetup_coss]]></methodname><![CDATA[;]]>
<token><![CDATA[void]]></token><![CDATA[ ]]><methodname><![CDATA[storeFsSetup]]></methodname><![CDATA[(]]><token><![CDATA[void]]></token><![CDATA[)]]>
<![CDATA[{]]>
<![CDATA[                ]]><methodname><![CDATA[storeFsAdd]]></methodname><![CDATA[(]]><phrase><![CDATA["]]></phrase><phrase><![CDATA[ufs]]></phrase><phrase><![CDATA["]]></phrase><![CDATA[, ]]><methodname><![CDATA[storeFsSetup_ufs]]></methodname><![CDATA[);]]>
<![CDATA[                ]]><methodname><![CDATA[storeFsAdd]]></methodname><![CDATA[(]]><phrase><![CDATA["]]></phrase><phrase><![CDATA[coss]]></phrase><phrase><![CDATA["]]></phrase><![CDATA[, ]]><methodname><![CDATA[storeFsSetup_coss]]></methodname><![CDATA[);]]>
<![CDATA[}]]>
</programlisting></section><section><title>Initialization of a storage type</title><para>Each storage type initializes through the <code>storeFsSetup_$type()</code> function.  The <code>storeFsSetup_$type()</code> function takes a single argument - a <code>storefs_entry_t</code> pointer. This pointer references the storefs_entry to initialise. A typical setup function is as follows: </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[storeFsSetup_ufs]]></methodname><![CDATA[(]]><methodname><![CDATA[storefs_entry_t]]></methodname><![CDATA[ *]]><methodname><![CDATA[storefs]]></methodname><![CDATA[)]]>
<![CDATA[{]]>
<![CDATA[        ]]><methodname><![CDATA[assert]]></methodname><![CDATA[(!]]><methodname><![CDATA[ufs_initialised]]></methodname><![CDATA[);]]>
<![CDATA[        ]]><methodname><![CDATA[storefs]]></methodname><![CDATA[->]]><methodname><![CDATA[parsefunc]]></methodname><![CDATA[ = ]]><methodname><![CDATA[storeUfsDirParse]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><methodname><![CDATA[storefs]]></methodname><![CDATA[->]]><methodname><![CDATA[reconfigurefunc]]></methodname><![CDATA[ = ]]><methodname><![CDATA[storeUfsDirReconfigure]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><methodname><![CDATA[storefs]]></methodname><![CDATA[->]]><methodname><![CDATA[donefunc]]></methodname><![CDATA[ = ]]><methodname><![CDATA[storeUfsDirDone]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><methodname><![CDATA[ufs_state_pool]]></methodname><![CDATA[ = ]]><methodname><![CDATA[memPoolCreate]]></methodname><![CDATA[(]]><phrase><![CDATA["]]></phrase><phrase><![CDATA[UFS IO State data]]></phrase><phrase><![CDATA["]]></phrase><![CDATA[, ]]><token><![CDATA[sizeof]]></token><![CDATA[(]]><methodname><![CDATA[ufsstate_t]]></methodname><![CDATA[));]]>
<![CDATA[        ]]><methodname><![CDATA[ufs_initialised]]></methodname><![CDATA[ = 1;]]>
<![CDATA[}]]>
</programlisting><para>There are five function pointers in the storefs_entry which require initializing. In this example, some protection is made against the setup function being called twice, and a memory pool is initialised for use inside the storage module. </para><para>Each function will be covered below. </para><section><title>done</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STFSSHUTDOWN]]></methodname><![CDATA[(]]><token><![CDATA[void]]></token><![CDATA[);]]>
</programlisting><para>This function is called whenever the storage system is to be shut down. It should take care of deallocating any resources currently allocated. </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STFSPARSE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[index]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[path]]></methodname><![CDATA[);]]>

<token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STFSRECONFIGURE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[index]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[path]]></methodname><![CDATA[);]]>
</programlisting><para>These functions handle configuring and reconfiguring a storage directory. Additional arguments from the cache_dir configuration line can be retrieved through calls to strtok() and GetInteger(). </para><para><emphasis>STFSPARSE</emphasis> has the task of initialising a new swapdir. It should parse the remaining arguments on the cache_dir line, initialise the relevant function pointers and data structures, and choose the replacement policy. <emphasis>STFSRECONFIGURE</emphasis> deals with reconfiguring an active swapdir.  It should parse the remaining arguments on the cache_dir line and change any active configuration parameters. The actual storage initialisation is done through the <emphasis>STINIT</emphasis> function pointer in the SwapDir. </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_SwapDir]]></methodname><![CDATA[ {]]>
<![CDATA[        ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[type]]></methodname><![CDATA[;                             ]]><lineannotation><![CDATA[/* Pointer to the store dir type string */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[cur_size]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* Current swapsize in kb */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[low_size]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* ?? */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[max_size]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* Maximum swapsize in kb */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[path]]></methodname><![CDATA[;                             ]]><lineannotation><![CDATA[/* Path to store */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[index]]></methodname><![CDATA[;                              ]]><lineannotation><![CDATA[/* This entry's index into the swapDir array */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[suggest]]></methodname><![CDATA[;                            ]]><lineannotation><![CDATA[/* Suggestion for UFS style stores (??) */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[max_objsize]]></methodname><![CDATA[;                     ]]><lineannotation><![CDATA[/* Maximum object size for this store */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[union]]></token><![CDATA[ {                                 ]]><lineannotation><![CDATA[/* Replacement policy-specific fields */]]></lineannotation>
<![CDATA[        #ifdef HEAP_REPLACEMENT]]>
<![CDATA[                ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                        ]]><methodname><![CDATA[heap]]></methodname><![CDATA[ *]]><methodname><![CDATA[heap]]></methodname><![CDATA[;]]>
<![CDATA[                } ]]><methodname><![CDATA[heap]]></methodname><![CDATA[;]]>
<![CDATA[        #endif]]>
<![CDATA[                ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                        ]]><methodname><![CDATA[dlink_list]]></methodname><![CDATA[ ]]><methodname><![CDATA[list]]></methodname><![CDATA[;]]>
<![CDATA[                        ]]><methodname><![CDATA[dlink_node]]></methodname><![CDATA[ *]]><methodname><![CDATA[walker]]></methodname><![CDATA[;]]>
<![CDATA[                } ]]><methodname><![CDATA[lru]]></methodname><![CDATA[;]]>
<![CDATA[        } ]]><methodname><![CDATA[repl]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[removals]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[scanned]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><token><![CDATA[unsigned]]></token><![CDATA[ ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[selected]]></methodname><![CDATA[:1;        ]]><lineannotation><![CDATA[/* Currently selected for write */]]></lineannotation>
<![CDATA[                ]]><token><![CDATA[unsigned]]></token><![CDATA[ ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[read_only]]></methodname><![CDATA[:1;       ]]><lineannotation><![CDATA[/* This store is read only */]]></lineannotation>
<![CDATA[        } ]]><methodname><![CDATA[flags]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><methodname><![CDATA[STINIT]]></methodname><![CDATA[ *]]><methodname><![CDATA[init]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* Initialise the fs */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STNEWFS]]></methodname><![CDATA[ *]]><methodname><![CDATA[newfs]]></methodname><![CDATA[;                         ]]><lineannotation><![CDATA[/* Create a new fs */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STDUMP]]></methodname><![CDATA[ *]]><methodname><![CDATA[dump]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* Dump fs config snippet */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STFREE]]></methodname><![CDATA[ *]]><methodname><![CDATA[freefs]]></methodname><![CDATA[;                         ]]><lineannotation><![CDATA[/* Free the fs data */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STDBLCHECK]]></methodname><![CDATA[ *]]><methodname><![CDATA[dblcheck]]></methodname><![CDATA[;                   ]]><lineannotation><![CDATA[/* Double check the obj integrity */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STSTATFS]]></methodname><![CDATA[ *]]><methodname><![CDATA[statfs]]></methodname><![CDATA[;                       ]]><lineannotation><![CDATA[/* Dump fs statistics */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STMAINTAINFS]]></methodname><![CDATA[ *]]><methodname><![CDATA[maintainfs]]></methodname><![CDATA[;               ]]><lineannotation><![CDATA[/* Replacement maintainence */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STCHECKOBJ]]></methodname><![CDATA[ *]]><methodname><![CDATA[checkob]]></methodname><![CDATA[;                    ]]><lineannotation><![CDATA[/* Check if the fs will store an object, and get the FS load */]]></lineannotation>
<![CDATA[        ]]><lineannotation><![CDATA[/* These two are notifications */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STREFOBJ]]></methodname><![CDATA[ *]]><methodname><![CDATA[refobj]]></methodname><![CDATA[;                       ]]><lineannotation><![CDATA[/* Reference this object */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STUNREFOBJ]]></methodname><![CDATA[ *]]><methodname><![CDATA[unrefobj]]></methodname><![CDATA[;                   ]]><lineannotation><![CDATA[/* Unreference this object */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STCALLBACK]]></methodname><![CDATA[ *]]><methodname><![CDATA[callback]]></methodname><![CDATA[;                   ]]><lineannotation><![CDATA[/* Handle pending callbacks */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STSYNC]]></methodname><![CDATA[ *]]><methodname><![CDATA[sync]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* Sync the directory */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><methodname><![CDATA[STOBJCREATE]]></methodname><![CDATA[ *]]><methodname><![CDATA[create]]></methodname><![CDATA[;            ]]><lineannotation><![CDATA[/* Create a new object */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STOBJOPEN]]></methodname><![CDATA[ *]]><methodname><![CDATA[open]]></methodname><![CDATA[;                ]]><lineannotation><![CDATA[/* Open an existing object */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STOBJCLOSE]]></methodname><![CDATA[ *]]><methodname><![CDATA[close]]></methodname><![CDATA[;              ]]><lineannotation><![CDATA[/* Close an open object */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STOBJREAD]]></methodname><![CDATA[ *]]><methodname><![CDATA[read]]></methodname><![CDATA[;                ]]><lineannotation><![CDATA[/* Read from an open object */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STOBJWRITE]]></methodname><![CDATA[ *]]><methodname><![CDATA[write]]></methodname><![CDATA[;              ]]><lineannotation><![CDATA[/* Write to a created object */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STOBJUNLINK]]></methodname><![CDATA[ *]]><methodname><![CDATA[unlink]]></methodname><![CDATA[;            ]]><lineannotation><![CDATA[/* Remove the given object */]]></lineannotation>
<![CDATA[        } ]]><methodname><![CDATA[obj]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><methodname><![CDATA[STLOGOPEN]]></methodname><![CDATA[ *]]><methodname><![CDATA[open]]></methodname><![CDATA[;                ]]><lineannotation><![CDATA[/* Open the log */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STLOGCLOSE]]></methodname><![CDATA[ *]]><methodname><![CDATA[close]]></methodname><![CDATA[;              ]]><lineannotation><![CDATA[/* Close the log */]]></lineannotation>
<![CDATA[                ]]><methodname><![CDATA[STLOGWRITE]]></methodname><![CDATA[ *]]><methodname><![CDATA[write]]></methodname><![CDATA[;              ]]><lineannotation><![CDATA[/* Write to the log */]]></lineannotation>
<![CDATA[                ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                        ]]><methodname><![CDATA[STLOGCLEANOPEN]]></methodname><![CDATA[ *]]><methodname><![CDATA[open]]></methodname><![CDATA[;   ]]><lineannotation><![CDATA[/* Open a clean log */]]></lineannotation>
<![CDATA[                        ]]><methodname><![CDATA[STLOGCLEANWRITE]]></methodname><![CDATA[ *]]><methodname><![CDATA[write]]></methodname><![CDATA[; ]]><lineannotation><![CDATA[/* Write to the log */]]></lineannotation>
<![CDATA[                        ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[state]]></methodname><![CDATA[;            ]]><lineannotation><![CDATA[/* Current state */]]></lineannotation>
<![CDATA[                } ]]><methodname><![CDATA[clean]]></methodname><![CDATA[;]]>
<![CDATA[        } ]]><methodname><![CDATA[log]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[fsdata]]></methodname><![CDATA[;                           ]]><lineannotation><![CDATA[/* FS-specific data */]]></lineannotation>
<![CDATA[};]]>
</programlisting></section></section><section><title>Operation of a storage module</title><para>Squid understands the concept of multiple diverse storage directories. Each storage directory provides a caching object store, with object storage, retrieval, indexing and replacement. </para><para>Each open object has associated with it a <emphasis>storeIOState</emphasis> object. The <emphasis>storeIOState</emphasis> object is used to record the state of the current object. Each <emphasis>storeIOState</emphasis> can have a storage module specific data structure containing information private to the storage module. </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_storeIOState]]></methodname><![CDATA[ {]]>
<![CDATA[        ]]><methodname><![CDATA[sdirno]]></methodname><![CDATA[ ]]><methodname><![CDATA[swap_dirn]]></methodname><![CDATA[;               ]]><lineannotation><![CDATA[/* SwapDir index */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[sfileno]]></methodname><![CDATA[ ]]><methodname><![CDATA[swap_filen]]></methodname><![CDATA[;             ]]><lineannotation><![CDATA[/* Unique file index number */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[;                  ]]><lineannotation><![CDATA[/* Pointer to parent StoreEntry */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[mode_t]]></token><![CDATA[ ]]><methodname><![CDATA[mode]]></methodname><![CDATA[;                    ]]><lineannotation><![CDATA[/* Mode - O_RDONLY or O_WRONLY */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[st_size]]></methodname><![CDATA[;                 ]]><lineannotation><![CDATA[/* Size of the object if known */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[off_t]]></token><![CDATA[ ]]><methodname><![CDATA[offset]]></methodname><![CDATA[;                   ]]><lineannotation><![CDATA[/* current _on-disk_ offset pointer */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STFNCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[file_callback]]></methodname><![CDATA[;          ]]><lineannotation><![CDATA[/* called on delayed sfileno assignments */]]></lineannotation>
<![CDATA[        ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[callback]]></methodname><![CDATA[;               ]]><lineannotation><![CDATA[/* IO Error handler callback */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[callback_data]]></methodname><![CDATA[;            ]]><lineannotation><![CDATA[/* IO Error handler callback data */]]></lineannotation>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><methodname><![CDATA[STRCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[callback]]></methodname><![CDATA[;        ]]><lineannotation><![CDATA[/* Read completion callback */]]></lineannotation>
<![CDATA[                ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[callback_data]]></methodname><![CDATA[;    ]]><lineannotation><![CDATA[/* Read complation callback data */]]></lineannotation>
<![CDATA[        } ]]><methodname><![CDATA[read]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><token><![CDATA[unsigned]]></token><![CDATA[ ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[closing]]></methodname><![CDATA[:1; ]]><lineannotation><![CDATA[/* debugging aid */]]></lineannotation>
<![CDATA[        } ]]><methodname><![CDATA[flags]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[fsstate]]></methodname><![CDATA[;                  ]]><lineannotation><![CDATA[/* pointer to private fs state */]]></lineannotation>
<![CDATA[};]]>
</programlisting><para>Each <emphasis>SwapDir</emphasis> has the concept of a maximum object size. This is used as a basic hint to the storage layer in first choosing a suitable <emphasis>SwapDir</emphasis>. The checkobj function is then called for suitable candidate <emphasis>SwapDirs</emphasis> to find out whether it wants to store a given <emphasis>StoreEntry</emphasis>. A <emphasis>maxobjsize</emphasis> of -1 means 'any size'. </para><para>The specific filesystem operations listed in the SwapDir object are covered below. </para><section><title>initfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token><![CDATA[ ]]><methodname><![CDATA[STINIT]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>Initialise the given <emphasis>SwapDir</emphasis>. Operations such as verifying and rebuilding the storage and creating any needed bitmaps are done here. </para></section><section><title>newfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STNEWFS]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>Called for each configured <emphasis>SwapDir</emphasis> to perform filesystem initialisation. This happens when '-z' is given to squid on the command line. </para></section><section><title>dumpfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STDUMP]]></methodname><![CDATA[(]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[, ]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>Dump the FS specific configuration data of the current <emphasis>SwapDir</emphasis> to the given <emphasis>StoreEntry</emphasis>.  Used to grab a configuration file dump from th <emphasis>cachemgr</emphasis> interface. </para><para>Note: The printed options should start with a space character to separate them from the cache_dir path. </para></section><section><title>freefs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STFREE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>Free the <emphasis>SwapDir</emphasis> filesystem information. This routine should deallocate <emphasis>SD-&gt;fsdata</emphasis>. </para></section><section><title>doublecheckfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[int]]></token>
<methodname><![CDATA[STDBLCHECK]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[);]]>
</programlisting><para>Double-check the given object for validity. Called during rebuild if the '-S' flag is given to squid on the command line. Returns 1 if the object is indeed valid, and 0 if the object is found invalid. </para></section><section><title>statfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STSTATFS]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[);]]>
</programlisting><para>Called to retrieve filesystem statistics, such as usage, load and errors. The information should be appended to the passed <emphasis>StoreEntry</emphasis> e. </para></section><section><title>maintainfs</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STMAINTAINFS]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>Called periodically to replace objects. The active replacement policy should be used to timeout unused objects in order to make room for new objects. </para></section><section><title>callback</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STCALLBACK]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>This function is called inside the comm_select/comm_poll loop to handle any callbacks pending. </para></section><section><title>sync</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STSYNC]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[);]]>
</programlisting><para>This function is called whenever a sync to disk is required. This function should not return until all pending data has been flushed to disk. </para></section><section><title>parse/reconfigure</title></section><section><title>checkobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[int]]></token>
<methodname><![CDATA[STCHECKOBJ]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[);]]>
</programlisting><para>Called by <code>storeDirSelectSwapDir()</code> to determine whether the <emphasis>SwapDir</emphasis> will store the given <emphasis>StoreEntry</emphasis> object. If the <emphasis>SwapDir</emphasis> is not willing to store the given <emphasis>StoreEntry</emphasis> -1 should be returned. Otherwise, a value between 0 and 1000 should be returned indicating the current IO load. A value of 1000 indicates the <emphasis>SwapDir</emphasis> has an IO load of 100%. This is used by <code>storeDirSelectSwapDir()</code> to choose the <emphasis>SwapDir</emphasis> with the lowest IO load. </para></section><section><title>referenceobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STREFOBJ]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[);]]>
</programlisting><para>Called whenever an object is locked by <code>storeLockObject()</code>. It is typically used to update the objects position in the replacement policy. </para></section><section><title>unreferenceobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STUNREFOBJ]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[);]]>
</programlisting><para>Called whenever the object is unlocked by <code>storeUnlockObject()</code> and the lock count reaches 0. It is also typically used to update the objects position in the replacement policy. </para></section><section><title>createobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]>
<methodname><![CDATA[STOBJCREATE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[, ]]><methodname><![CDATA[STFNCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[file_callback]]></methodname><![CDATA[, ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[io_callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[io_callback_data]]></methodname><![CDATA[);]]>
</programlisting><para>Create an object in the <emphasis>SwapDir</emphasis> *SD. <emphasis>file_callback</emphasis> is called whenever the filesystem allocates or reallocates the <emphasis>swap_filen</emphasis>. Note - <emphasis>STFNCB</emphasis> is called with a generic cbdata pointer, which points to the <emphasis>StoreEntry</emphasis> e.  The <emphasis>StoreEntry</emphasis> should not be modified EXCEPT for the replacement policy fields. </para><para>The IO callback should be called when an error occurs and when the object is closed. Once the IO callback is called, the <emphasis>storeIOState</emphasis> becomes invalid. </para><para><emphasis>STOBJCREATE</emphasis> returns a <emphasis>storeIOState</emphasis> suitable for writing on sucess, or NULL if an error occurs. </para></section><section><title>openobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]>
<methodname><![CDATA[STOBJOPEN]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[, ]]><methodname><![CDATA[STFNCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[file_callback]]></methodname><![CDATA[, ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[io_callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[io_callback_data]]></methodname><![CDATA[);]]>
</programlisting><para>Open the <emphasis>StoreEntry</emphasis> in <emphasis>SwapDir</emphasis> *SD for reading. Much the same is applicable from <emphasis>STOBJCREATE</emphasis>, the major difference being that the data passed to <emphasis>file_callback</emphasis> is the relevant <emphasis>store_client</emphasis> . </para></section><section><title>closeobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STOBJCLOSE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[);]]>
</programlisting><para>Close an opened object. The <emphasis>STIOCB</emphasis> callback should be called at the end of this routine. </para></section><section><title>readobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STOBJREAD]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[buf]]></methodname><![CDATA[, ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[size]]></methodname><![CDATA[, ]]><token><![CDATA[off_t]]></token><![CDATA[ ]]><methodname><![CDATA[offset]]></methodname><![CDATA[, ]]><methodname><![CDATA[STRCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[read_callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[read_callback_data]]></methodname><![CDATA[);]]>
</programlisting><para>Read part of the object of into <emphasis>buf</emphasis>. It is safe to request a read when there are other pending reads or writes. <emphasis>STRCB</emphasis> is called at completion. </para><para>If a read operation fails, the filesystem layer notifies the calling module by calling the <emphasis>STIOCB</emphasis> callback with an error status code. </para></section><section><title>writeobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STOBJWRITE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *]]><methodname><![CDATA[SD]]></methodname><![CDATA[, ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[buf]]></methodname><![CDATA[, ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[size]]></methodname><![CDATA[, ]]><token><![CDATA[off_t]]></token><![CDATA[ ]]><methodname><![CDATA[offset]]></methodname><![CDATA[, ]]><methodname><![CDATA[FREE]]></methodname><![CDATA[ *]]><methodname><![CDATA[freefunc]]></methodname><![CDATA[);]]>
</programlisting><para>Write the given block of data to the given store object. <emphasis>buf</emphasis> is allocated by the caller. When the write is complete, the data is freed through <emphasis>free_func</emphasis>. </para><para>If a write operation fails, the filesystem layer notifies the calling module by calling the <emphasis>STIOCB</emphasis> callback with an error status code. </para></section><section><title>unlinkobj</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[void]]></token>
<methodname><![CDATA[STOBJUNLINK]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *);]]>
</programlisting><para>Remove the <emphasis>StoreEntry</emphasis> e from the <emphasis>SwapDir</emphasis> SD and the replacement policy. </para></section></section><section><title>Store IO calls</title><para>These routines are used inside the storage manager to create and retrieve objects from a storage directory. </para><section><title>storeCreate()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]>
<methodname><![CDATA[storeCreate]]></methodname><![CDATA[(]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[, ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[file_callback]]></methodname><![CDATA[, ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[close_callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ * ]]><methodname><![CDATA[callback_data]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeCreate</code> is called to store the given <emphasis>StoreEntry</emphasis> in a storage directory. </para><para><code>callback</code> is a function that will be called either when an error is encountered, or when the object is closed (by calling <code>storeClose()</code>).  If the open request is successful, there is no callback.  The calling module must assume the open request will succeed, and may begin reading or writing immediately. </para><para><code>storeCreate()</code> may return NULL if the requested object can not be created.  In this case the <code>callback</code> function will not be called. </para></section><section><title>storeOpen()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]>
<methodname><![CDATA[storeOpen]]></methodname><![CDATA[(]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[, ]]><methodname><![CDATA[STFNCB]]></methodname><![CDATA[ * ]]><methodname><![CDATA[file_callback]]></methodname><![CDATA[, ]]><methodname><![CDATA[STIOCB]]></methodname><![CDATA[ * ]]><methodname><![CDATA[callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[callback_data]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeOpen</code> is called to open the given <emphasis>StoreEntry</emphasis> from the storage directory it resides on. </para><para><code>callback</code> is a function that will be called either when an error is encountered, or when the object is closed (by calling <code>storeClose()</code>).  If the open request is successful, there is no callback.  The calling module must assume the open request will succeed, and may begin reading or writing immediately. </para><para><code>storeOpen()</code> may return NULL if the requested object can not be openeed.  In this case the <code>callback</code> function will not be called. </para></section><section><title>storeRead()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[storeRead]]></methodname><![CDATA[(]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[buf]]></methodname><![CDATA[, ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[size]]></methodname><![CDATA[, ]]><token><![CDATA[off_t]]></token><![CDATA[ ]]><methodname><![CDATA[offset]]></methodname><![CDATA[, ]]><methodname><![CDATA[STRCB]]></methodname><![CDATA[ *]]><methodname><![CDATA[callback]]></methodname><![CDATA[, ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[callback_data]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeRead()</code> is more complicated than the other functions because it requires its own callback function to notify the caller when the requested data has actually been read. <emphasis>buf</emphasis> must be a valid memory buffer of at least <emphasis>size</emphasis> bytes.  <emphasis>offset</emphasis> specifies the byte offset where the read should begin.  Note that with the Swap Meta Headers prepended to each cache object, this offset does not equal the offset into the actual object data. </para><para>The caller is responsible for allocating and freeing <emphasis>buf</emphasis> . </para></section><section><title>storeWrite()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[storeWrite]]></methodname><![CDATA[(]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[, ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[buf]]></methodname><![CDATA[, ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[size]]></methodname><![CDATA[, ]]><token><![CDATA[off_t]]></token><![CDATA[ ]]><methodname><![CDATA[offset]]></methodname><![CDATA[, ]]><methodname><![CDATA[FREE]]></methodname><![CDATA[ *]]><methodname><![CDATA[free_func]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeWrite()</code> submits a request to write a block of data to the disk store. The caller is responsible for allocating <emphasis>buf</emphasis>, but since there is no per-write callback, this memory must be freed by the lower filesystem implementation.  Therefore, the caller must specify the <emphasis>free_func</emphasis> to be used to deallocate the memory. </para><para>If a write operation fails, the filesystem layer notifies the calling module by calling the <emphasis>STIOCB</emphasis> callback with an error status code. </para></section><section><title>storeUnlink()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[storeUnlink]]></methodname><![CDATA[(]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[e]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeUnlink()</code> removes the cached object from the disk store.  There is no callback function, and the object does not need to be opened first.  The filesystem layer will remove the object if it exists on the disk. </para></section><section><title>storeOffset()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[off_t]]></token>
<methodname><![CDATA[storeOffset]]></methodname><![CDATA[(]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[)]]>
</programlisting><para><code>storeOffset()</code> returns the current _ondisk_ offset. This is used to determine how much of an objects memory can be freed to make way for other in-transit and cached objects. You must make sure that the <emphasis>storeIOState-&gt;offset</emphasis> refers to the ondisk offset, or undefined results will occur. For reads, this returns the current offset of successfully read data, not including queued reads. </para></section></section><section><title>Callbacks</title><section><title>STIOCB callback</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[stiocb]]></methodname><![CDATA[(]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[data]]></methodname><![CDATA[, ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[errorflag]]></methodname><![CDATA[, ]]><methodname><![CDATA[storeIOState]]></methodname><![CDATA[ *]]><methodname><![CDATA[sio]]></methodname><![CDATA[)]]>
</programlisting><para>The <emphasis>stiocb</emphasis> function is passed as a parameter to <code>storeOpen()</code>.  The filesystem layer calls <emphasis>stiocb</emphasis> either when an I/O error occurs, or when the disk object is closed. </para><para><emphasis>errorflag</emphasis> is one of the following: </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><![CDATA[#define DISK_OK                   (0)]]>
<![CDATA[#define DISK_ERROR               (-1)]]>
<![CDATA[#define DISK_EOF                 (-2)]]>
<![CDATA[#define DISK_NO_SPACE_LEFT       (-6)]]>

</programlisting><para>Once the The <emphasis>stiocb</emphasis> function has been called, the <emphasis>sio</emphasis> structure should not be accessed further. </para></section><section><title>STRCB callback</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[strcb]]></methodname><![CDATA[(]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[data]]></methodname><![CDATA[, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[buf]]></methodname><![CDATA[, ]]><token><![CDATA[size_t]]></token><![CDATA[ ]]><methodname><![CDATA[len]]></methodname><![CDATA[)]]>
</programlisting><para>The <emphasis>strcb</emphasis> function is passed as a parameter to <code>storeRead()</code>.  The filesystem layer calls <emphasis>strcb</emphasis> after a block of data has been read from the disk and placed into <emphasis>buf</emphasis>.  <emphasis>len</emphasis> indicates how many bytes were placed into <emphasis>buf</emphasis>.  The <emphasis>strcb</emphasis> function is only called if the read operation is successful.  If it fails, then the <emphasis>STIOCB</emphasis> callback will be called instead. </para></section></section><section><title>State Logging</title><para>These functions deal with state logging and related tasks for a squid storage system. These functions are used (called) in <code>store_dir.c</code>. </para><para>Each storage system must provide the functions described in this section, although it may be a no-op (null) function that does nothing.  Each function is accessed through a function pointer stored in the <emphasis>SwapDir</emphasis> structure: </para><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><![CDATA[    ]]><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_SwapDir]]></methodname><![CDATA[ {]]>
<![CDATA[        ...]]>
<![CDATA[        ]]><methodname><![CDATA[STINIT]]></methodname><![CDATA[ *]]><methodname><![CDATA[init]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><methodname><![CDATA[STNEWFS]]></methodname><![CDATA[ *]]><methodname><![CDATA[newfs]]></methodname><![CDATA[;]]>
<![CDATA[        ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[            ]]><methodname><![CDATA[STLOGOPEN]]></methodname><![CDATA[ *]]><methodname><![CDATA[open]]></methodname><![CDATA[;]]>
<![CDATA[            ]]><methodname><![CDATA[STLOGCLOSE]]></methodname><![CDATA[ *]]><methodname><![CDATA[close]]></methodname><![CDATA[;]]>
<![CDATA[            ]]><methodname><![CDATA[STLOGWRITE]]></methodname><![CDATA[ *]]><methodname><![CDATA[write]]></methodname><![CDATA[;]]>
<![CDATA[            ]]><token><![CDATA[struct]]></token><![CDATA[ {]]>
<![CDATA[                ]]><methodname><![CDATA[STLOGCLEANOPEN]]></methodname><![CDATA[ *]]><methodname><![CDATA[open]]></methodname><![CDATA[;]]>
<![CDATA[                ]]><methodname><![CDATA[STLOGCLEANWRITE]]></methodname><![CDATA[ *]]><methodname><![CDATA[write]]></methodname><![CDATA[;]]>
<![CDATA[                ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[state]]></methodname><![CDATA[;]]>
<![CDATA[            } ]]><methodname><![CDATA[clean]]></methodname><![CDATA[;]]>
<![CDATA[        } ]]><methodname><![CDATA[log]]></methodname><![CDATA[;]]>
<![CDATA[        ....]]>
<![CDATA[    };]]>
</programlisting><section><title>log.open()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[STLOGOPEN]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *);]]>
</programlisting><para>The <code>log.open</code> function, of type <emphasis>STLOGOPEN</emphasis>, is used to open or initialize the state-holding log files (if any) for the storage system.  For UFS this opens the <emphasis>swap.state</emphasis> files. </para><para>The <code>log.open</code> function may be called any number of times during Squid's execution.  For example, the process of rotating, or writing clean logfiles closes the state log and then re-opens them.  A <emphasis>squid -k reconfigure</emphasis> does the same. </para></section><section><title>log.close()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[STLOGCLOSE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *);]]>
</programlisting><para>The <code>log.close</code> function, of type <emphasis>STLOGCLOSE</emphasis>, is obviously the counterpart to <code>log.open</code>.  It must close the open state-holding log files (if any) for the storage system. </para></section><section><title>log.write()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[STLOGWRITE]]></methodname><![CDATA[(]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *, ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[op]]></methodname><![CDATA[);]]>
</programlisting><para>The <code>log.write</code> function, of type <emphasis>STLOGWRITE</emphasis>, is used to write an entry to the state-holding log file.  The <emphasis>op</emphasis> argument is either <emphasis>SWAP_LOG_ADD</emphasis> or <emphasis>SWAP_LOG_DEL</emphasis>. This feature may not be required by some storage systems and can be implemented as a null-function (no-op). </para></section><section><title>log.clean.start()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[int]]></token>
<methodname><![CDATA[STLOGCLEANSTART]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *);]]>
</programlisting><para>The <code>log.clean.start</code> function, of type <emphasis>STLOGCLEANSTART</emphasis>, is used for the process of writing &quot;clean&quot; state-holding log files.  The clean-writing procedure is initiated by the <emphasis>squid -k rotate</emphasis> command.  This is a special case because we want to optimize the process as much as possible. This might be a no-op for some storage systems that don't have the same logging issues as UFS. </para><para>The <emphasis>log.clean.state</emphasis> pointer may be used to keep state information for the clean-writing process, but should not be accessed by upper layers. </para></section><section><title>log.clean.nextentry()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]>
<methodname><![CDATA[STLOGCLEANNEXTENTRY]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *);]]>
</programlisting><para>Gets the next entry that is a candidate for the clean log. </para><para>Returns NULL when there is no more objects to log </para></section><section><title>log.clean.write()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[STLOGCLEANWRITE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *);]]>
</programlisting><para>The <code>log.clean.write</code> function, of type <emphasis>STLOGCLEANWRITE</emphasis>, writes an entry to the clean log file (if any). </para></section><section><title>log.clean.done()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[void]]></token>
<methodname><![CDATA[STLOGCLEANDONE]]></methodname><![CDATA[(]]><methodname><![CDATA[SwapDir]]></methodname><![CDATA[ *);]]>
</programlisting><para>Indicates the end of the clean-writing process and signals the storage system to close the clean log, and rename or move them to become the official state-holding log ready to be opened. </para></section></section><section><title>Replacement policy implementation</title><para>The replacement policy can be updated during STOBJREAD/STOBJWRITE/STOBJOPEN/ STOBJCLOSE as well as STREFOBJ and STUNREFOBJ. Care should be taken to only modify the relevant replacement policy entries in the StoreEntry. The responsibility of replacement policy maintainence has been moved into each SwapDir so that the storage code can have tight control of the replacement policy. Cyclic filesystems such as COSS require this tight coupling between the storage layer and the replacement policy. </para></section><section><title>Removal policy API</title><para>The removal policy is responsible for determining in which order objects are deleted when Squid needs to reclaim space for new objects. Such a policy is used by a object storage for maintaining the stored objects and determining what to remove to reclaim space for new objects. (together they implements a replacement policy) </para><section><title>API</title><para>It is implemented as a modular API where a storage directory or memory creates a policy of choice for maintaining it's objects, and modules registering to be used by this API. </para><section><title>createRemovalPolicy()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ ]]><methodname><![CDATA[policy]]></methodname><![CDATA[ = ]]><methodname><![CDATA[createRemovalPolicy]]></methodname><![CDATA[(]]><methodname><![CDATA[cons]]></methodname><![CDATA[ ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[type]]></methodname><![CDATA[, ]]><methodname><![CDATA[cons]]></methodname><![CDATA[ ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[args]]></methodname><![CDATA[)]]>
</programlisting><para>Creates a removal policy instance where object priority can be maintained </para><para>The returned RemovalPolicy instance is cbdata registered </para></section><section><title>policy.Free()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[Free]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[)]]>
</programlisting><para>Destroys the policy instance and frees all related memory. </para></section><section><title>policy.Add()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[Add]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *, ]]><methodname><![CDATA[RemovalPolicyNode]]></methodname><![CDATA[ *]]><methodname><![CDATA[node]]></methodname><![CDATA[)]]>
</programlisting><para>Adds a StoreEntry to the policy instance. </para><para>datap is a pointer to where policy specific data can be stored for the store entry, currently the size of one (void *) pointer. </para></section><section><title>policy.Remove()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[Remove]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *, ]]><methodname><![CDATA[RemovalPolicyNode]]></methodname><![CDATA[ *]]><methodname><![CDATA[node]]></methodname><![CDATA[)]]>
</programlisting><para>Removes a StoreEntry from the policy instance out of policy order. For example when an object is replaced by a newer one or is manually purged from the store. </para><para>datap is a pointer to where policy specific data is stored for the store entry, currently the size of one (void *) pointer. </para></section><section><title>policy.Referenced()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[Referenced]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *, ]]><methodname><![CDATA[RemovalPolicyNode]]></methodname><![CDATA[ *]]><methodname><![CDATA[node]]></methodname><![CDATA[)]]>
</programlisting><para>Tells the policy that a StoreEntry is going to be referenced. Called whenever a entry gets locked. </para><para>node is a pointer to where policy specific data is stored for the store entry, currently the size of one (void *) pointer. </para></section><section><title>policy.Dereferenced()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[Dereferenced]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *, ]]><methodname><![CDATA[RemovalPolicyNode]]></methodname><![CDATA[ *]]><methodname><![CDATA[node]]></methodname><![CDATA[)]]>
</programlisting><para>Tells the policy that a StoreEntry has been referenced. Called when an access to the entry has finished. </para><para>node is a pointer to where policy specific data is stored for the store entry, currently the size of one (void *) pointer. </para></section><section><title>policy.WalkInit()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[RemovalPolicyWalker]]></methodname><![CDATA[ ]]><methodname><![CDATA[walker]]></methodname><![CDATA[ = ]]><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[WalkInit]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[)]]>
</programlisting><para>Initiates a walk of all objects in the policy instance. The objects is returned in an order suitable for using as reinsertion order when rebuilding the policy. </para><para>The returned RemovalPolicyWalker instance is cbdata registered </para><para>Note: The walk must be performed as an atomic operation with no other policy actions intervening, or the outcome will be undefined. </para></section><section><title>walker.Next()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[const]]></token><![CDATA[ ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[entry]]></methodname><![CDATA[ = ]]><methodname><![CDATA[walker]]></methodname><![CDATA[->]]><methodname><![CDATA[Next]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicyWalker]]></methodname><![CDATA[ *]]><methodname><![CDATA[walker]]></methodname><![CDATA[)]]>
</programlisting><para>Gets the next object in the walk chain </para><para>Return NULL when there is no further objects </para></section><section><title>walker.Done()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[walker]]></methodname><![CDATA[->]]><methodname><![CDATA[Done]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicyWalker]]></methodname><![CDATA[ *]]><methodname><![CDATA[walker]]></methodname><![CDATA[)]]>
</programlisting><para>Finishes a walk of the maintained objects, destroys walker. </para></section><section><title>policy.PurgeInit()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[RemovalPurgeWalker]]></methodname><![CDATA[ ]]><methodname><![CDATA[purgewalker]]></methodname><![CDATA[ = ]]><methodname><![CDATA[policy]]></methodname><![CDATA[->]]><methodname><![CDATA[PurgeInit]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><token><![CDATA[int]]></token><![CDATA[ ]]><methodname><![CDATA[max_scan]]></methodname><![CDATA[)]]>
</programlisting><para>Initiates a search for removal candidates. Search depth is indicated by max_scan. </para><para>The returned RemovalPurgeWalker instance is cbdata registered </para><para>Note: The walk must be performed as an atomic operation with no other policy actions intervening, or the outcome will be undefined. </para></section><section><title>purgewalker.Next()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[entry]]></methodname><![CDATA[ = ]]><methodname><![CDATA[purgewalker]]></methodname><![CDATA[->]]><methodname><![CDATA[Next]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPurgeWalker]]></methodname><![CDATA[ *]]><methodname><![CDATA[purgewalker]]></methodname><![CDATA[)]]>
</programlisting><para>Gets the next object to purge. The purgewalker will remove each returned object from the policy. </para><para>It is the polices responsibility to verify that the object isn't locked or otherwise prevented from being removed. What this means is that the policy must not return objects where storeEntryLocked() is true. </para><para>Return NULL when there is no further purgeable objects in the policy. </para></section><section><title>purgewalker.Done()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[purgewalker]]></methodname><![CDATA[->]]><methodname><![CDATA[Done]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPurgeWalker]]></methodname><![CDATA[ *]]><methodname><![CDATA[purgewalker]]></methodname><![CDATA[)]]>
</programlisting><para>Finishes a walk of the maintained objects, destroys walker and restores the policy to it's normal state. </para></section><section><title>policy.Stats()</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><methodname><![CDATA[purgewalker]]></methodname><![CDATA[->]]><methodname><![CDATA[Stats]]></methodname><![CDATA[(]]><methodname><![CDATA[RemovalPurgeWalker]]></methodname><![CDATA[ *]]><methodname><![CDATA[purgewalker]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *]]><methodname><![CDATA[entry]]></methodname><![CDATA[)]]>
</programlisting><para>Appends statistics about the policy to the given entry. </para></section></section><section><title>Source layout</title><para>Policy implementations resides in src/repl/&lt;name&gt;/, and a make in such a directory must result in a object archive src/repl/&lt;name&gt;.a containing all the objects implementing the policy. </para></section><section><title>Internal structures</title><section><title>RemovalPolicy</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicy]]></methodname><![CDATA[ ]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[;]]>
<token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicy]]></methodname><![CDATA[ {]]>
<![CDATA[    ]]><token><![CDATA[char]]></token><![CDATA[ *]]><methodname><![CDATA[_type]]></methodname><![CDATA[;]]>
<![CDATA[    ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[_data]]></methodname><![CDATA[;]]>
<![CDATA[    ]]><token><![CDATA[void]]></token><![CDATA[ (*]]><methodname><![CDATA[add]]></methodname><![CDATA[)(]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[policy]]></methodname><![CDATA[, ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *);]]>
<![CDATA[    ... ]]><lineannotation><![CDATA[/* see the API definition above */]]></lineannotation>
<![CDATA[};]]>
</programlisting><para>The _type member is mainly for debugging and diagnostics purposes, and should be a pointer to the name of the policy (same name as used for creation) </para><para>The _data member is for storing policy specific information. </para></section><section><title>RemovalPolicyWalker</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicyWalker]]></methodname><![CDATA[ ]]><methodname><![CDATA[RemovalPolicyWalker]]></methodname><![CDATA[;]]>
<token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicyWalker]]></methodname><![CDATA[ {]]>
<![CDATA[    ]]><methodname><![CDATA[RemovalPolicy]]></methodname><![CDATA[ *]]><methodname><![CDATA[_policy]]></methodname><![CDATA[;]]>
<![CDATA[    ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[_data]]></methodname><![CDATA[;]]>
<![CDATA[    ]]><methodname><![CDATA[StoreEntry]]></methodname><![CDATA[ *(*]]><methodname><![CDATA[next]]></methodname><![CDATA[)(]]><methodname><![CDATA[RemovalPolicyWalker]]></methodname><![CDATA[ *);]]>
<![CDATA[    ... ]]><lineannotation><![CDATA[/* see the API definition above */]]></lineannotation>
<![CDATA[};]]>
</programlisting></section><section><title>RemovalPolicyNode</title><programlisting format="linespecific" language="cpp" linenumbering="numbered" startinglinenumber="1"><token><![CDATA[typedef]]></token><![CDATA[ ]]><token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicyNode]]></methodname><![CDATA[ ]]><methodname><![CDATA[RemovalPolicyNode]]></methodname><![CDATA[;]]>
<token><![CDATA[struct]]></token><![CDATA[ ]]><methodname><![CDATA[_RemovalPolicyNode]]></methodname><![CDATA[ {]]>
<![CDATA[    ]]><token><![CDATA[void]]></token><![CDATA[ *]]><methodname><![CDATA[data]]></methodname><![CDATA[;]]>
<![CDATA[};]]>
</programlisting><para>Stores policy specific information about a entry. Currently there is only space for a single pointer, but plans are to maybe later provide more space here to allow simple policies to store all their data &quot;inline&quot; to preserve some memory. </para></section></section><section><title>Policy registration</title><para>Policies are automatically registered in the Squid binary from the policy selection made by the user building Squid. In the future this might get extended to support loadable modules. All registered policies are available to object stores which wishes to use them. </para></section><section><title>Policy instance creation</title><para>Each policy must implement a &quot;create/new&quot; function  <code>RemovalPolicy * createRemovalPolicy_&lt;name&gt;(char *arguments)</code> This function creates the policy instance and populates it with at least the API methods supported. Currently all API calls are mandatory, but the policy implementation must make sure to NULL fill the structure prior to populating it in order to assure future API compability. </para><para>It should also populate the _data member with a pointer to policy specific data. </para></section><section><title>Walker</title><para>When a walker is created the policy populates it with at least the API methods supported. Currently all API calls are mandatory, but the policy implementation must make sure to NULL fill the structure prior to populating it in order to assure future API compatibility. </para></section><section><title>Design notes/bugs</title><para>The RemovalPolicyNode design is incomplete/insufficient. The intention was to abstract the location of the index pointers from the policy implementation to allow the policy to work on both on-disk and memory caches, but unfortunately the purge method for HEAP based policies needs to update this, and it is also preferable if the purge method in general knows how to clear the information. I think the agreement was that the current design of tightly coupling the two together on one StoreEntry is not the best design possible. </para><para>It is debated if the design in having the policy index control the clean index writes is the correct approach. Perhaps not. Perhaps a more appropriate design is probably to do the store indexing completely outside the policy implementation (i.e. using the hash index), and only ask the policy to dump it's state somehow. </para><para>The Referenced/Dereferenced() calls is today mapped to lock/unlock which is an approximation of when they are intended to be called. However, the real intention is to have Referenced() called whenever an object is referenced, and Dereferenced() only called when the object has actually been used for anything good. </para></section></section></section><section><title>Forwarding Selection</title><para>To be written... </para></section></article>