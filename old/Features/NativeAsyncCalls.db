<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/NativeAsyncCalls</title><revhistory><revision><revnumber>11</revnumber><date>2015-08-31 08:06:50</date><authorinitials>FrancescoChemolli</authorinitials><revremark>fixed links to bugzilla.</revremark></revision><revision><revnumber>10</revnumber><date>2010-10-28 11:45:30</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed for features-listing</revremark></revision><revision><revnumber>9</revnumber><date>2010-10-28 09:15:26</date><authorinitials>FrancescoChemolli</authorinitials></revision><revision><revnumber>8</revnumber><date>2008-05-18 19:39:00</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>7</revnumber><date>2008-04-21 04:18:28</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>6</revnumber><date>2008-02-13 17:17:37</date><authorinitials>AlexRousskov</authorinitials><revremark>Updated status</revremark></revision><revision><revnumber>5</revnumber><date>2007-12-20 15:35:19</date><authorinitials>AlexRousskov</authorinitials><revremark>Updated ETA</revremark></revision></revhistory></articleinfo><section><title>Feature: Native support for asynchronous calls</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>: Simplify code, improve debugging, improve ICAP performance, and prevent crashes from single transaction errors. </para></listitem><listitem><para><emphasis role="strong">Version</emphasis>: 3.1 </para></listitem><listitem><para><emphasis role="strong">Status</emphasis>: complete </para></listitem><listitem><para><emphasis role="strong">Developer</emphasis>: <ulink url="https://wiki.squid-cache.org/Features/NativeAsyncCalls/AlexRousskov#">AlexRousskov</ulink> </para></listitem><listitem><para><emphasis role="strong">More</emphasis>: <ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=1912#">bug1912</ulink>, <ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=2093#">bug2093</ulink>, and item 1 in <ulink url="http://www.squid-cache.org/mail-archive/squid-dev/200707/0109.html">email109</ulink> </para></listitem></itemizedlist><section><title>Design sketch</title><para>This section summarizes design ideas for the asynchronous call interface. Only a small fraction of what is discussed here has been implemented so many changes are expected. </para><section><title>The main loop</title><para><emphasis role="strong">High-level</emphasis>: The main loop will continuously fire all asynchronous calls until there are no calls left. Then, it will get the maximum wait time from the time-based event queue and let &quot;select&quot; probe file descriptors. The code sketch below outlines a single Main Loop iteration: </para><screen><![CDATA[timeout = TheEvents.checkpoint();
TheCalls.fireAllCalls();
TheSelect.scan(timeout);]]></screen><para><emphasis role="strong">More realistic:</emphasis> In addition to the above, the event queue must be re-checked if async calls were fired because the call(s) may take long enough for a new event to become ready. Again, the code fragment below is a single Main Loop iteration. </para><screen><![CDATA[do {
    timeout = TheEvents.checkpoint();
    something_has_changed = not TheCalls.empty();
    TheCalls.fire();
} while (something_has_changed);
]]><![CDATA[
TheSelect.scan(timeout);]]></screen></section><section><title>Firing a single call</title><para>Before firing an async call, Squid prepares to catch call exceptions. If the call itself fails to fire (e.g., an event callback data became invalid), Squid stops working with the call. If an exception is caught, the call exception handler is called: </para><screen><![CDATA[    try {
        if (!call->fire())
            return;
    }
    catch (const exception &e) {
        call->handleException(e);
    }
    call->end();]]></screen><para>All async calls are fired in the same way. Individual call types provide call-specific debugging information (in a similar format), call the required code with stored parameters, and customize exception handling. </para><para>The actual code may also catch other exceptions with a <emphasis>catch(...)</emphasis> clause. </para></section><section><title>Callbacks</title><para>A Callback is information necessary to make a future call. Callbacks are often used in Squid to register with a job or module to receive future updates or other asynchronous notifications about important events. </para><para>It can be viewed as a half-baked Call: The call destination address and possibly some parameters are known but the time of the call and possibly some other parameters are not known and must be determined by the caller. </para><para>The initial implementation will not optimize Callback representation and just use Calls (with some parameters left unset) for Callbacks. </para></section><section><title>Types of calls</title><para>Call destination kind determines call type. Supported destinations include: an AsyncJob object method, other object method, and a global static function. </para><para>Here is how AsyncJob call might implement its public methods: </para><screen><![CDATA[bool JobCall::fire() {
    AsyncJob *job = dynamic_cast<AsyncJob*>(theObject);
    if (job pointer is not valid) {
        debugs(section, level, "NOT Calling " << className << "::"
            << methodName << " method ...");
        return false;
    }
]]><![CDATA[
    debugs(section, level, "Entering " << className << "::" <<
        methodName << " method [" >> job->status () >> "]");
    (job->*)(theMethod)(...)
    return true;
]]><![CDATA[
}
]]><![CDATA[
void JobCall::end()
{
]]><![CDATA[
    if (job->done()) {
        debug("Ending job [" >> job->status () >> "]");
        job->swanSing();
        delete job;
        debug("The " << className << "::" << methodName
            << " method  ended the job [" >> (void*)job >> "]");
        return;
    }
    debug("Exited " << className << "::" << methodName <<
        " method [" >> job->status () >> "]");
}]]></screen><para>The actual JobCall code will use more debugging and probably use more ObjectCall (i.e., its parent) facilities): </para><para>Comm module will probably provide its own convenience classes to handle &quot;note your file descriptor is ready&quot; type of calls. </para></section></section><section><title>What creates asynchronous calls?</title><para>Any code can queue an asynchronous call at any time after TheCalls queue is initialized. For example, any of the following calls may result in new async call creations: </para><screen><![CDATA[TheEvents.checkpoint();  // when the event(s) time has come
TheCalls.fireAll();      // when a call handler needs to call
TheSelect.scan(timeout); // when descriptors are ready]]></screen></section><section><title>Challenges</title><para>There will be templates, macros, and/or code-generated classes that handle arbitrary call destination addresses and calls with one, two, or three parameters (at least). Designing a simple and efficient set of wrappers without using a template-based library like <ulink url="http://www.boost.org/">Boost</ulink> will be tricky. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/NativeAsyncCalls/CategoryFeature#">CategoryFeature</ulink> </para></section></section></article>