<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/BetterStringBuffer</title><revhistory><revision><revnumber>21</revnumber><date>2015-09-21 04:37:29</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>20</revnumber><date>2015-01-17 17:47:53</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>19</revnumber><date>2010-09-03 21:23:39</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Retargeted.</revremark></revision><revision><revnumber>18</revnumber><date>2010-02-22 12:18:45</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed dangling wiki-links</revremark></revision><revision><revnumber>17</revnumber><date>2010-02-22 12:17:51</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed dangling wiki-links</revremark></revision><revision><revnumber>16</revnumber><date>2010-02-19 13:21:53</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed dangling wiki-links</revremark></revision><revision><revnumber>15</revnumber><date>2010-02-19 10:45:40</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed dangling wiki-links</revremark></revision><revision><revnumber>14</revnumber><date>2008-09-18 12:01:10</date><authorinitials>FrancescoChemolli</authorinitials></revision><revision><revnumber>13</revnumber><date>2008-09-18 11:38:12</date><authorinitials>AmosJeffries</authorinitials><revremark>Kinkie has started coding.</revremark></revision><revision><revnumber>12</revnumber><date>2008-08-26 12:44:11</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Added info on StringNg effort</revremark></revision><revision><revnumber>11</revnumber><date>2008-07-12 11:48:04</date><authorinitials>AmosJeffries</authorinitials><revremark>comment replies and clarifications.</revremark></revision><revision><revnumber>10</revnumber><date>2008-05-18 19:38:58</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>9</revnumber><date>2008-04-21 04:35:51</date><authorinitials>AmosJeffries</authorinitials><revremark>bump to later versions</revremark></revision><revision><revnumber>8</revnumber><date>2008-03-24 21:27:25</date><authorinitials>AlexRousskov</authorinitials><revremark>typo</revremark></revision><revision><revnumber>7</revnumber><date>2008-03-19 15:04:05</date><authorinitials>AlexRousskov</authorinitials><revremark>added comments/questions; it would be nice to have dedicated markup for comments. Spell checked</revremark></revision><revision><revnumber>6</revnumber><date>2008-03-18 22:08:36</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>5</revnumber><date>2008-03-18 21:59:26</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>4</revnumber><date>2008-02-19 00:04:07</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>3</revnumber><date>2008-02-04 06:02:01</date><authorinitials>AmosJeffries</authorinitials></revision></revhistory></articleinfo><section><title>Feature: Better String memory usage</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>:  Improve the usage of short strings to use best-practice, efficient, pointer-safe APIs. </para></listitem><listitem><para><emphasis role="strong">Status</emphasis>: general code conversion underway </para></listitem><listitem><para><emphasis role="strong">ETA</emphasis>: unknown </para></listitem><listitem><para><emphasis role="strong">Developer</emphasis>: <ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/AmosJeffries#">AmosJeffries</ulink>, <ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/FrancescoChemolli#">FrancescoChemolli</ulink> </para></listitem><listitem><para><emphasis role="strong">More</emphasis>: <ulink url="https://code.launchpad.net/~kinkie/squid/stringng"/> </para></listitem></itemizedlist><section><title>Details</title><para>Improve the usage of memory-pooled strings and the string API. The code is presently not using best-practice or pointer-safety with regards to short strings. Nor is it using them widely in place of un-pooled character arrays where it could provide greater memory management easily. </para><para>Plans for the string API are intended to allow improved access at all current usage of strings (ESI, ICAP, others?) and allow for improved and safer access to larger buffers (HTTP parser, URI Parser, etc). </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> Please clarify your goal. What &quot;usage&quot; aspects are you trying to improve? APIs are rarely the goal, they are usually the means to achieve some goal(s). It is not clear what &quot;improved access&quot; means. </para></listitem></itemizedlist><para><emphasis role="strong">Goal</emphasis>: To implement a zero-copy data pathway from network/disk read to network/disk write within Squid. </para><para>Safer access, means with a coded non-char* access to raw data buffers which we can store in state objects and be sure the pointers are not going to die underneath the callee code. The present !SquidString/String implementation is limited by: </para><itemizedlist><listitem><para>max-size of 65536 bytes. This was made evident by earlier attempts at using it universally for char* replacement. </para></listitem><listitem><para>direct access to a self-controlled char* buffer. No existing ability for non-local buffer sharing. </para></listitem><listitem><para>existing usage within squid strictly assuming the above two limits are always true. </para></listitem></itemizedlist><para><ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/FrancescoChemolli#">FrancescoChemolli</ulink> has started a sample implementation, drawing from many concepts in this page and <ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/AdrianChadd#">AdrianChadd</ulink>'s implementation in branch s27_adri. General concepts and discussion in <ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/Features/BetterStringBuffer/StringNg#">/StringNg</ulink>, will be merged here once better sketched. </para></section><section><title>Plan</title><para>Implementing a single semi-generic referenced-String class that acts as both a parent-buffer and a child-string (see below) simultaneously is easy enough. Once created we can slowly migrate usage of it around Squid. If done carefully with a char* and SquidString  in/out conversion we can insert them seamlessly at any point in the code with no loss of performance, but an overall gain in places where two can reference each other. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> Can you rewrite the above as a sequence of specific steps? This is a big and important project that will affect other code. Let's try to be clear about the steps. This will also help you describe the current status later. </para></listitem></itemizedlist><para>Steps: </para><itemizedlist><listitem><para>discuss the design below until its clear what the best implementation is for Squid. </para><itemizedlist><listitem override="none"><para>JIT, RefCount, const String, others? </para></listitem></itemizedlist></listitem><listitem><para>Create a class to implement it. </para></listitem><listitem><para>Insert the class at request read handler and incrementally push down the request pathway </para></listitem><listitem><para>Insert the class at reply read handler and incrementally push down the network reply pathway </para></listitem><listitem><para>Insert the class at store read handler(s) and incrementally push down the cache-reply pathway </para></listitem><listitem><para>Look for any places still using xstrdup() or equivalent from these string objects, and incrementally push down those secondary pathways as well. </para></listitem></itemizedlist><para>The steps have started. Progress so far is: </para><itemizedlist><listitem><para>Adrian has implemented this in his own way for Squid-2 with non-copying strings. </para></listitem><listitem><para>We are stuck on step 1 for Squid-3. </para></listitem></itemizedlist><para>It's the same methodology I used for the v6 makeover. Once we have passed step-1, it should take 6-10 months to completion. </para></section><section><title>Design sketch</title><section><title>I/O Buffers</title><para>The faster string counters revolve around Just-In-Time duplication of strings out of buffers. Such that strings which never actually need duplication are not allocated memory or perform any copying. </para><para>The first steps of that is to make the low-level data buffers capable of communicating with the strings that are using them. </para><para>Buffers need to have a list of child strings added with register/deregister, and Destructor-cascade operations. The register/deregister kicked-off by the child strings when their JIT is triggered. Destructor cascade is kicked-off by the buffer when it needs to de-allocate and all remaining child strings must duplicate their data or loose it. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> The above design will work, but there are alternatives. Can you compare the above with a simpler design where the buffer is locked by stings using it, but does not point back to them; if a string needs to be modified and the buffer has more than one lock, the buffer (or its affected portion) is copied for that string use, without any affect on other strings. </para></listitem></itemizedlist><para>The alternative I believe you refer to is RefCounted children instead of JIT duplication. That was one of the initial models I looked at. It would be much simpler and easier to use. The problem pointed out by Adrian who has taken the JIT model into Squid-2 was that there are too many places in Squid which assume the data it receives is going to exist 'forever'. </para><para>Choosing the RefCounted option would trade keeping the buffer memory in use as long as even one byte of its content is ref-locked. The JIT method trades that memory consumption + O(1) refcount, against linked-list (fast unordered O(4) ) inserts at the parent buffer. Making the child/parent buffers/strings one object type the implementation for either can be coded and tested for speed + benefits in squid and the best kept. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> Please also address the overheads of content insertion or explicitly say that we are not going to address that at this stage: The above design optimizes parsing, but does not help much with the opposite process of content assembly (e.g., building an HTTP header). Should this project also allow for efficient, copy-free content assembly? One way to support that is to support buffers that consist of multiple independently-allocated areas. </para></listitem></itemizedlist><para>JIT model overheads of content insertion is a fall-back in worst-case to the current squid behavior of duplicating each string/buffer. Best-case is complete zero-copy. This is what I mean by no loss of performance. My current understanding of both clones between server-side and client-side is that they presently duplicate the same data several times in-transit to and from each data pathway. </para><para>This model is hoping primarily to address the request/reply parsing and also in-transit delays of copying HTTP-header portions. The data-object portions are not expected to improve much with this. Only ESI or other object-parsing may be peripherally affected. </para><para>NP: a generically-written buffer may be a string itself referencing another larger buffer elsewhere. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> This needs clarification. Please define the primary roles of the buffer and string classes. For example, the string is responsible for maintaining information about an area of a buffer (buffer, offset, size) and read/write locks, while the buffer is responsible for everything else (memory management, duplication, insertion, search, comparison, etc.). This high-level role separation should probably be discussed before the class-specific sections. </para></listitem></itemizedlist><para>The sub-note is about; that there may in fact be no need for two such classes. The memory-manager may be completely capable of handling allocations, leaving 'parent' and 'child' layers of the model a single class type capable of referring to other objects of its own type. This still needs investigation of the different use and behavior of the current MemBuf, char*, and SquidString. </para></section><section><title>JIT Strings</title><para>The string itself should hold an offset and reference to its parent-buffer in addition to the character-pointer into the parent buffer if parent is present, or to its own duplicated buffer if necessary. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> I do not think you need &quot;parent buffers&quot; and &quot;own buffers&quot;. One kind of buffer should suffice. The &quot;own buffer&quot; is just a buffer that is currently used by one string. That can change whenever the string or its portion is duplicated by the user code. </para></listitem></itemizedlist><para>Indeed, that is the intent. I use 'parent' and 'own' to differentiate the case where these objects are referring to a seperate object 'parent' (shared buffer by offset+lock on the external object) or has master-control over a buffer (responsibiity for: allocate, de-allocate, notify-cascade initiate on changes) </para><para>They should be read-only by default, with write-operations requiring a buffer-duplication to accommodate the new content without altering the parent buffer underneath other sibling-strings. </para><para>An alteration feedback mechanism needs to be added to prevent a string buffer being altered when it has child-strings itself. To prevent unnecessary duplication. </para><para><emphasis role="strong">NP:</emphasis> Concatenations are a special case here with no duplicate need IFF the string has its own already-duplicated buffer large enough to hold the extra. </para></section><section><title>String-Users</title><para>All code that uses these strings MUST NOT reference the raw-data buffer for access or manipulation. Offset-based API needs to be provided for all actions instead. </para><para><emphasis role="strong">NP:</emphasis> I/O is the one exception to this, where output may be done from the current string buffer.  </para><para>Preferably IO is done through the highest-level of construct tracking the child-strings and thus being buffer-agnostic and most importantly length agnostic. It is up to the high-level object whether it outputs the original input buffer or the (possibly altered) child strings individually re-formatted. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> Perhaps I am missing something, but I think it is OK to pass constant string content pointers to external code (I/O, system libraries, etc.) as long as the string is guaranteed to remain intact until the end of the call. Passing non-constant pointers requires write-locking, but is also OK under the same conditions. This will help with migrating from current code to the new API and allows for greater code reuse. </para></listitem></itemizedlist><para>Constants yes. char* buffer pointers no. The essence of this is that the new string objects are not nul-terminated. Child object has only an offset and length into the raw buffer somewhere else which it supplies via a [] operator or a lookup itself to de-reference the char*. Many of the current users depend on null-termination of char* for stdlib string functions, will die horribly if they attempt to random-access a non-terminated buffer. </para></section><section><title>Remaining Problems</title><para>The case remains that a buffer may be partially-parsed into three parts (or more, but 3 is the simplest case). It maintains it's head pointer, and by referencing the child it may locate the child start offset. This allows output of the A-part. The child itself can perform output of the B-part, changed or not. BUT, if the B-part child has changed we no longer have the start-offset information for the C-part of the string. This will have to be maintained cleanly somewhere. </para><para>There are two options for handling this: </para><itemizedlist><listitem><para>A small Dead-String class type to map these dead-spaces in the buffer. Which the parent creates when a child-string de-references itself indicating alteration as the reason (other reasons may be child-destruct). </para></listitem><listitem><para>We ensure parsers are run over the full buffer they need to, user keep reference to the C-parts IFF they need to and ignore this, considering all unreferenced areas of the parent buffer as unparsed/garbage. All IO at that point MUST be performed from the top-down to encompass these 'deletions'. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> It sounds like your buffer consists of parts here. If that is the case, the above design needs to reflect that. At least, it was not clear to me that you are proposing support for multi-part buffers as opposed to a single buffer, with multiple strings pointing to buffer areas. That is why I asked above whether you are going to optimize content generation as well. </para></listitem></itemizedlist></listitem></itemizedlist><para>I'm indeed not proposing multi-part buffers. At least not in the design on this page above. Reference to parts is only to logical sections of a sequential raw buffer if partially parsed. I'm leaning towards ignoring this and assuming the user takes care of any bits. That is more in line with the parsing basis of this and general parser behavior. </para><para>This is an attempt to take a real N-kilobyte stream of data into one buffer and handle the fact that dozens of small sections of its raw ascii are used around Squid. Without duplicating it, we end up with functions receiving an triplet object of {buf,offset,length}. Or in the case of pre-parsed headers, a tree of these objects with for example, the ones which point to hop-by-hop headers missing. Then we need to reconstruct them into the socket write stream directly (think; non-copy from network read to network/disk write). </para><para>Though true, the output generation optimization does need more thought. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/BetterStringBuffer/CategoryFeature#">CategoryFeature</ulink> </para></section></section></section></article>