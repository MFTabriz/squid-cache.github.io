<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/HotConf</title><revhistory><revision><revnumber>6</revnumber><date>2015-09-21 05:36:10</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>5</revnumber><date>2013-06-11 06:26:16</date><authorinitials>AmosJeffries</authorinitials><revremark>update bug wikilinks and removes some resolved in other features.</revremark></revision><revision><revnumber>4</revnumber><date>2009-04-09 17:46:50</date><authorinitials>AlexRousskov</authorinitials><revremark>Quoted discussion as otherwise very few will know about it</revremark></revision><revision><revnumber>3</revnumber><date>2009-04-09 03:01:28</date><authorinitials>AmosJeffries</authorinitials><revremark>reference bugs related to, part of, or requiring this cleanup feature</revremark></revision><revision><revnumber>2</revnumber><date>2009-04-09 02:12:56</date><authorinitials>AmosJeffries</authorinitials><revremark>link to related features</revremark></revision><revision><revnumber>1</revnumber><date>2009-04-09 02:06:44</date><authorinitials>AmosJeffries</authorinitials><revremark>brain dump on the config process</revremark></revision></revhistory></articleinfo><section><title>Feature: Hot Configuration</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>: To remove the many issues squid currently displays due to reconfigure via a full component shutdown/restart cycle. </para></listitem><listitem><para><emphasis role="strong">Status</emphasis>: underway; </para></listitem><listitem><para><emphasis role="strong">ETA</emphasis>: unknown </para></listitem><listitem><para><emphasis role="strong">Version</emphasis>:  </para></listitem><listitem><para><emphasis role="strong">Developer</emphasis>: <ulink url="https://wiki.squid-cache.org/Features/HotConf/AmosJeffries#">AmosJeffries</ulink> </para></listitem></itemizedlist></section><section><title>Details</title><para>Squid currently performs reconfigure by way of a simulated shutdown, re-loading the config files, and restarting. </para><para>This causes many issues which are visible: </para><itemizedlist><listitem><para>ports fully closed for a duration </para></listitem><listitem><para>memory leaks for SSL contexts, and other in-use objects </para></listitem><listitem><para>loss of information on in-transit requests </para></listitem><listitem><para>INVALID URL errors when protocol info disappears. </para></listitem><listitem><para>request denials when ACLs being checked disappear. </para></listitem></itemizedlist><para>Related Bug reports: </para><itemizedlist><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=219#">219</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=513#">513</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=537#">537</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=1545#">1545</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=1946#">1946</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=2110#">2110</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=2460#">2460</ulink> </para></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=2570#">2570</ulink> </para><itemizedlist><listitem override="none"><para>A workaround is in use for memory-only caches, but this keeps resurfacing. Lately rock type dirs with SMP diskers is causing it again. </para></listitem><listitem override="none"><para>We need to obsolete <ulink url="http://www.squid-cache.org/Doc/config/wccp2_rebuild_wait#">wccp2_rebuild_wait</ulink>. </para></listitem></itemizedlist></listitem><listitem><para><ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=2626#">2626</ulink> </para></listitem></itemizedlist><section><title>State up to Squid-3.1</title><para>The plan begun during early 3.0 cycle was to re-work the existing squid.conf parser to pass the syntax parsing into each component which had better knowledge of the requirements. </para><para>The above plan halted for currently unknown reasons and was left incomplete. It appears to split the parsing down a bit too deeply into components for easy understanding. It also leads to code duplication as minor parsing functions (undocumented!) are missed by followup developers and re-implemented at the per-component level. This is not a good state and needs to be simplified in the redesign. </para><para>The old Squid-2 parser has a much clearer design, but suffers major issues with component inter-dependencies. So needs to be split at least partway down the track of the 3.0 design. </para><para>Also, neither of the current config parser designs can completely resolve the set of issues so a new design is needed to replace both. Integrating the simple option handling of the Squid-2 parser and the per-component split of the initial Squid-3 parser. </para></section><section><title>New Design for Squid-3.1+</title><para>The current work begun already in Squid-3.1 and building in with <ulink url="https://wiki.squid-cache.org/Features/HotConf/Features/SourceLayout#">Features/SourceLayout</ulink> takes the Squid-3.0 parser idea of modular component config (each sub-library has its own XX::Config object which holds only that components configuration settings. </para><para>But also leaves the legacy parser per-type parsing function. Which causes two layers to emerge: </para><itemizedlist><listitem><para>the underlayer of legacy parser which handles file actions </para></listitem><listitem><para>the component layer of squid.conf option handlers </para></listitem></itemizedlist><para>these are linked together at present by defining the legacy parser handlers interface as wrapper functions/macro to the XX::Config object methods. </para><para>The plan is to build on that modular design and create two master objects: </para><section><title>A XX::Config template or parent object</title><para>This object to provide virtual functions that register a handler for each squid.conf option the component can parse (both current, deprecated, and obsolete options). </para><para>The option handlers: </para><itemizedlist><listitem><para>parse the squid.conf line for that option </para></listitem><listitem><para>produce clear and understandable error messages when a line is bad </para></listitem><listitem><para>produce clear warnings when an option is being deprecated </para></listitem><listitem><para>provide for migrating obsolete squid.conf options, a built-in <ulink url="https://wiki.squid-cache.org/Features/HotConf/Features/ConfigUpdater#">Features/ConfigUpdater</ulink> </para></listitem></itemizedlist><para>It also must provide an API for the startup, shutdown, reload, and reconfigure processes. The reconfigure is in need of the most work. </para><para>As I see it the important part of reconfigure, is that a pre-reconfigure and post-reconfigure call is made to each component so it can perform any actions needed to prepare itself for parsing. And to cleanup/restart if needed after parsing. </para><para>Major components may need to process their parsing results into a shadow config during the reconfigure and perform a hot-swap that allows existing requests to continue with the old config details and new ones to use the updated config. </para><para>Some objects will need to be made ref-counted to prevent disappearance when an updated config is hot-swapped into place: </para><itemizedlist><listitem><para>http_port definitions </para></listitem><listitem><para>SSL context settings </para></listitem><listitem><para>ACL lists </para></listitem><listitem><para>helper settings </para></listitem><listitem><para>auth settings </para></listitem><listitem><para>delay pools </para></listitem><listitem><para>store settings </para></listitem><listitem><para>(any others known please add) </para></listitem></itemizedlist><para>The config object for each component needs to have a component enable/disable flag or setting. This will allow run-time enabling and disabling of components and additionally allow the shutdown/restart logics to be improved and extended with async paths. </para></section><section><title>A registry-style parser / component manager</title><para>A manager object to receive handler registrations and process the low-level file reads needed to process squid.conf. </para><para>May also control the core startup/shutdown/restart/reconfigure/reload actions currently done at global level by main.cc </para></section></section><section><title>Results</title><para>When this is completed; </para><itemizedlist><listitem><para>Components can be created semi-autonomously and 'dropped in' to the code base. </para></listitem><listitem><para>Each will manage its own set of squid.conf lines. </para></listitem><listitem><para>The startup procedure will take less than a second </para></listitem><listitem><para>reload will be a zero-downtime event </para></listitem><listitem><para>restart will be a zero-downtime event </para></listitem><listitem><para>shutdown will be a fast event </para></listitem><listitem><para>components such as auth and helpers will be reconfigurable </para></listitem></itemizedlist></section><section><title>Discussion</title><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> To answer, use the &quot;Discussion&quot; link in the main menu </para><para>See <ulink url="https://wiki.squid-cache.org/Features/HotConf/Features/HotConf#">Discussed Page</ulink> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C1"/> Thank you for setting up this page, Amos. Lots of good thoughts here. </para><para>One conceptual change I would recommend is to separate parsing from configuration. If you look through your notes, a lot of them have to do with how things are parsed and who is parsing them. This may be important, but is not (should not be) related to hot reconfiguration. </para><para>We need a set of dumb configuration-holding objects created by parsers. Those objects should have nothing to do with the runtime state of Squid. During reconfiguration, the newly created configuration objects are fed to their modules. The modules decide how to handle the reconfiguration, but they should not deal with parsing problems while making that decision. They should operate on and with configuration objects. </para><para>In pseudo C++, and simplifying a bit: </para><screen><![CDATA[// lifecycle
void Module::init();
void Module::configure(const Module::Config &cfg);
void Module::reconfigure(const Module::Config &newCfg);
void Module::shutdown();
]]><![CDATA[
// parsing; probably static to avoid module creation  
Module::Config *Module::Parse(const SquidDotConfTokenizer &text);]]></screen><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-09 05:11:39' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> Good point, I can see the switchover case would need that separation of data vs handlers. However I dislike the need to pass config objects to them. manager will be the one doing the calls and we don't want the manager to handle individual Config objects, only the current state of processing and the current squid.conf line string. </para><para>NP: I envision startup to be just a special case of reconfigure. where defaults are built into the ::Config constructors and used for first X seconds until local config  </para><para>My model is one where the object with API methods is either inherited or templated from a master/shared object which provides the basic tokenizing methods. Similar to Robs earlier attempt at a parser, but without the call nesting going outside the currently parsing object. (yes, I must make exception for ACL list already since they are tacked on the end of many things, but after much browsing of the config I see no others) </para><para>The parser is tightly wound with hot-conf since hot-conf is a desirable and planned effect of the parsing design. Not the other way around. This is needed to RefCount the objects shared between old conf and new conf. Parser controls and uses both current and future dumb::Config to determine what goes into future (a RefCounted clone of the current or a new allocation). Indeed Parser controls whether there is a future object or if its editing current on the spot (think err directory locations, size limits, and other state-agnostic settings). </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AmosJeffries#">AmosJeffries</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-10 13:58:00' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C3"/> I am worried about several ideas expressed here but I may be just misinterpreting what you are saying. I will provide specific sketches in hope to make this discussion less vague and more structured. </para><para>I disagree that it is a good idea to keep parser tightly coupled with configuration. There is certainly a way around it (see my sketch). We would be significantly increasing the complexity of the overall design if modules keep parsing and configuring at the same time. Also, if you want to write module-specific test cases, the ability to create and [re]configure a module without parsing is very valuable.  </para><para>Refcounting has nothing to do with this issue, IMO. Refcounting is just a low-level memory-saving mechanism, and we are discussing a high-level API (which should work with or without refcounting). </para><para>The Parser should _not_ be editing &quot;on the spot&quot;. It should always create and fill brand new dumb configuration objects. It will spend a little bit more memory compared to the current &quot;stuff everything into one global&quot; design, but the spending is relatively small, temporary, and results in several significant advantages, including the ability to write clear reconfiguration code that can compare old and new configuration objects, identify the differences, and decide whether hot reconfiguration is possible.   </para><para>I do not think it is a good idea to start running with defaults and then reconfigure to the actual configuration values. It buys you nothing but complexity because you still have to write initial configuration code (the one that applies the defaults) and then perform possibly complex reconfiguration.  </para><para>Having initial configuration code also allows you to avoid implementing true hot reconfiguration when necessary: </para><screen><![CDATA[// a sketch of a possible default implementation for modules
void Module::reconfigure(const Config &newCfg) {
    shutdown();
    init();
    configure(newCfg);
}]]></screen><para>This approach allows for steady migration from the code that does not support hot reconfiguration to the code that does. The minimum requirement is to implement init/shutdown/configure, which is something we need anyway. </para><para>Finally, I am not sure how the top-level [re]configuration manager should look like, but I do not understand the problem of &quot;handling individual module configs&quot; that your are referring to. Something like this sketch might work: </para><screen><![CDATA[int main() {
    addModule(new Module1); // calls init() and registers
    addModule(new Module2); // calls init() and registers
    addModule(new Module3); // calls init() and registers
    addModule(new Module4); // calls init() and registers
    ...
]]><![CDATA[
    SquidConfig *cfg = parse();
    configure(*cfg);
]]><![CDATA[
    mainLoop();
]]><![CDATA[
    while (registered module container is not empty) {
        delete popModule(); // calls shutdown() and deregisters popped m
    }
}
]]><![CDATA[
// note how parsing is unaware of individual module and configuration
// types
SquidConfig *parse() {
    // I do not like the Tokenizer name here; the class does more than
    // just tokenizing because it allows to search for relevant lines
    SquidDotConfTokenizer tokenizer(...);
]]><![CDATA[
    SquidConfig *cfg = new SquidConfig; // collection of Module cfgs
    for each registered module m {
        // the module will find lines that belong to it by searching
        // for module-specific option names
        Config *moduleCfg = m->parse(tokenizer);
        cfg->add(moduleCfg);
    }
]]><![CDATA[
    if (tokenizer.unusedLines())
        throw "unclaimed config options";
]]><![CDATA[
    return cfg;
}
]]><![CDATA[
void configure(const SquidConfig &cfg) {
    for each registered module m {
        // find module configuration; hide this inside m->configure()?
        Config *mcfg = cfg.find(m);
]]><![CDATA[
        // configure the module
        m->configure(*mcfg);
    }
}
]]><![CDATA[
void reconfigure() {
    SquidConfig *newCfg = parse(...);
]]><![CDATA[
    for each registered module m {
        // find module configuration; hide this inside m->reconfigure()?
        Config *mcfg = newCfg->find(m);
]]><![CDATA[
        // reconfigure the module
        m->reconfigure(*mcfg);
    }
]]><![CDATA[
    delete newCfg; // or replace the old global refcounted pointer
}]]></screen><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-09 15:00:45' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para>Aw, heck no. That leaves the configure startup/shutdown process outside the main loop and inaccessible to async operations. </para><para>Have adjusted your example to be more what I mean: </para><screen><![CDATA[int main() {
    addModule(new Module1);
        // calls init() and registers "no_cache" as Store::??::parse_cache_acl(...) etc.
    addModule(new Module2);
        // calls init() and registers "adaptation_enable" as Adaptation::??::parse_enable(...) etc.
    ...
]]><![CDATA[
    SquidConfig::startConfigure();
    scheduleAsync(..., SquidConfig::parse(), ...); // as next job with zero time delay
    scheduleAsync(..., SquidConfig::doneConfigure(), ...); // as next job with zero time delay after parse...
]]><![CDATA[
    mainLoop();
]]><![CDATA[
// I like this loop, however for code simplicity I think it should be its own async event 'shutdown'
    while (registered module container is not empty) {
        delete popModule(); // calls shutdown() and deregisters popped m
    }
}
]]><![CDATA[
// note how parsing is unaware of individual module and configuration
// types AND even of individual line content tokens!!
void parse() {
    SquidDotConfTokenizer tokenizer(...);
]]><![CDATA[
    for each tag = SquidDotConfTokenizer.nextLine() {
       // find handler for that named config option...
       if ( opt = find(tag)) 
           opt->parseHandler(tokenizer);
       else
           handleUnclaimedLine(tag, tokenizer)
    }
]]><![CDATA[
    if (tokenizer.unusedLines())
        throw "unclaimed config options";
}
]]><![CDATA[
// only used to prep-state during a true reconfigure
void startConfigure() {
    for each registered module m {
        // find module configuration; maybe even hide this inside parse()
        cfg.startingConfigure();
    }
}
]]><![CDATA[
// used after any config changes from any source...
void doneConfigure() {
    for each registered module m {
        // find module configuration; maybe even hide this inside parse()
        cfg.reconfigureCompleted();
    }
}]]></screen><screen><![CDATA[using namespace Module; // ...
]]><![CDATA[
Module::Config *current;
Module::Config *future;
]]><![CDATA[
// NP: legacy code here might call its own shutdown() instead of the hot-conf clone().
startConfigure()
{
   future = current->clone();
    // maybe followup with any removals needed to reset the future config to 'unused state'
}
]]><![CDATA[
parse(tokeniser)
{
    // parse tokeniser line into *future ...
}
]]><![CDATA[
// NP: _this_ is the entirety of hot-swap.
// legacy code which did shutdown earlier will be doing its own restart() stuff here instead of hot-swap.
reconfigureComplete()
{
   if (!changed) {
      delete future;
      return;
   }
]]><![CDATA[
   // anything else needed to finish up with ...
   Module::Config *tmp = current;
   current = future;
   delete tmp;
}]]></screen><para>both layers are essentially the same in call meaning Squid::startConfigure calls Module::startConfigure etc. BUT the difference is that the scope of each method reduces from file to line and increases in the amount of tokenizer interaction between these layers. </para><para>The parsing tokenizer needs to be looked at separately as you pointed out. But that is not relevant to the reconfigure scope of this feature. </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AmosJeffries#">AmosJeffries</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-10 02:03:02' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C5"/> </para><para>Making configuration asynchronous is worth trying. </para><para>You have added &quot;AND even of individual line content tokens&quot; comment. That was true in my sketch as well. </para><para>I do not think it is a good idea to limit module configuration API to &quot;one option at a time&quot; and add an &quot;module option registration&quot; interface.  In my sketch the module knows its options and handles them however it wants. There may be a common/shared code that a module can reuse to handle one option at a time, of course, but I would not expose that detail to the upper layer or force it on lower layers.  </para><para>It is possible that two modules will need access to the same option, for example. We also do not know the order in which the options should be handled by the module (and that order can be dynamic so always using the registration order is not good enough). Overall, it just adds complexity and makes the interface more rigid than necessary. </para><para>The last bit in your sketch is about a possible way to implement reconfiguration, I think. Again, I would not force that way on all modules. I would just give them the new or &quot;future&quot; Module::Config object and let them figure out how to handle the transition. The arguments are very similar to the &quot;one registered line at a time only&quot; objections above. </para><para>I feel it is critical to separate parsing from [re]configuration. We should not even attempt to [re]configure Squid if parsing fails. Parsing produces Module::Config objects, that have no effect other than memory use. Most common errors are detected at this stage. If everything is OK, all modules are asked to [re]configure themselves using these Config objects. We can even go further and have three reconfiguration steps: </para><orderedlist numeration="arabic"><listitem><para><emphasis role="strong">Parsing</emphasis> --  Module::parse(tokenizer) is called for all modules, producing Module::Config objects. Abort reconfiguration on errors. No changes to the current config. </para></listitem><listitem><para><emphasis role="strong">Validation</emphasis> -- Module::canReconfigure(cfg) is called for all modules, producing success/errors. Abort reconfiguration on errors. No changes to the current config. </para></listitem><listitem><para><emphasis role="strong">Application</emphasis> -- Module::reconfigure(cfg) is called for all modules. Should not fail. Changes current config. </para></listitem></orderedlist><para>One of the biggest challenges here is handling dependencies between modules, but having Module::Config objects free of side-effects will help with that. </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-28 20:41:32' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C6"/> </para><para>This bit confused me terribly... </para><screen><![CDATA[It is possible that two modules will need access to the same option, for example.]]></screen><para>Do you mean 'access' by the dictionary meaning or do you actually mean access to _set_ during reconfigure? </para><para>Name one instance where it's a good idea to load two components simultaneously which use the same configuration line tag with different option formats please? </para><para>If you mean two modules sharing the exact same options, then they need to be created such that loading both at the same time does not clash and their state is kept in-sync. This is not a problem for the Squid config or parser should deal with. </para><para>Or should the shared line like <code> asl bar src all</code> be parsed separately and stored separately for each component that needs to reference it? </para><screen><![CDATA[ We also do not know the order in which the options should be handled by the module (and that order can be dynamic so always using the registration order is not good enough). Overall, it just adds complexity and makes the interface more rigid than necessary.]]></screen><para>Huh? I make no such assumptions! registration order is only relevant to ensure that each squid.conf option/tag has a known object to receive it. </para><para>Hmm, yes we are facing different world aspects in this discussion. For example some of your statements make me think you define 'option' as something other that the 'acl' in &quot;acl foo ... bar&quot;. </para><para>For the rest of it I think I'm seeing a little bit of what you mean, but you appear to be not seeing the transition requirements. Lets lay out the assumption/guarantees I'm making here and where they come from... </para><screen><![CDATA[I do not think it is a good idea to limit module configuration API to "one option at a time" and add an "module option registration" interface. In my sketch the module knows its options and handles them however it wants. There may be a common/shared code that a module can reuse to handle one option at a time, of course, but I would not expose that detail to the upper layer or force it on lower layers.]]></screen><para>'one option at a time' is needed during the transition to prevent breakage of the very many components which require things like this to work: </para><screen><![CDATA[ http_access allow foo
 acl bar src all
 http_access deny bar]]></screen><para>When the transition is completed, that limit may be removed. In fact with the model I'm proposing the 3-step process of pre-config/config/post-config allows an easy way to make the above async and/or parallel if so desired. Without forcing us to consider the details of such usage right now. </para><para>We know that the squid.conf is order-specific. Some components make use of that guarantee, some do not care. This is a detail of the upper layer parse implementation. The lower design does (and only) needs to guarantee that lines are passed to the component in the order they were configured and component is notified when configuration is complete. see above about sync/async again. The added bonus in this case is the pre-config call to allow such things as shadow TheConfig to be created and setup. Which does not yet exist at all in Squid. </para><para>What I'm reading you're saying:  that we should code squid to handle every possible option and disallow plugin components from doing their own parse? to be handed a pre-filled object (which squid should not even know the field format of!) when reconfigure is needed. </para><para>I'm saying: </para><itemizedlist><listitem><para>leave the parse details to the upper layer where the option details are known. Lower level only needs to pass the right option text buffer to the right component processor unit then move on to the next line. </para></listitem><listitem><para>configure is a process of three function calls pre/configure/post to warn the component whats about to happen. What gets done is not relevant to the lower layer. </para></listitem></itemizedlist><para>I also took a look at breaking the line down into generic tokens and passing the option handler a list. A both you and kinkie suggested. We hit one major problem their. The exact nature of tokens to split on will need to be hard-coded into squid. for now we use whitespace, but even now there are exceptions to that. Some lines parse with or without quoting, some do not. Others split on '=' as well as whitespace but only for special portions of a line. Things like the ACL IP lists split on '-' and '/' as well, again only in one part of the line. We simply cannot make any assumptions as to what a component may need in a token. </para><screen><![CDATA[The last bit in your sketch is about a possible way to implement reconfiguration, I think. Again, I would not force that way on all modules. I would just give them the new or "future" Module::Config object and let them figure out how to handle the transition. The arguments are very similar to the "one registered line at a time only" objections above.]]></screen><para>... so we instead force squid to know in advance of loading any third-party module exactly what format its TheConfig class/structure has? create a new one, Parse into it, and pass it back to the component? in order to _save_ complexity? I don't believe I have to mention any of the problems associated with that to you. </para><para>IMO thats _way_ more complexity and trouble than simply passing squid.conf buffers to the component. You could I suppose go the way of having pre-configure method/function return a void* that gets passed back. </para><para>BUT. since we can only be doing reconfigure or not doing reconfigure. IMO again we should leave the TheConfig handling and details to the component if it even needs them. </para><para>Consider the third-party black-box component Widget dynamically loaded last configure time.  In order to parse the widget_magic lines which part of the upper layer (squid) and lower-layer (component library) whats the minimum transfer of information and call complexity we can do? </para><screen><![CDATA[  squid:  'about to reconfigure'
  widget: '(void)
  squid:  'reconfigure your widget_magic with this line from squid.conf ...'
  squid:  'reconfigure your widget_magic2 with this line from squid.conf ...'
  widget:  'okay / error / abort'
  squid:  'done configuring.'
  widget:  'okay / error / abort']]></screen><screen><![CDATA[I feel it is critical to separate parsing from [re]configuration. We should not even attempt to [re]configure Squid if parsing fails. Parsing produces Module::Config objects, that have no effect other than memory use. Most common errors are detected at this stage. If everything is OK, all modules are asked to [re]configure themselves using these Config objects. We can even go further and have three reconfiguration steps:]]></screen><para>at east we agree on that much. As you re-state my model with an additional validation step, but no pre-setup for the component to create its 'empty' TheConfig for us <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/smile.png" width="15"/></imageobject><textobject><phrase>:)</phrase></textobject></inlinemediaobject> </para><para>Validation IMO should happen at the point of parsing. It's either a valid parse or not, and the state produced should be expected to work. If you like a separate meta-validate after everything is parsed into the new TheConfig set to check dependencies etc, fine. I think it will turn out to be very small, but it may be useful. </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AmosJeffries#">AmosJeffries</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-29 05:46:56' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C7"/> </para><para>I am sorry, but do not follow most of your comments because I think you are attacking a model that I am not proposing while discussing low-level details that seem irrelevant to me. I suspect there is just basic disconnect between our terminology and expressions that prevents us from understanding each other and making progress. We need to step back, I think. </para><para>We should either make smaller steps or discuss this online. I will try the former first. </para><para>In my model, there are two most important design decisions: </para><orderedlist numeration="loweralpha"><listitem><para>Each module has its own Config class (i.e., Module::Config), inherited from some common base ModuleConfig class. Only module M users know the details of M::Config. Others just know it is an instance of the base ModuleConfig class, with a few common methods for reporting and such. Configs from all modules are collected into one SquidConfig class, but that is not important in most cases. The exact shape of that SquidConfig class is not important for now. </para></listitem><listitem><para>A module Config object has no runtime effect on Squid except when it is used as the &quot;current&quot; config for the module. For each module, many, possibly conflicting, Config objects might exist at the same time, but there is only one current config for each module and for Squid as a whole. </para></listitem></orderedlist><para>And there are three most important configuration and reconfiguration steps: </para><orderedlist numeration="arabic"><listitem><para>During the first step, each Module creates its Config object by parsing whatever squid.conf options are needed to be parsed for that module. Let's ignore how that parsing is done for now. Let's ignore how the module decides which parts of squid.conf are relevant to that module. Let's ignore how squid.conf is presented to the module. Created Config objects are assembled into a Squid Config object. Let's ignore how that is done and by whom. That Squid Config object, with no runtime effect, is the ultimate result of step1. If a module fails to produce a valid Config object, step1 aborts. </para></listitem><listitem><para>During the second step, each module validates its Config object in the context of other Config objects where necessary. This step can be merged with step1, but it is better to keep it separate for several reasons. One reason is to allow for inter-module checks such as &quot;My config option Foo requires option Bar in module M2. Is M2::Bar specified?&quot;. You cannot do such checks during parsing because module M2 may be creating its Config after we created ours. Also note that if some module decides to merge step1 and step2, it is free to do so. Such module will just always say &quot;yes, this config is valid&quot; for step2. </para></listitem><listitem><para>During the third step, each module applies its Config object (i.e., makes the supplied Config object &quot;current&quot;). This step must be separate and last because we do not want to leave Squid in a partially configured state. If squid.conf became invalid, reconfiguration should be a no-op (except error messages and such). </para></listitem></orderedlist><para>Ignoring all other details, do you see any serious problems with the above? </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-29 21:24:49' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C8"/> </para><para>Yes I think we are definitely talking to different things. I will try harder to catch you on IRC about the fine details of the processing. </para><para>For now I will concentrate on your design for the config objects and point out where I disagree instead of comparing: </para><screen><![CDATA[ a. Each module has its own Config class (i.e., Module::Config), inherited from some common base ModuleConfig class. Only module M users know the details of M::Config. Others just know it is an instance of the base ModuleConfig class, with a few common methods for reporting and such. Configs from all modules are collected into one SquidConfig class, but that is not important in most cases. The exact shape of that SquidConfig class is not important for now.]]></screen><para>You make 3 design choices above. </para><itemizedlist><listitem><para><emphasis>Module::Config existence</emphasis>. I agree and am coding with you in Features/SourceLayout for this. </para></listitem><listitem><para><emphasis>Module::Config inheriting from a base class</emphasis>. May be useful if the API methods are to be virtual. The only use I see for this is the cachemgr config 'dump' display. I could go either way here. </para></listitem><listitem><para><emphasis>Module::Config being integrated into a Squid::Config</emphasis>. This worries me. A _lot_ of the current dependency loops in Squid are directly caused by the existence of struct SquidConfig. I was under the impression that the cleanup work was dropping such dependency. We need to clarify this further. </para></listitem></itemizedlist><screen><![CDATA[ b. A module Config object has no runtime effect on Squid except when it is used as the "current" config for the module. For each module, many, possibly conflicting, Config objects might exist at the same time, but there is only one current config for each module and for Squid as a whole.]]></screen><para>I disagree with <emphasis>For each module, many, possibly conflicting, Config objects might exist at the same time</emphasis>. I see no cause for more than 2 to exist at the same time for any given module. One active config. One shadow config being altered. </para><para>More than 2 config objects and we enter realms of state maintenance and merge complexity which I strongly believe are unnecessary to even consider allowing inside Squid. </para><!--rule (<hr>) is not applicable to DocBook--><para> I think we begin to differ wildly on the reconfiguring process. </para><para>I break step (1) down to show how/why we differ in view here and seek to understand what you are talking about... </para><para><emphasis>1. During the first step, each Module creates its Config object by parsing whatever squid.conf options are needed to be parsed for that module.</emphasis> </para><itemizedlist><listitem><para>Agreed. So far we are mostly in-sync, only the meaning of <emphasis>creates</emphasis> vs <emphasis>fills</emphasis> could be confusion or difference. </para></listitem></itemizedlist><orderedlist numeration="loweralpha"><listitem><para><emphasis>Let's ignore how that parsing is done for now.</emphasis> </para><itemizedlist><listitem><para>I get worried. But okay. </para></listitem></itemizedlist><para>b. <emphasis>Let's ignore how the module decides which parts of squid.conf are relevant to that module.</emphasis> </para><itemizedlist><listitem><para>Here we hit a vital assumption. I don't think we _can_ ignore it. </para></listitem><listitem><para>How this happens defines critically whether we are doing <emphasis role="strong">fill Module::Config</emphasis> or <emphasis role="strong">create Module::Config</emphasis> (with strict state of existence meanings to those words). </para></listitem><listitem><para>How this happens defines large parts of the parser (okay we ignoring that). </para></listitem><listitem><para>How these decisions are made defines how many little Module::Config are left floating around inside Squid and how we reference to them. </para></listitem><listitem><para>How many ModuleX::Config instances we have defines how we handle correlating them back together. </para></listitem></itemizedlist><para>c. <emphasis>Let's ignore how squid.conf is presented to the module.</emphasis> </para><itemizedlist><listitem><para>Another vital assumption. I don't think we can ignore this one either. </para></listitem><listitem><para>How this is presented defines what configuration states which can exist. </para></listitem><listitem><para>Backward compatibility adds a lot of constraints. </para></listitem><listitem><para>How the constraints are handled by the Module::Config states defines how relevant squid.conf parts are detected. (see the loop?) </para></listitem></itemizedlist><para>d. <emphasis>Created Config objects are assembled into a Squid Config object. Let's ignore how that is done and by whom.</emphasis> </para><itemizedlist><listitem><para>Another vital assumption we can't just ignore. </para></listitem><listitem><para>IMO unnecessary as stated. </para></listitem><listitem><para>The only use I see here is to allow calling of the Module::Config API methods. </para></listitem><listitem><para>We need to clarify what you are trying to achieve with this. </para></listitem><listitem><para>This one defines whether or not we _can_ handle more than one Module::Config object at all. </para></listitem><listitem><para>Also defines the central core step of what is termed hot-config, which I thought we were aiming at a design for. </para></listitem></itemizedlist><para>e.<emphasis>That Squid Config object, with no runtime effect, is the ultimate result of step1. If a module fails to produce a valid Config object, step1 aborts.</emphasis> </para><itemizedlist><listitem><para>IMO the super-object does not need to even exist as a data construct. </para></listitem><listitem><para>It can exist perfectly well as an information state. </para></listitem><listitem><para>Fatal error at any point up or down the configure system is a fatal error, not just the data currently held at sub-system terminus. </para></listitem></itemizedlist></listitem></orderedlist><para>The other steps (2) and (3) only make sense under the basic assumptions you are making for the above step. Until we agree on step (1) design I think we should skip them. </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AmosJeffries#">AmosJeffries</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-04-30 03:51:00' which caused the docbook-formatter to choke. Please file a bug.--> </para><para><anchor id="C9"/> </para><para>Your first two worries are non-issues, I think: </para><screen><![CDATA["Module::Config being integrated into a Squid::Config" worries me. A _lot_ of the current dependency loops in Squid are directly caused by the existence of struct SquidConfig. I was under the impression that the cleanup work was dropping such dependency. We need to clarify this further.]]></screen><para>Integration does not mean we are going to have a struct comprising of individual module configuration members. We may have a searchable collection of ModuleConfig pointers (one for each module) or something of that kind. The resulting SquidConfig class will not know about individual modules. We most likely need a &quot;single config&quot; class so that we can pass global configuration around to code that needs it.  </para><para>For example, during validation step, some code may need access to Module::Config objects from various modules and that code cannot just ask modules themselves because those Module::Config objects have not been applied/stored yet.  </para><screen><![CDATA[I disagree with ''For each module, many, possibly conflicting, Config objects might exist at the same time''. I see no cause for more than 2 to exist at the same time for any given module. One active config. One shadow config being altered.]]></screen><para>I agree that we probably do not need more than two Config objects per module in the Squid executable. Some future configuration-related tools might deal with more (e.g., some kind of a config upgrade tool with user input capability and an undo or history operation). </para><para>From the design point of view, 2 or 22 should make no significant difference at this stage though. I said &quot;many&quot; to emphasize that the Config objects are not assumed to be well-known global singulars, tied to their module state like we have them now (at best). They will be &quot;regular&quot; objects that one could multiply as needed. </para><para>So these are settled, I think. Let's call that progress! </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-05-02 05:54:46' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <anchor id="C10"/> </para><para>I believe we have rough agreement on the high-level definition for the first configuration step, despite that you think you cannot ignore some of the details. As long as you agree that my high-level statements _may_ be correct (if we do the details right), we are in agreement. </para><para>I think we can ignore most of what you are worried about until the high-level steps are agreed upon. One can always ignore things until there is nothing to argue about (with a risk that some high-level decisions would have to be redone when details are considered)! However, let's try to nail at least two of these concerns now: </para><para>1. I do not really understand the &quot;creation versus fill&quot; problem. I think we will create _and_ fill. Clearly, the module will create its own Config object: The module knows the actual Module::Config type. The Configurator (i.e., Squid code performing the high-level configuration steps) does not use and should not know that specific type. The created object will then be filled with specific values based on the actual configuration file. We cannot immediately create a filled object so this &quot;filling&quot; process seems to be reasonable and necessary. Whether the module code will fill Config or Config will fill itself is not important for now. </para><para>2. Existence of a &quot;cumulative config&quot; class called SquidConfig or similar. Again, I doubt we can or should avoid it. C9 above gives one motivation: cross-module config validation. We cannot check whether future module M1 config is consistent with future module M2 config if we do not have access to both future configs from the same place. Thus, we need to store all future configs somewhere before we can validate and apply them. That storage is SquidConfig. Other uses include reporting and persistent storage: neither should know the list of all modules (by name) and, hence, both would need some kind of &quot;config container&quot;. I hope the fact that I am not proposing a monolithic structure with &quot;Module1::Config c1; Module2::Config c2; ...&quot; as members addresses your corresponding concerns.   </para><para>If the above is satisfactory, let's try to move on to step2 discussion and come back to the lower-level details as needed. </para><para>-- <ulink url="https://wiki.squid-cache.org/Features/HotConf/AlexRousskov#">AlexRousskov</ulink> <!--The macro DateTime caused an error and should be blacklisted. It returned the data '2009-05-02 06:29:04' which caused the docbook-formatter to choke. Please file a bug.--> </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/HotConf/CategoryFeature#">CategoryFeature</ulink> </para></section></section></article>