<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/PartialResponsesCaching</title><revhistory><revision><revnumber>2</revnumber><date>2014-05-10 13:38:16</date><authorinitials>AmosJeffries</authorinitials><revremark>add proposals I'm aware of. Faysals one sounds almost doable in the current code</revremark></revision><revision><revnumber>1</revnumber><date>2009-03-26 11:35:18</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Imported from bug 1337</revremark></revision></revhistory></articleinfo><section><title>Feature: Support caching of partial responses</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>: Enable the caching of partial responses, and obsolete the range_offset_limit configuration option. </para></listitem><listitem><para><emphasis role="strong">Status</emphasis>: <emphasis>Not started</emphasis> </para></listitem><listitem><para><emphasis role="strong">ETA</emphasis>: <emphasis>unknown</emphasis> </para></listitem><listitem><para><emphasis role="strong">Version</emphasis>: </para></listitem><listitem><para><emphasis role="strong">Priority</emphasis>: </para></listitem><listitem><para><emphasis role="strong">Developer</emphasis>: </para></listitem><listitem><para><emphasis role="strong">More</emphasis>: Originally from Bug <ulink url="https://bugs.squid-cache.org/show_bug.cgi?id=1337#">1337</ulink> </para></listitem><listitem><para><emphasis role="strong">More</emphasis>: <ulink url="http://tools.ietf.org/html/draft-ietf-httpbis-p5-range-26"/> </para></listitem></itemizedlist></section><section><title>Details</title><para>(from the bug report): When range_offset_limit is set to -1, Squid tries to fetch the entire object in response to an HTTP range request. </para><itemizedlist><listitem><para><emphasis role="strong">Bug</emphasis>: The entire object is fetched even when it is not cacheable (e.g. because it is larger than <ulink url="http://www.squid-cache.org/Doc/config/maximum_object_size#">maximum_object_size</ulink> or some other criteria). </para><itemizedlist><listitem><para>Squid should revert to fetching just the range if the entire object cannot be cached. </para></listitem><listitem><para>Squid should be able to fetch just the section(s) of object necessary and fill the gaps in the background. Otherwise, a patch fetching mechanism such as Windows Update, which fetches a patch file in N chunks, will cause the file to be fetched in its entirety N times. This can cause huge inefficiencies. Squid should always check for cacheability before fetching the entire file. </para></listitem></itemizedlist></listitem></itemizedlist><para>The proper fix for this is to add caching of partial responses, eleminating the need for <ulink url="http://www.squid-cache.org/Doc/config/range_offset_limit#">range_offset_limit</ulink> entirely. </para></section><section><title>Proposal 1: chunked sequencing</title><itemizedlist><listitem override="none"><para><emphasis>by Faysal Banna</emphasis> (with some small updates) </para></listitem></itemizedlist><para>Squid should store each object as a series of N-byte chunks. When a range is requested the whole of the chunk containing those bytes should be fetched into the relevat chunk position. </para><para>For example; in my cache i would save it in ranges of 1KB  which means 40KB file will be 40 chunks of 1KB each. </para><para>Suppose my file is called faysal.data </para><screen><![CDATA[chunk0 = faysal.data,0-1KB
chunk1 = faysal,data,1-2KB
...]]></screen><para>Now suppose the file is not cached yet nor requested and I request a range: bytes=2100-3000. </para><para>What Squid should do is: </para><orderedlist numeration="arabic"><listitem><para>skip the 1024-2048 chunk </para></listitem><listitem><para>fetch the 2049-3072 chunk </para></listitem><listitem><para>optionally skip the 3073+ chunks, or contiue fetching. </para></listitem></orderedlist><para>Caching the chunks received and marking the response as incomplete. </para><itemizedlist><listitem><para><ulink url="https://wiki.squid-cache.org/Features/PartialResponsesCaching/Features/LargeRockStore#">rock cache</ulink> is already operating as a series of ~32KB chunks for each object. It just needs extending to store non-sequential chunks, and detecting when needed chunks are missing to start background request(s) to fill gaps if a client asks more than already present. </para></listitem></itemizedlist></section><section><title>Proposal 2: sparse cache file</title><para>Squid should open a disk file for the full file size and fill only the bytes received. The rest can be loaded in background requests later. </para><itemizedlist><listitem><para>NP: requires some method of mapping which file bytes have been received and accountig for the variable-length metadata headers in each cache object file. </para></listitem></itemizedlist></section><section><title>Proposal 3: caching by Range</title><para>Squid caches Vary responses using additional cache key components. Range responses should be cached using a similar mechanism altering the cache key for the range. </para><itemizedlist><listitem><para>NP: needs logic to represent a list of all stored ranges in the variant meta entry. Vary caching uses X-Vary-Headers. Range would need a payload. </para></listitem><listitem><para>Update: a Store-ID helper can possibly be used to track which URLs are stored incompletely and handle the key alterations. </para></listitem></itemizedlist><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/PartialResponsesCaching/CategoryFeature#">CategoryFeature</ulink> </para></section></article>