<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/LoadBalance</title><revhistory><revision><revnumber>10</revnumber><date>2021-05-27 05:23:56</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>9</revnumber><date>2015-11-06 15:54:00</date><authorinitials>AlexRousskov</authorinitials><revremark>Partially detailed how the destination list is built.</revremark></revision><revision><revnumber>8</revnumber><date>2011-08-16 00:53:11</date><authorinitials>AmosJeffries</authorinitials><revremark>mention bug in default algorithm and related changes</revremark></revision><revision><revnumber>7</revnumber><date>2011-06-29 22:07:37</date><authorinitials>AmosJeffries</authorinitials><revremark>typo</revremark></revision><revision><revnumber>6</revnumber><date>2011-06-09 02:41:20</date><authorinitials>AmosJeffries</authorinitials><revremark>exaplain weighted-round-robin bias a littl more. mention basetime= option usage.</revremark></revision><revision><revnumber>5</revnumber><date>2011-06-09 01:12:21</date><authorinitials>AmosJeffries</authorinitials><revremark>typos the log types of hash algorithms</revremark></revision><revision><revnumber>4</revnumber><date>2011-05-18 01:00:16</date><authorinitials>AmosJeffries</authorinitials><revremark>document the peer selection balancing algorithms, add byte-based selection to wishlist.</revremark></revision><revision><revnumber>3</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>2</revnumber><date>2007-10-09 04:46:42</date><authorinitials>AlexRousskov</authorinitials><revremark>Separate categories with a pipe symbol</revremark></revision><revision><revnumber>1</revnumber><date>2007-10-09 03:17:12</date><authorinitials>AlexRousskov</authorinitials><revremark>Moving Load Balancing wish to its own feature page</revremark></revision></revhistory></articleinfo><section><title>Feature: Load Balancing</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>: Load balance origin servers or peers. </para></listitem><listitem><para><emphasis role="strong">Version</emphasis>: 2.6 </para></listitem></itemizedlist><section><title>Wish List</title><para>Support for squid to act as a load balancer is almost there, but some features are not well integrated or missing. </para><itemizedlist><listitem><para>Parent selection can now be done with ACLs. </para></listitem><listitem><para>Session affinity can currently be done using the client IP addresses. To have that done as a cookie, it is now responsibility of the backend application to set that cookie. It would be nice to have an external authenticator in charge of that. </para></listitem><listitem><para>Squid does accounting of all traffic going to a peer. It would be nice to have a byte-based balancing algorithm or two. </para></listitem></itemizedlist></section><section><title>Overall peer selection logic</title><para>To forward a request, Squid builds a list of unique destinations to try. These destinations may include peers (<ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink>) and origin servers. The destinations are then used as needed in the order they were added to the list. Usually, the very first destination in the list serves the request, but various failures may necessitate contacting other destinations. This section describes how the destination list is constructed. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> This section currently assumes that there are <emphasis role="strong">no</emphasis> pinned connections, ICP/HTCP queries, netdb databases, and Cache Digests to deal with. If your Squid uses those features, the destination list may <emphasis>start</emphasis> with peers selected by algorithms other than those listed in this section! Additional documentation covering these important use cases is welcomed. </para></listitem></itemizedlist><para>First of all, Squid decides whether to go direct, selecting from the following four possible answers: </para><itemizedlist><listitem><para>Go direct. </para></listitem><listitem><para>Go through a peer. </para></listitem><listitem><para>Prefer going direct (but peer if needed). </para></listitem><listitem><para>Prefer peering (but go direct if needed). </para></listitem></itemizedlist><para>This decision to go direct or use peering is based on the combination of <ulink url="http://www.squid-cache.org/Doc/config/always_direct#">always_direct</ulink>, <ulink url="http://www.squid-cache.org/Doc/config/never_direct#">never_direct</ulink>, and various transaction properties/restrictions. If those initial checks are inconclusive, Squid uses <ulink url="http://www.squid-cache.org/Doc/config/prefer_direct#">prefer_direct</ulink> to pick from the last two possible options (prefer direct or prefer peering). The decision affects which peer selection algorithms are used to add destinations to the list, as detailed below. </para><section><title>Go direct</title><para>If Squid decides to go direct, it adds the origin server to the destination list. </para></section><section><title>Go through a peer</title><para>If Squid decides to peer with another proxy, it builds the destination list using the following three steps: </para><orderedlist numeration="arabic"><listitem><para>Add the &quot;best&quot; peer to use, if any. </para></listitem><listitem><para>Add All Alive Parents, if any. </para></listitem><listitem><para>Add Default Parent, if any. </para></listitem></orderedlist><para>The &quot;best&quot; peer in step #1 is the very first peer found by the following ordered sequence of peer-selection algorithms: </para><itemizedlist><listitem><para>Source IP Hash </para></listitem><listitem><para>Username Hash </para></listitem><listitem><para>CARP </para></listitem><listitem><para>Round Robin </para></listitem><listitem><para>Weighted Round Robin </para></listitem><listitem><para>First-Up Parent </para></listitem><listitem><para>Default Parent </para></listitem></itemizedlist><para>The Default Parent algorithm at the end of step #1 sequence is the same as the algorithm executed at step #3, but Default Parent in step #1 may never get a chance to run if another step #1 algorithm finds the &quot;best&quot; peer... </para><para>Each of the above peer-selection algorithms (including All Alive Parents in step #2) checks each candidate peer against the following <emphasis>disqualifying</emphasis> conditions before adding the candidate to the destination list: </para><itemizedlist><listitem><para>The peer has an <emphasis>originserver</emphasis> type and the request is a CONNECT for a non-peer port. </para></listitem><listitem><para><ulink url="http://www.squid-cache.org/Doc/config/cache_peer_access#">cache_peer_access</ulink> denies access to the peer. </para></listitem></itemizedlist><para>Peers that meet at least one of the above disqualifying conditions are not added to the destination list. </para></section><section><title>Prefer going direct</title><para>Squid builds the destination list using the following two steps: </para><orderedlist numeration="arabic"><listitem><para>Add the origin server to the destination list. </para></listitem><listitem><para>If the request is &quot;hierarchical&quot; or <ulink url="http://www.squid-cache.org/Doc/config/nonhierarchical_direct#">nonhierarchical_direct</ulink> is off, then Squid follows the three steps described in the &quot;Going through a peer&quot; subsection above. Otherwise, this step does nothing. </para></listitem></orderedlist></section><section><title>Prefer peering</title><para>Squid builds the destination list using the following two steps: </para><orderedlist numeration="arabic"><listitem><para>If the request is &quot;hierarchical&quot; or <ulink url="http://www.squid-cache.org/Doc/config/nonhierarchical_direct#">nonhierarchical_direct</ulink> is off, then Squid follows the three steps described in the &quot;Going through a peer&quot; subsection above. Otherwise, this step does nothing. </para></listitem><listitem><para>Add the origin server to the destination list. </para></listitem></orderedlist></section></section><section><title>Peer Selection Algorithms</title><para>When building a hierarchy of peers into a load balanced, high performance or high availability / failure tolerant layering there are a number of algorithms Squid makes available. </para><para>The following algorithms are listed in order of preference. Squid will try to find an available peer using each of these algorithms in turn. If there are no available peers configured for that algorithm it will skip to the next. </para><para>In absence of any configuration the peers selected will be: </para><itemizedlist><listitem override="none"><para>first ICP responding sibling, followed by <emphasis role="strong">default</emphasis> <emphasis role="strong">first-up</emphasis> parent then <emphasis role="strong">default</emphasis> <ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink>. </para></listitem></itemizedlist><section><title>HTCP : Hyper Text Caching Protocol</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log Code</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> UDP_*, SIBLING_HIT, PARENT_HIT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> no-query </para></entry><entry colsep="1" rowsep="1"><para> Disable HTCP queries to this peer. </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"/><entry colsep="1" rowsep="1"><para> htcp </para></entry><entry colsep="1" rowsep="1"><para> Enable HTCP queries to this peer (instead of ICP). </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"/><entry colsep="1" rowsep="1"><para> htcp= </para></entry><entry colsep="1" rowsep="1"><para> Enable HTCP queries to this peer (instead of ICP). </para></entry></row></tbody></tgroup></informaltable><para>This is a UDP based fetch-response protocol used to discover if a <emphasis role="strong">sibling</emphasis> peer has an object from the same URL already stored. see RFC <ulink url="https://tools.ietf.org/rfc/rfc2756#">2756</ulink> for details on this protocol. </para><para>This protocol sends whole HTTP headers to the peer for response decision making. It should be preferred over ICP selection wherever possible, but can cause a larger background traffic overhead. </para></section><section><title>ICP : Internet Cache Protocol</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log Code</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> UDP_*, SIBLING_HIT, PARENT_HIT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> no-query </para></entry><entry colsep="1" rowsep="1"><para> Disable ICP queries to this peer. </para></entry></row></tbody></tgroup></informaltable><para>This is a UDP based fetch-response protocol used to discover if a <emphasis role="strong">sibling</emphasis> peer has an object from the same URL already stored. see RFC <ulink url="https://tools.ietf.org/rfc/rfc2186#">2186</ulink> for details on this protocol. </para><para>It suffers from some limitations due to only requesting the URL. Modern HTTP concept of <emphasis>variants</emphasis> is not included (one URL with a gzipped variant, a deflate variant, a sdch variant, a plain-text variant, etc). A lot of websites also provide many variants based on other visitor details. So there is a risk of false positives and sub-optimal routing selection in the modern www. see HTCP below for the fix. </para></section><section><title>Default Parent</title><informaltable><tgroup cols="2"><colspec colname="col_0"/><colspec colname="col_1"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> DEFAULT_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> default </para></entry></row></tbody></tgroup></informaltable><para>If a peer is marked as <emphasis>default</emphasis> it is always considered for use as a fallback source. Although if DEAD or blocked by ACL requirements it may be skipped. Only one peer may be marked as the default. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-error.png" width="16"/></imageobject><textobject><phrase>{X}</phrase></textobject></inlinemediaobject> Despite the documentation stating this since squid-2.6; in squid older than 3.1.15 a default peer will in fact be preferred over all other selection algorithms. This has been corrected in 3.1.15 so that default is a last-resort choice matching the documentation. </para></listitem></itemizedlist></section><section><title>Source IP Hash</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> SOURCEHASH_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> sourcehash </para></entry><entry colsep="1" rowsep="1"><para> Use IP-based hash algorithm with this peer </para></entry></row></tbody></tgroup></informaltable><para>Peers marked for <emphasis>sourcehash</emphasis> are bundled into a group and a hash is used to load balance based on IP address such that each user always goes through the same peer. </para><para>Almost identical to <emphasis>userhash</emphasis> this version can be used when login is not available. </para></section><section><title>Username Hash</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> USERHASH_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> userhash </para></entry><entry colsep="1" rowsep="1"><para> Use login based hash algorithm with this peer </para></entry></row></tbody></tgroup></informaltable><para>Peers marked for <emphasis>userhash</emphasis> are bundled into a group and a hash is used to load balance based on login username such that each user always goes through the same peer. There is some flexibility, when peers become unavailable or return to availability the hash is adjusted to cope with the change. </para><para>This algorithm is primarily needed to make predictable paths through clusters or hierarchies. It is particularly useful for ISP clusters having to cope with websites linking the IP and user login together as sessions (such as <ulink url="https://wiki.squid-cache.org/Features/LoadBalance/KnowledgeBase/Hotmail#">Hotmail</ulink>). These sessions break when passing through regular HTTP stateless clusters which split up the transaction stream for load balancing. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> In Squid older than 3.1.15 this is selected higher priority than Source IP hash. They are mutually exclusive algorithms, so this should not be an issue. </para></listitem></itemizedlist></section><section><title>CARP : Cache Array Routing Protocol</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> CARP </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> carp </para></entry><entry colsep="1" rowsep="1"><para> Use CARP hash algorithm with this peer</para></entry></row></tbody></tgroup></informaltable><para>Peers marked for CARP are bundled into a group and a hash is used to load balance URLs such that each URL always goes to the same peer. There is some flexibility, when peers become unavailable or return to availability the hash is adjusted to cope with the change. </para><para>This algorithm is one of the preferred methods of object de-duplication in cache clusters and load balancing for multi-instance installations of <ulink url="https://wiki.squid-cache.org/Features/LoadBalance/Squid-3.1#">Squid-3.1</ulink> and older (it is outdated in this purpose by SMP support in <ulink url="https://wiki.squid-cache.org/Features/LoadBalance/Squid-3.2#">Squid-3.2</ulink>). The efficient alternatives are multicast ICP or HTCP. </para></section><section><title>Round-Robin</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> ROUNDROBIN_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> weight=N </para></entry><entry colsep="1" rowsep="1"><para> Un-balance the connections to pick this peer N times each cycle. </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"/><entry colsep="1" rowsep="1"><para> basetime=T</para></entry><entry colsep="1" rowsep="1"><para> Fine tune the RTT distance bias. </para></entry></row></tbody></tgroup></informaltable><para>The classical load distribution algorithm. It operates like a circle selecting the first peer, then the second, then the third, etc until all peers have been used then selects the first again and repeats the sequence. Can be modified with <emphasis role="strong">weight=</emphasis> option to un-balance the connections. </para><para>There are some fundamental details which you need to be aware of, outlined below <emphasis>by Grant Taylor</emphasis> </para><para>In (basic) theory, yes. will alternate between the peers thus hypothetically equalizing the load on the connections. </para><section><title>Bias: Connection-based</title><para>The main noticeable bias is that this does <emphasis role="strong">not</emphasis> take in to account is what type of traffic a given connection is nor how long lived and active it is. </para><para>Let's say that I have the following (new) connections in the following sequence. </para><orderedlist numeration="arabic"><listitem><para> Simple HEAD request. </para></listitem><listitem><para> HTTP download of kernel source. </para></listitem><listitem><para> Simple image GET request, closed immediately. </para></listitem><listitem><para> CONNECT tunnel. </para></listitem></orderedlist><para>You will find that connections #1 and #3 are sent to peer-A and that connections #2 and #4 are sent to peer-B.  So what you end up with is two very <emphasis>light</emphasis> connections on peer-A and two <emphasis>much heavier</emphasis> connections on peer-B. </para><para>The connections did end up &quot;load balanced&quot; (in a manner of speaking), or &quot;distributed&quot; (is probably a better way to describe it) across the multiple peers.  However, if you look at the utilization of the two or the physical connections they represent, you will find that one is way under utilized and the other is probably saturated. </para><para>So, you do end up distributing the connections, but not necessarily load balancing. </para></section></section><section><title>Weighted Round-Robin</title><informaltable><tgroup cols="3"><colspec colname="col_0"/><colspec colname="col_1"/><colspec colname="col_2"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> ROUNDROBIN_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> weight=N </para></entry><entry colsep="1" rowsep="1"><para> Un-balance the connections to pick this peer N times each cycle. </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"/><entry colsep="1" rowsep="1"><para> basetime=T</para></entry><entry colsep="1" rowsep="1"><para> Fine tune the RTT distance bias. </para></entry></row></tbody></tgroup></informaltable><para>Simple adaptation on the classical <emphasis>round-robin</emphasis> algorithm. This one uses measurements of the TCP latency to each peer (RTT lag) to modify the weight of each peer. </para><para>The classical load distribution algorithm. It operates like a circle selecting the first peer, then the second, then the third, etc until all peers have been used then selects the first again and repeats the sequence. Can be modified with <emphasis role="strong">weight=</emphasis> option to un-balance the connections, this is in addition to the RTT weight. </para><para>It works best for load balancing in an ISP or CDN where the peers are remote with sizable RTT. When the peers are close or available on high-speed links with very low latency (such as a typical reverse-proxy or small CDN) the RTT weighting becomes nearly useless. </para><para>There is one potential benefit on high-speed networks. To provide early detection of peer overload. Squid peers will stop responding fast when overloaded. The lag weighting can reduce the load to that peer before connections start getting completely dropped or timing out (too) badly. </para><para>Consider peer A has a 5ms response RTT and peer B is on a neighbouring network with 10ms RTT. There is a 1:2 bias towards using peer A. </para><para>If you want to reduce or increase this bias you can configure the <emphasis>basetime=T</emphasis> option on <ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink>. It takes the number of milliseconds to be subtracted from RTT before the calculation is made. </para><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> Don't forget that basetime=T is a fixed value, and RTT lag can vary with network conditions. So this is just a bias, not a &quot;fix&quot; for distance problems. </para></listitem></itemizedlist></section><section><title>First-Up Parent</title><informaltable><tgroup cols="2"><colspec colname="col_0"/><colspec colname="col_1"/><tbody><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Log entry</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> FIRST_UP_PARENT </para></entry></row><row rowsep="1"><entry colsep="1" rowsep="1"><para> <emphasis role="strong">Options</emphasis> </para></entry><entry colsep="1" rowsep="1"><para> (none) </para></entry></row></tbody></tgroup></informaltable><para>Select the first squid.conf listed <ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink> <emphasis role="strong">parent</emphasis> entry which is marked as ALIVE and available. </para><para>This algorithm is the default used for <emphasis role="strong">parent</emphasis> peers. There is currently no explicit configuration option to turn it on/off. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/LoadBalance/CategoryFeature#">CategoryFeature</ulink> | <ulink url="https://wiki.squid-cache.org/Features/LoadBalance/CategoryWish#">CategoryWish</ulink> </para></section></section></section></article>