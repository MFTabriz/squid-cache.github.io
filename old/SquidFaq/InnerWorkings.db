<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>SquidFaq/InnerWorkings</title><revhistory><revision><revnumber>13</revnumber><date>2013-10-27 20:03:08</date><authorinitials>FrancescoChemolli</authorinitials><revremark>Fixed dangling wikilink</revremark></revision><revision><revnumber>12</revnumber><date>2013-09-21 01:03:29</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented re-forwarding logic.</revremark></revision><revision><revnumber>11</revnumber><date>2013-03-21 11:36:25</date><authorinitials>AmosJeffries</authorinitials><revremark>fix a bunch of typos. wiki-link a bunch of items and update some now incorrect details.</revremark></revision><revision><revnumber>10</revnumber><date>2009-04-08 02:11:15</date><authorinitials>AmosJeffries</authorinitials><revremark>correct docs for --enable-heap-replacement</revremark></revision><revision><revnumber>9</revnumber><date>2008-11-22 13:04:04</date><authorinitials>AmosJeffries</authorinitials><revremark>remove some outdated content. move dnsserve info to a Feature page.</revremark></revision><revision><revnumber>8</revnumber><date>2008-05-18 19:38:58</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>7</revnumber><date>2007-07-30 15:11:24</date><authorinitials>Henrik Nordstr√∂m</authorinitials><revremark>Vary objects is cached since many years back..</revremark></revision><revision><revnumber>6</revnumber><date>2007-03-02 18:22:39</date><authorinitials>kinkie</authorinitials><revremark>Markup Fixes</revremark></revision><revision><revnumber>5</revnumber><date>2006-08-29 10:45:44</date><authorinitials>kinkie</authorinitials><revremark>small fixup</revremark></revision><revision><revnumber>4</revnumber><date>2006-06-04 07:34:20</date><authorinitials>ReubenFarrelly</authorinitials><revremark>Formatting cleanups (extra ''' tend to mess the page up a bit)</revremark></revision><revision><revnumber>3</revnumber><date>2006-06-04 07:26:38</date><authorinitials>ReubenFarrelly</authorinitials><revremark>Updates to remove old Squid-1 references</revremark></revision><revision><revnumber>2</revnumber><date>2006-03-03 09:25:45</date><authorinitials>kinkie</authorinitials></revision><revision><revnumber>1</revnumber><date>2006-01-25 18:40:07</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>What are cachable objects?</title><para>An Internet Object is a file, document or response to a query for an Internet service such as FTP, HTTP, or gopher.  A client requests an Internet object from a caching proxy; if the object is not already cached, the proxy server fetches the object (either from the host specified in the URL or from a parent or sibling cache) and delivers it to the client. </para></section><section><title>What is the ICP protocol?</title><para>ICP is a protocol used for communication among squid caches. The ICP protocol is defined in two Internet RFC's. RFC <ulink url="https://tools.ietf.org/rfc/rfc2186#">2186</ulink> describes the protocol itself, while RFC <ulink url="https://tools.ietf.org/rfc/rfc2187#">2187</ulink> describes the application of ICP to hierarchical Web caching. </para><para>ICP is primarily used within a cache hierarchy to locate specific objects in sibling caches.  If a squid cache does not have a requested document, it sends an ICP query to its siblings, and the siblings respond with ICP replies indicating a &quot;HIT&quot; or a &quot;MISS.&quot; The cache then uses the replies to choose from which cache to resolve its own MISS. </para><para>ICP also supports multiplexed transmission of multiple object streams over a single TCP connection.  ICP is currently implemented on top of UDP.  Current versions of Squid also support ICP via multicast. </para></section><section><title>What is a cache hierarchy?  What are parents and siblings?</title><para>A cache hierarchy is a collection of caching proxy servers organized in a logical parent/child and sibling arrangement so that caches closest to Internet gateways (closest to the backbone transit entry-points) act as parents to caches at locations farther from the backbone.  The parent caches resolve &quot;misses&quot; for their children. In other words, when a cache requests an object from its parent, and the parent does not have the object in its cache, the parent fetches the object, caches it, and delivers it to the child.  This ensures that the hierarchy achieves the maximum reduction in bandwidth utilization on the backbone transit links, helps reduce load on Internet information servers outside the network served by the hierarchy, and builds a rich cache on the parents so that the other child caches in the hierarchy will obtain better &quot;hit&quot; rates against their parents. </para><para>In addition to the parent-child relationships, squid supports the notion of siblings:  caches at the same level in the hierarchy, provided to distribute cache server load.  Each cache in the hierarchy independently decides whether to fetch the reference from the object's home site or from parent or sibling caches, using a a simple resolution protocol.  Siblings will not fetch an object for another sibling to resolve a cache &quot;miss.&quot; </para></section><section><title>What is the Squid cache resolution algorithm?</title><orderedlist numeration="arabic"><listitem><para>Send ICP queries to all appropriate siblings </para></listitem><listitem><para>Wait for all replies to arrive with a configurable timeout (the default is two seconds). </para><orderedlist numeration="arabic"><listitem><para>Begin fetching the object upon receipt of the first HIT reply, or </para></listitem><listitem><para>Fetch the object from the first parent which replied with MISS (subject to weighting values), or </para></listitem><listitem><para>Fetch the object from the source </para></listitem></orderedlist></listitem></orderedlist><para>The algorithm is somewhat more complicated when firewalls are involved. </para><para>The <ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink> <emphasis role="strong">no-query</emphasis> option can be used to skip the ICP queries if the only appropriate source is a parent cache (i.e., if there's only one place you'd fetch the object from, why bother querying?) </para></section><section><title>What features are Squid developers currently working on?</title><para>The features and areas we work on are always changing. See the <ulink url="https://wiki.squid-cache.org/SquidFaq/InnerWorkings/RoadMap#">Squid Road Maps</ulink> for more details on current activities. </para></section><section><title>Tell me more about Internet traffic workloads</title><para>Workload can be characterized as the burden a client or group of clients imposes on a system.  Understanding the nature of workloads is important to the managing system capacity. </para><para>If you are interested in Internet traffic workloads then NLANR's <ulink url="http://www.nlanr.net/NA/">Network Analysis activities</ulink> is a good place to start. </para></section><section><title>What are the tradeoffs of caching with the NLANR cache system?</title><para>The NLANR root caches are at the NSF supercomputer centers (SCCs), which are interconnected via NSF's high speed backbone service (vBNS).  So inter-cache communication between the NLANR root caches does not cross the Internet. </para><para>The benefits of hierarchical caching (namely, reduced network bandwidth consumption, reduced access latency, and improved resiliency) come at a price.  Caches higher in the hierarchy must field  the misses of their descendents. If the equilibrium hit rate of a leaf cache is 50%, half of all leaf references have to be resolved through a second level cache rather than directly from the object's source.  If this second level cache has most of the documents, it is usually still a win, but if higher level caches often don't have the document, or become overloaded, then they could actually increase access latency, rather than reduce it. </para></section><section><title>Where can I find out more about firewalls?</title><para>Please see the <ulink url="http://www.faqs.org/faqs/firewalls-faq/">Firewalls FAQ</ulink> information site. </para></section><section><title>What is the &quot;Storage LRU Expiration Age?&quot;</title><para>For example: </para><screen><![CDATA[Storage LRU Expiration Age:      4.31 days]]></screen><para>The LRU expiration age is a dynamically-calculated value.  Any objects which have not been accessed for this amount of time will be removed from the cache to make room for new, incoming objects.  Another way of looking at this is that it would take your cache approximately this many days to go from empty to full at your current traffic levels. </para><para>As your cache becomes more busy, the LRU age becomes lower so that more objects will be removed to make room for the new ones.  Ideally, your cache will have an LRU age value in the range of at least 3 days.  If the LRU age is lower than 3 days, then your cache is probably not big enough to handle the volume of requests it receives.  By adding more disk space you could increase your cache hit ratio. </para></section><section><title>What is &quot;Failure Ratio at 1.01; Going into hit-only-mode for 5 minutes&quot;?</title><para>Consider a pair of caches named A and B.  It may be the case that A can reach B, and vice-versa, but B has poor reachability to the rest of the Internet. In this case, we would like B to recognize that it has poor reachability and somehow convey this fact to its neighbor caches. </para><para>Squid will track the ratio of failed-to-successful requests over short time periods.  A failed request is one which is logged as ERR_DNS_FAIL, ERR_CONNECT_FAIL, or ERR_READ_ERROR.  When the failed-to-successful ratio exceeds 1.0, then Squid will return ICP_MISS_NOFETCH instead of ICP_MISS to neighbors. Note, Squid will still return ICP_HIT for cache hits. </para></section><section><title>Does squid periodically re-read its configuration file?</title><para>No, you must send a HUP signal to have Squid re-read its configuration file, including access control lists.  An easy way to do this is with the <emphasis>-k</emphasis> command line option: </para><screen><![CDATA[squid -k reconfigure]]></screen></section><section><title>How does ''unlinkd'' work?</title><para><emphasis>unlinkd</emphasis> is an external process used for unlinking unused cache files. Performing the unlink operation in an external process opens up some race-condition problems for Squid.  If we are not careful, the following sequence of events could occur: </para><itemizedlist><listitem><para>An object with swap file number <emphasis role="strong">S</emphasis> is removed from the cache. </para></listitem><listitem><para>We want to unlink file <emphasis role="strong">F</emphasis> which corresponds to swap file number <emphasis role="strong">S</emphasis>, so we write pathname <emphasis role="strong">F</emphasis> to the <emphasis>unlinkd</emphasis> socket. We also mark <emphasis role="strong">S</emphasis> as available in the filemap. </para></listitem><listitem><para>We have a new object to swap out.  It is allocated to the first available file number, which happens to be <emphasis role="strong">S</emphasis>.  Squid opens file <emphasis role="strong">F</emphasis> for writing. </para></listitem><listitem><para>The <emphasis>unlinkd</emphasis> process reads the request to unlink <emphasis role="strong">F</emphasis> and issues the actual unlink call. </para></listitem></itemizedlist><para>So, the problem is, how can we guarantee that <emphasis>unlinkd</emphasis> will not remove a cache file that Squid has recently allocated to a new object? The approach we have taken is to have Squid keep a stack of unused (but not deleted!)  swap file numbers.  The stack size is hard-coded at 128 entries.  We only give unlink requests to <emphasis>unlinkd</emphasis> when the unused file number stack is full.  Thus, if we ever have to start unlinking files, we have a pool of 128 file numbers to choose from which we know will not be removed by <emphasis>unlinkd</emphasis>. </para><para>In terms of implementation, the only way to send unlink requests to the <emphasis>unlinkd</emphasis> process is via the <emphasis>storePutUnusedFileno</emphasis> function. </para><para>Unfortunately there are times when Squid can not use the <emphasis>unlinkd</emphasis> process but must call <emphasis>unlink(2)</emphasis> directly.  One of these times is when the cache swap size is over the high water mark.  If we push the released file numbers onto the unused file number stack, and the stack is not full, then no files will be deleted, and the actual disk usage will remain unchanged.  So, when we exceed the high water mark, we must call <emphasis>unlink(2)</emphasis> directly. </para></section><section><title>What is an icon URL?</title><para>One of the most unpleasant things Squid must do is generate HTML pages of Gopher and FTP directory listings.  For some strange reason, people like to have little <emphasis>icons</emphasis> next to each listing entry, denoting the type of object to which the link refers (image, text file, etc.). </para><para>We include a set of icons in the source distribution for this purpose. These icon files are loaded by Squid as cached objects at runtime. Thus, every Squid cache now has its own icons to use in Gopher and FTP listings.  Just like other objects available on the web, we refer to the icons with <ulink url="ftp://ftp.isi.edu/in-notes/rfc1738.txt">Uniform Resource Locators</ulink>, or <emphasis>URLs</emphasis>. </para></section><section><title>Can I make my regular FTP clients use a Squid cache?</title><para>Nope, its not possible.  Squid only accepts HTTP requests.  It speaks FTP on the <emphasis>server-side</emphasis>, but <emphasis role="strong">not</emphasis> on the <emphasis>client-side</emphasis>. </para><para>The very cool <ulink url="ftp://gnjilux.cc.fer.hr/pub/unix/util/wget/">wget</ulink> will download FTP URLs via Squid (and probably any other proxy cache). </para></section><section><title>Why is the select loop average time so high?</title><para><emphasis>Is there any way to speed up the time spent dealing with select</emphasis>? Cachemgr shows: </para><screen><![CDATA[ Select loop called: 885025 times, 714.176 ms avg]]></screen><para>This number is NOT how much time it takes to handle filedescriptor I/O. We simply count the number of times select was called, and divide the total process running time by the number of select calls. </para><para>This means, on average it takes your cache .714 seconds to check all the open file descriptors once.   But this also includes time select() spends in a wait state when there is no I/O on any file descriptors. My relatively idle workstation cache has similar numbers: </para><screen><![CDATA[Select loop called: 336782 times, 715.938 ms avg]]></screen><para>But my busy caches have much lower times: </para><screen><![CDATA[Select loop called: 16940436 times, 10.427 ms avg
Select loop called: 80524058 times, 10.030 ms avg
Select loop called: 10590369 times, 8.675 ms avg
Select loop called: 84319441 times, 9.578 ms avg]]></screen></section><section><title>How does Squid deal with Cookies?</title><para>The presence of Cookies headers in <emphasis role="strong">requests</emphasis> does not affect whether or not an HTTP reply can be cached.   Similarly, the presense of <emphasis>Set-Cookie</emphasis> headers in <emphasis role="strong">replies</emphasis> does not affect whether the reply can be cached. </para><para>The proper way to deal with <emphasis>Set-Cookie</emphasis> reply headers, according to  <ulink url="ftp://ftp.isi.edu/in-notes/rfc2109.txt">RFC 2109</ulink> is to cache the whole object, <emphasis>EXCEPT</emphasis> the <emphasis>Set-Cookie</emphasis> header lines. </para><para>However, we can filter out specific HTTP headers.  But instead of filtering them on the receiving-side, we filter them on the sending-side. Thus, Squid does cache replies with <emphasis>Set-Cookie</emphasis> headers, but it filters out the <emphasis>Set-Cookie</emphasis> header itself for cache hits. </para></section><section><title>How does Squid decide when to refresh a cached object?</title><para>When checking the object freshness, we calculate these values: </para><itemizedlist><listitem><para><emphasis>OBJ_DATE</emphasis> is the time when the object was given out by the </para></listitem></itemizedlist><para>origin server.  This is taken from the HTTP Date reply header. </para><itemizedlist><listitem><para><emphasis>OBJ_LASTMOD</emphasis> is the time when the object was last modified, </para></listitem></itemizedlist><para>given by the HTTP Last-Modified reply header. </para><itemizedlist><listitem><para><emphasis>OBJ_AGE</emphasis> is how much the object has aged <emphasis>since</emphasis> it was retrieved: </para></listitem></itemizedlist><screen><![CDATA[OBJ_AGE = NOW - OBJ_DATE]]></screen><itemizedlist><listitem><para><emphasis>LM_AGE</emphasis> is how old the object was <emphasis>when</emphasis> it was retrieved: </para></listitem></itemizedlist><screen><![CDATA[LM_AGE = OBJ_DATE - OBJ_LASTMOD]]></screen><itemizedlist><listitem><para><emphasis>LM_FACTOR</emphasis> is the ratio of <emphasis>OBJ_AGE</emphasis> to <emphasis>LM_AGE</emphasis>: </para></listitem></itemizedlist><screen><![CDATA[LM_FACTOR = OBJ_AGE / LM_AGE]]></screen><itemizedlist><listitem><para><emphasis>CLIENT_MAX_AGE</emphasis> is the (optional) maximum object age the client will </para></listitem></itemizedlist><para>accept as taken from the HTTP/1.1 Cache-Control request header. </para><itemizedlist><listitem><para><emphasis>EXPIRES</emphasis> is the (optional) expiry time from the server reply headers. </para></listitem></itemizedlist><para>These values are compared with the parameters of the <emphasis>refresh_pattern</emphasis> rules.  The refresh parameters are: </para><itemizedlist><listitem><para>URL regular expression </para></listitem><listitem><para><emphasis>CONF_MIN</emphasis>: The time (in minutes) an object without an explicit expiry time should be considered fresh. The recommended value is 0, any higher values may cause dynamic applications to be erronously cached unless the application designer has taken the appropriate actions. </para></listitem><listitem><para><emphasis>CONF_PERCENT</emphasis>: A percentage of the objects age (time since last modification age) an object without explicit exipry time will be considered fresh. </para></listitem><listitem><para><emphasis>CONF_MAX</emphasis>: An upper limit on how long objects without an explicit expiry time will be considered fresh. </para></listitem></itemizedlist><para>The URL regular expressions are checked in the order listed until a match is found.  Then the algorithms below are applied for determining if an object is fresh or stale. </para><para>The refresh algorithm used in Squid-2 looks like this: </para><screen><![CDATA[    if (EXPIRES) {
        if (EXPIRES <= NOW)
            return STALE
        else
            return FRESH
    }
    if (CLIENT_MAX_AGE)
        if (OBJ_AGE > CLIENT_MAX_AGE)
            return STALE
    if (OBJ_AGE > CONF_MAX)
        return STALE
    if (OBJ_DATE > OBJ_LASTMOD) {
        if (LM_FACTOR < CONF_PERCENT)
            return FRESH
        else
            return STALE
    }
    if (OBJ_AGE <= CONF_MIN)
        return FRESH
    return STALE]]></screen></section><section><title>What exactly is a ''deferred read''?</title><para>The cachemanager I/O page lists <emphasis>deferred reads</emphasis> for various server-side protocols. </para><para>Sometimes reading on the server-side gets ahead of writing to the client-side.  Especially if your cache is on a fast network and your clients are connected at modem speeds.  Squid will read up to <ulink url="http://www.squid-cache.org/Doc/config/read_ahead_gap#">read_ahead_gap</ulink> bytes (default of 16 KB) ahead of the client before it starts to defer the server-side reads. </para></section><section><title>Why is my cache's inbound traffic equal to the outbound traffic?</title><para><emphasis>I've been monitoring the traffic on my cache's ethernet adapter an found a behavior I can't explain: the inbound traffic is equal to the outbound traffic. The differences are negligible. The hit ratio reports 40%. Shouldn't the outbound be at least 40% greater than the inbound?</emphasis> </para><para>by  <ulink url="mailto:david@avarice.nepean.uws.edu.au">David J N Begley</ulink> </para><para>I can't account for the exact behavior you're seeing, but I can offer this advice;  whenever you start measuring raw Ethernet or IP traffic on interfaces, you can forget about getting all the numbers to exactly match what Squid reports as the amount of traffic it has sent/received. </para><para>Why? </para><para>Squid is an application - it counts whatever data is sent to, or received from, the lower-level networking functions;  at each successively lower layer, additional traffic is involved (such as header overhead, retransmits and fragmentation, unrelated broadcasts/traffic, etc.).  The additional traffic is never seen by Squid and thus isn't counted - but if you run MRTG (or any SNMP/RMON measurement tool) against a specific interface, all this additional traffic will &quot;magically appear&quot;. </para><para>Also remember that an interface has no concept of upper-layer networking (so an Ethernet interface doesn't distinguish between IP traffic that's entirely internal to your organization, and traffic that's to/from the Internet);  this means that when you start measuring an interface, you have to be aware of *what* you are measuring before you can start comparing numbers elsewhere. </para><para>It is possible (though by no means guaranteed) that you are seeing roughly equivalent input/output because you're measuring an interface that both retrieves data from the outside world (Internet), *and* serves it to end users (internal clients).  That wouldn't be the whole answer, but hopefully it gives you a few ideas to start applying to your own circumstance. </para><para>To interpret any statistic, you have to first know what you are measuring; for example, an interface counts inbound and outbound bytes - that's it.  The interface doesn't distinguish between inbound bytes from external Internet sites or from internal (to the organization) clients (making requests).  If you want that, try looking at RMON2. </para><para>Also, if you're talking about a 40% hit rate in terms of object requests/counts then there's absolutely no reason why you should expect a 40% reduction in traffic;  after all, not every request/object is going to be the same size so you may be saving a lot in terms of requests but very little in terms of actual traffic. </para></section><section><title>How come some objects do not get cached?</title><para>To determine whether a given object may be cached, Squid takes many things into consideration.  The current algorithm (for Squid-2) goes something like this: </para><itemizedlist><listitem><para>Responses with <emphasis>Cache-Control: Private</emphasis> are NOT cachable. </para></listitem><listitem><para>Responses with <emphasis>Cache-Control: No-Cache</emphasis> are NOT cachable by Squid older than <ulink url="https://wiki.squid-cache.org/SquidFaq/InnerWorkings/Squid-3.2#">Squid-3.2</ulink>. </para></listitem><listitem><para>Responses with <emphasis>Cache-Control: No-Store</emphasis> are NOT cachable. </para></listitem><listitem><para>Responses for requests with an <emphasis>Authorization</emphasis> header are cachable ONLY if the reponse includes <emphasis>Cache-Control: Public</emphasis> or some other special parameters controling revalidation. </para></listitem><listitem><para>The following HTTP status codes are cachable: </para><itemizedlist><listitem><para>200 OK </para></listitem><listitem><para>203 Non-Authoritative Information </para></listitem><listitem><para>300 Multiple Choices </para></listitem><listitem><para>301 Moved Permanently </para></listitem><listitem><para>410 Gone </para></listitem></itemizedlist></listitem></itemizedlist><para>However, if Squid receives one of these responses from a neighbor cache, it will NOT be cached if ALL of the <emphasis>Date</emphasis>, <emphasis>Last-Modified</emphasis>, and <emphasis>Expires</emphasis> reply headers are missing.  This prevents such objects from bouncing back-and-forth between siblings forever. </para><para>A 302 Moved Temporarily response is cachable ONLY if the response also includes an <emphasis>Expires</emphasis> header. </para><para>The following HTTP status codes are &quot;negatively cached&quot; for a short amount of time (configurable): </para><itemizedlist><listitem><para>204 No Content </para></listitem><listitem><para>305 Use Proxy </para></listitem><listitem><para>400 Bad Request </para></listitem><listitem><para>403 Forbidden </para></listitem><listitem><para>404 Not Found </para></listitem><listitem><para>405 Method Not Allowed </para></listitem><listitem><para>414 Request-URI Too Large </para></listitem><listitem><para>500 Internal Server Error </para></listitem><listitem><para>501 Not Implemented </para></listitem><listitem><para>502 Bad Gateway </para></listitem><listitem><para>503 Service Unavailable </para></listitem><listitem><para>504 Gateway Time-out </para></listitem></itemizedlist><para>All other HTTP status codes are NOT cachable, including: </para><itemizedlist><listitem><para>206 Partial Content </para></listitem><listitem><para>303 See Other </para></listitem><listitem><para>304 Not Modified </para></listitem><listitem><para>401 Unauthorized </para></listitem><listitem><para>407 Proxy Authentication Required </para></listitem></itemizedlist></section><section><title>What does ''keep-alive ratio'' mean?</title><para>The <emphasis>keep-alive ratio</emphasis> shows up in the <emphasis>server_list</emphasis> cache manager page. </para><para>This is a mechanism to try detecting neighbor caches which might not be able to deal with persistent connections.  Every time we send a <emphasis>Connection: keep-alive</emphasis> request header to a neighbor, we count how many times the neighbor sent us a <emphasis>Connection: keep-alive</emphasis> reply header.  Thus, the <emphasis>keep-alive ratio</emphasis> is the ratio of these two counters. </para><para>If the ratio stays above 0.5, then we continue to assume the neighbor properly implements persistent connections.  Otherwise, we will stop sending the keep-alive request header to that neighbor. </para></section><section><title>How does Squid's cache replacement algorithm work?</title><para>Squid uses an LRU (least recently used) algorithm to replace old cache objects.  This means objects which have not been accessed for the longest time are removed first.  In the source code, the <code>StoreEntry-&gt;lastref</code> value is updated every time an object is accessed. </para><para>Objects are not necessarily removed &quot;on-demand.&quot;  Instead, a regularly scheduled event runs to periodically remove objects.  Normally this event runs every second. </para><para>Squid keeps the cache disk usage between the low and high water marks. By default the low mark is 90%, and the high mark is 95% of the total configured cache size.  When the disk usage is close to the low mark, the replacement is less aggressive (fewer objects removed).  When the usage is close to the high mark, the replacement is more aggressive (more objects removed). </para><para>When selecting objects for removal, Squid examines some number of objects and determines which can be removed and which cannot. A number of factors determine whether or not any given object can be removed.  If the object is currently being requested, or retrieved from an upstream site, it will not be removed.   If the object is &quot;negatively-cached&quot; it will be removed.  If the object has a private cache key, it will be removed (there would be no reason to keep it -- because the key is private, it can never be &quot;found&quot; by subsequent requests). Finally, if the time since last access is greater than the LRU threshold, the object is removed. </para><para>The LRU threshold value is dynamically calculated based on the current cache size and the low and high marks.  The LRU threshold scaled exponentially between the high and low water marks.  When the store swap size is near the low water mark, the LRU threshold is large.  When the store swap size is near the high water mark, the LRU threshold is small. The threshold automatically adjusts to the rate of incoming requests. In fact, when your cache size has stabilized, the LRU threshold represents how long it takes to fill (or fully replace) your cache at the current request rate.  Typical values for the LRU threshold are 1 to 10 days. </para><para>Back to selecting objects for removal.  Obviously it is not possible to check every object in the cache every time we need to remove some of them. We can only check a small subset each time. </para><para>Every time an object is accessed, it gets moved to the top of a list.  Over time, the least used objects migrate to the bottom of the list.  When looking for objects to remove, we only need to check the last 100 or so objects in the list.  Unfortunately this approach increases our memory usage because of the need to store three additional pointers per cache object. We also use cache keys with MD5 hashes. </para></section><section><title>What are private and public keys?</title><para><emphasis>keys</emphasis> refers to the database keys which Squid uses to index cache objects.  Every object in the cache--whether saved on disk or currently being downloaded--has a cache key.  We use MD5 checksums for cache keys. </para><para>The Squid cache uses the notions of <emphasis>private</emphasis> and <emphasis>public</emphasis> cache keys.  An object can start out as being private, but may later be changed to public status.  Private objects are associated with only a single client whereas a public object may be sent to multiple clients at the same time.  In other words, public objects can be located by any cache client.  Private keys can only be located by a single client--the one who requested it. </para><para>Objects are changed from private to public after all of the HTTP reply headers have been received and parsed.  In some cases, the reply headers will indicate the object should not be made public. For example, if the <emphasis>private</emphasis> Cache-Control directive is used. </para></section><section><title>What is FORW_VIA_DB for?</title><para>We use it to collect data for  <ulink url="http://www.ircache.net/Cache/Plankton/">Plankton</ulink>. </para></section><section><title>Does Squid send packets to port 7 (echo)?  If so, why?</title><para>It may.  This is an old feature from the Harvest cache software. The cache would send ICP &quot;SECHO&quot; message to the echo ports of origin servers.  If the SECHO message came back before any of the other ICP replies, then it meant the origin server was probably closer than any neighbor cache.  In that case Harvest/Squid sent the request directly to the origin server. </para><para>With more attention focused on security, many administrators filter UDP packets to port 7.  The Computer Emergency Response Team (CERT) once issued an advisory note ( <ulink url="http://www.cert.org/advisories/CA-96.01.UDP_service_denial.html">CA-96.01: UDP Port Denial-of-Service Attack</ulink>) that says UDP echo and chargen services can be used for a denial of service attack.  This made admins extremely nervous about any packets hitting port 7 on their systems, and they made complaints. </para><para>The <emphasis>source_ping</emphasis> feature has been disabled in Squid-2.  If you're seeing packets to port 7 that are coming from a Squid cache (remote port 3130), then its probably a very old version of Squid. </para></section><section><title>What does &quot;WARNING: Reply from unknown nameserver [a.b.c.d]&quot; mean?</title><para>It means Squid sent a DNS query to one IP address, but the response  came back from a different IP address.  By default Squid checks that the addresses match.  If not, Squid ignores the response. </para><para>There are a number of reasons why this would happen: </para><orderedlist numeration="arabic"><listitem><para>Your DNS name server just works this way, either because its been configured to, or because its stupid and doesn't know any better. </para></listitem><listitem><para>You have a weird broadcast address, like 0.0.0.0, in your <emphasis>/etc/resolv.conf</emphasis> file. </para></listitem><listitem><para>Somebody is trying to send spoofed DNS responses to your cache. </para></listitem></orderedlist><para>If you recognize the IP address in the warning as one of your name server hosts, then its probably numbers (1) or (2). </para><para>You can make these warnings stop, and allow responses from &quot;unknown&quot; name servers by setting this configuration option: </para><screen><![CDATA[ignore_unknown_nameservers off]]></screen><itemizedlist><listitem override="none"><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> WARNING: this opens your Squid up to many possible security breaches. You should prefer to configure your set of possible nameserver IPs correctly. </para></listitem></itemizedlist></section><section><title>How does Squid distribute cache files among the available directories?</title><para><emphasis>Note: The information here is current for version 2.2.</emphasis> </para><para>See <emphasis>storeDirMapAllocate()</emphasis> in the source code. </para><para>When Squid wants to create a new disk file for storing an object, it first selects which <emphasis>cache_dir</emphasis> the object will go into.  This is done with the <emphasis>storeDirSelectSwapDir()</emphasis> function.  If you have <emphasis>N</emphasis> cache directories, the function identifies the <emphasis>3N/4</emphasis> (75%) of them with the most available space.  These directories are then used, in order of having the most available space.  When Squid has stored one URL to each of the <emphasis>3N/4</emphasis> <emphasis>cache_dir</emphasis>s, the process repeats and  <emphasis>storeDirSelectSwapDir()</emphasis> finds a new set of <emphasis>3N/4</emphasis> cache directories with the most available space. </para><para>Once the <emphasis>cache_dir</emphasis> has been selected, the next step is to find an available <emphasis>swap file number</emphasis>.  This is accomplished by checking the <emphasis>file map</emphasis>, with the <emphasis>file_map_allocate()</emphasis> function.  Essentially the swap file numbers are allocated sequentially.  For example, if the last number allocated happens to be 1000, then the next one will be the first number after 1000 that is not already being used. </para></section><section><title>Why do I see negative byte hit ratio?</title><para>Byte hit ratio is calculated a bit differently than Request hit ratio.  Squid counts the number of bytes read from the network on the server-side, and the number of bytes written to the client-side.  The byte hit ratio is calculated as </para><screen><![CDATA[        (client_bytes - server_bytes) / client_bytes]]></screen><para>If server_bytes is greater than client_bytes, you end up with a negative value. </para><para>The server_bytes may be greater than client_bytes for a number of reasons, including: </para><itemizedlist><listitem><para>Cache Digests and other internally generated requests. Cache Digest messages are quite large.  They are counted in the server_bytes, but since they are consumed internally, they do not count in client_bytes. </para></listitem><listitem><para>User-aborted requests.  If your <emphasis>quick_abort</emphasis> setting allows it, Squid sometimes continues to fetch aborted requests from the server-side, without sending any data to the client-side. </para></listitem><listitem><para>Some range requests, in combination with Squid bugs, can consume more bandwidth on the server-side than on the </para></listitem></itemizedlist><para>client-side.  In a range request, the client is asking for only some part of the object.  Squid may decide to retrieve the whole object anyway, so that it can be used later on. This means downloading more from the server than sending to the client.  You can affect this behavior with the <emphasis>range_offset_limit</emphasis> option. </para></section><section><title>What does &quot;Disabling use of private keys&quot; mean?</title><para>First you need to understand the difference between public and private keys. </para><para>When Squid sends ICP queries, it uses the ICP 'reqnum' field to hold the private key data.  In other words, when Squid gets an ICP reply, it uses the 'reqnum' value to build the private cache key for the pending object. </para><para>Some ICP implementations always set the 'reqnum' field to zero when they send a reply.   Squid can not use private cache keys with such neighbor caches because Squid will not be able to locate cache keys for those ICP replies.  Thus, if Squid detects a neighbor cache that sends zero reqnum's, it disables the use of private cache keys. </para><para>Not having private cache keys has some important privacy implications.  Two users could receive one response that was meant for only one of the users.  This response could contain personal, confidential information.  You will need to disable the 'zero reqnum' neighbor if you want Squid to use private cache keys. </para></section><section><title>What is a half-closed filedescriptor?</title><para>TCP allows connections to be in a &quot;half-closed&quot; state.   This is accomplished with the <emphasis>shutdown(2)</emphasis> system call.  In Squid, this means that a client has closed its side of the connection for writing, but leaves it open for reading.  Half-closed connections are tricky because Squid can't tell the difference between a half-closed connection, and a fully closed one. </para><para>If Squid tries to read a connection, and <emphasis>read()</emphasis> returns 0, and Squid knows that the client doesn't have the whole response yet, Squid puts marks the filedescriptor as half-closed. Most likely the client has aborted the request and the connection is really closed.  However, there is a slight chance that the client is using the <emphasis>shutdown()</emphasis> call, and that it can still read the response. </para><para>To disable half-closed connections, simply put this in squid.conf: </para><screen><![CDATA[half_closed_clients off]]></screen><para>Then, Squid will always close its side of the connection instead of marking it as half-closed. </para><itemizedlist><listitem override="none"><para><emphasis role="strong">NP:</emphasis> from <ulink url="https://wiki.squid-cache.org/SquidFaq/InnerWorkings/Squid-3.0#">Squid-3.0</ulink> the default is now OFF. </para></listitem></itemizedlist></section><section><title>What does --enable-heap-replacement do?</title><itemizedlist><listitem override="none"><para><emphasis>This option is only relevant for Squid-2. It has been replaced in Squid-3 by --enable-removal-policies=heap</emphasis> </para></listitem></itemizedlist><para>Squid has traditionally used an LRU replacement algorithm. However with Squid version 2.4 and later you should use this configure option: </para><screen><![CDATA[./configure --enable-heap-replacement]]></screen><para>Currently, the heap replacement code supports two additional algorithms: LFUDA, and GDS. </para><para>Then, in <emphasis>squid.conf</emphasis>, you can select different policies with the <ulink url="http://www.squid-cache.org/Doc/config/cache_replacement_policy#">cache_replacement_policy</ulink> directive. </para><para>The LFUDA and GDS replacement code was contributed by John Dilley and others from Hewlett-Packard.  Their work is described in these papers: </para><itemizedlist><listitem override="none"><para>- </para></listitem></itemizedlist><para><ulink url="http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html">Enhancement and Validation of Squid's Cache Replacement Policy</ulink> (HP Tech Report). </para><itemizedlist><listitem override="none"><para>- </para></listitem></itemizedlist><para><ulink url="http://workshop.ircache.net/Papers/dilley-abstract.html">Enhancement and Validation of the Squid Cache Replacement Policy</ulink> (WCW 1999 paper). </para></section><section><title>Why is actual filesystem space used greater than what Squid thinks?</title><para>If you compare <emphasis>df</emphasis> output and cachemgr <emphasis>storedir</emphasis> output, you will notice that actual disk usage is greater than what Squid reports.  This may be due to a number of reasons: </para><itemizedlist><listitem><para>Squid doesn't keep track of the size of the <emphasis>swap.state</emphasis> file, which normally resides on each <ulink url="http://www.squid-cache.org/Doc/config/cache_dir#">cache_dir</ulink>. </para></listitem><listitem><para>Directory entries and take up filesystem space. </para></listitem><listitem><para>Other applications might be using the same disk partition. </para></listitem><listitem><para>Your filesystem block size might be larger than what Squid thinks.  When calculating total disk usage, Squid rounds file sizes up to a whole number of 1024 byte blocks.  If your filesystem uses larger blocks, then some &quot;wasted&quot; space is not accounted. </para></listitem><listitem><para>Your cache has suffered some minor corruption and some objects have gotten lost without being removed from the swap.state file.  Over time, Squid will detect this and automatically fix it. </para></listitem></itemizedlist></section><section><title>How do ''positive_dns_ttl'' and ''negative_dns_ttl'' work?</title><para><ulink url="http://www.squid-cache.org/Doc/config/positive_dns_ttl#">positive_dns_ttl</ulink> is how long Squid caches a successful DNS lookup. Similarly, <ulink url="http://www.squid-cache.org/Doc/config/negative_dns_ttl#">negative_dns_ttl</ulink> is how long Squid caches a failed DNS lookup. </para><para><ulink url="http://www.squid-cache.org/Doc/config/positive_dns_ttl#">positive_dns_ttl</ulink> is not always used.  It is NOT used in the following cases: </para><itemizedlist><listitem><para>Squid-2.3 and later versions with internal DNS lookups. Internal lookups are the default for Squid-2.3 and later. </para></listitem><listitem><para>If you applied the &quot;DNS TTL&quot; for BIND as described in <ulink url="https://wiki.squid-cache.org/SquidFaq/InnerWorkings/SquidFaq/CompilingSquid#">../CompilingSquid</ulink>. </para></listitem><listitem><para>If you are using FreeBSD, then it already has the DNS TTL patch built in. </para></listitem></itemizedlist><para>Let's say you have the following settings: </para><screen><![CDATA[positive_dns_ttl 1 hours
negative_dns_ttl 1 minutes]]></screen><para>When Squid looks up a name like <emphasis>www.squid-cache.org</emphasis>, it gets back an IP address like 204.144.128.89.  The address is cached for the next hour.  That means, when Squid needs to know the address for  <emphasis>www.squid-cache.org</emphasis> again, it uses the cached answer for the next hour.  After one hour, the cached information expires, and Squid makes a new query for the address of <emphasis>www.squid-cache.org</emphasis>. </para><para>If you have the DNS TTL patch, or are using internal lookups, then each hostname has its own TTL value, which was set by the domain name administrator.  You can see these values in the 'ipcache' cache manager page.  For example: </para><screen><![CDATA[ Hostname                      Flags lstref    TTL N
 www.squid-cache.org               C   73043  12784  1( 0)  204.144.128.89-OK
 www.ircache.net                   C   73812  10891  1( 0)   192.52.106.12-OK
 polygraph.ircache.net             C  241768 -181261  1( 0)   192.52.106.12-OK]]></screen><para>The TTL field shows how how many seconds until the entry expires. Negative values mean the entry is already expired, and will be refreshed upon next use. </para><para>The <ulink url="http://www.squid-cache.org/Doc/config/negative_dns_ttl#">negative_dns_ttl</ulink> directive specifies how long to cache failed DNS lookups. When Squid fails to resolve a hostname, you can be pretty sure that it is a real failure, and you are not likely to get a successful answer within a short time period.  Squid retries its lookups many times before declaring a lookup has failed. If you like, you can set <ulink url="http://www.squid-cache.org/Doc/config/negative_dns_ttl#">negative_dns_ttl</ulink> to zero. </para></section><section><title>What does ''swapin MD5 mismatch'' mean?</title><para>It means that Squid opened up a disk file to serve a cache hit, but it found that the stored object doesn't match what the user's request. Squid stores the MD5 digest of the URL at the start of each disk file. When the file is opened, Squid checks that the disk file MD5 matches the MD5 of the URL requested by the user.  If they don't match, the warning is printed and Squid forwards the request to the origin server. </para><para>You do not need to worry about this warning.  It means that Squid is automatically recovering from a corrupted cache directory. </para></section><section><title>What does ''failed to unpack swapfile meta data'' mean?</title><para>Each of Squid's disk cache files has a metadata section at the beginning. This header is used to store the URL MD5, some <code>StoreEntry</code> data, and more. When Squid opens a disk file for reading, it looks for the meta data header and unpacks it. </para><para>This warning means that Squid couln't unpack the meta data.  This is non-fatal bug, from which Squid can recover.  Perhaps the meta data was just missing, or perhaps the file got corrupted. </para><para>You do not need to worry about this warning.  It means that Squid is double-checking that the disk file matches what Squid thinks should be there, and the check failed.  Squid recovers and generates a cache miss in this case. </para></section><section><title>Why doesn't Squid make ''ident'' lookups in interception mode?</title><para>It is a side-effect of the way interception proxying works. </para><para>When Squid is configured for interception proxying, the operating system pretends that it is the origin server.  That means that the &quot;local&quot; socket address for intercepted TCP connections is really the origin server's IP address.  If you run <emphasis>netstat -n</emphasis> on your interception proxy, you'll see a lot of foreign IP addresses in the <emphasis>Local Address</emphasis> column. </para><para>When Squid wants to make an ident query, it creates a new TCP socket and <emphasis>binds</emphasis> the local endpoint to the same IP address as the local end of the client's TCP connection.  Since the local address isn't really local (its some far away origin server's IP address), the <emphasis>bind()</emphasis> system call fails.  Squid handles this as a failed ident lookup. </para><para><emphasis>So why bind in that way? If you know you are interception proxying, then why not bind the local endpoint to the host's (intranet) IP address? Why make the masses suffer needlessly?</emphasis> </para><para>Because thats just how ident works.   Please read  <ulink url="ftp://ftp.isi.edu/in-notes/rfc931.txt">RFC 931</ulink>, in particular the RESTRICTIONS section. </para></section><section><title>What are FTP passive connections?</title><para>by Colin Campbell </para><para>FTP uses two data streams, one for passing commands around, the other for moving data. The command channel is handled by the ftpd listening on port 21. </para><para>The data channel varies depending on whether you ask for passive ftp or not. When you request data in a non-passive environment, you client tells the server &quot;I am listening on &lt;ip-address&gt; &lt;port&gt;.&quot; The server then connects FROM port 20 to the ip address and port specified by your client. This requires your &quot;security device&quot; to permit any host outside from port 20 to any host inside on any port &gt; 1023. Somewhat of a hole. </para><para>In passive mode, when you request a data transfer, the server tells the client &quot;I am listening on &lt;ip address&gt; &lt;port&gt;.&quot; Your client then connects to the server on that IP and port and data flows. </para></section><section><title>When does Squid re-forward a client request?</title><para>When Squid forwards an HTTP request to the next hop (either a <ulink url="http://www.squid-cache.org/Doc/config/cache_peer#">cache_peer</ulink> or an origin server), things may go wrong. In some cases, Squid decides to re-forward the request. This section documents the associated Squid decision logic. Notes in <code>{curly braces}</code> are meant to help developers to correlate these comments with Squid sources. Non-developers should ignore those notes. </para><para><emphasis role="strong">Warning</emphasis>: Squid uses two somewhat different methods for making re-forwarding decisions. <code>{FwdState::checkRetry}</code> and <code>{FwdState::reforward}</code>. Unfortunately, there are many different cases when at least one of those methods might be called and method decision may be affected by the calling sequence (i.e. the transaction state). The logic documented below does not match the reality in some corner cases. If you find a serious discrepancy with the real life use case that you care about, please file a documentation bug report. </para><para>Squid does <emphasis role="strong">not</emphasis> try to re-forward a request if at least one of the following conditions is true: </para><itemizedlist><listitem><para>Squid is shutting down, although this is ignored by <code>{FwdState::reforward}</code>, one of the two decision making methods. </para></listitem><listitem><para>The number of forwarding attempts exceeded <ulink url="http://www.squid-cache.org/Doc/config/forward_max_tries#">forward_max_tries</ulink>. For example, if you set <ulink url="http://www.squid-cache.org/Doc/config/forward_max_tries#">forward_max_tries</ulink> to 1 (one), then no requests will be re-forwarded. </para></listitem><listitem><para>Squid successfully received a complete response. See below regarding the meaning of &quot;received&quot; in this context. <code>{!FwdState.self}</code> </para></listitem><listitem><para>The process of storing the response body (for the purpose of caching it or just for forwarding it to the client) was aborted. This may happen for numerous reasons usually dealing with some difficult-to-recover-from error conditions, possibly not even related to communication with the next hop. See below regarding the meaning of &quot;received&quot; in this context. <code>{EBIT_TEST(e-&gt;flags, ENTRY_ABORTED)}</code> and <code>{entry-&gt;store_status != STORE_PENDING}</code>. </para></listitem><listitem><para>Squid has not received the end of HTTP response headers but already generated some kind of internal error response. Note that if the response goes through a RESPMOD adaptation service, then &quot;received&quot; here means &quot;received after adaptation&quot; and not &quot;received from the next HTTP hop&quot;.  <code>{entry-&gt;store_status != STORE_PENDING}</code> and <code>{!entry-&gt;isEmpty}</code> in <code>{FwdState::checkRetry}</code>? </para></listitem><listitem><para>Squid discovers that the origin server speaks an unsupported protocol. <code>{flags.dont_retry}</code> set in <code>{FwdState::dispatch}</code>. </para></listitem><listitem><para>Squid detects a persistent connection race on a <emphasis>pinned</emphasis> connection. That is, Squid detects a pinned connection closure after sending [a part of] the request and before receiving anything from the server. Pinned connections are used for connection-based authentication and bumped SSL traffic. <code>{flags.dont_retry}</code> set in <code>{FwdState::fail}</code>. </para></listitem><listitem><para>The producer of the request body (either the client or a precache REQMOD adaptation service) has aborted. <code>{flags.dont_retry}</code> set in <code>{ServerStateData::handleRequestBodyProducerAborted}</code>. </para></listitem><listitem><para>HTTP response header size sent by the next hop exceeds <ulink url="http://www.squid-cache.org/Doc/config/reply_header_max_size#">reply_header_max_size</ulink>. <code>{flags.dont_retry}</code> set in <code>{HttpStateData::continueAfterParsingHeader}</code>. </para></listitem><listitem><para>The received response body size exceeds <ulink url="http://www.squid-cache.org/Doc/config/reply_body_max_size#">reply_body_max_size</ulink> configuration. Currently, this condition may only occur if precache RESPMOD adaptation is enabled for the response.  <code>{flags.dont_retry}</code> set in <code>{ServerStateData::sendBodyIsTooLargeError}</code>. </para></listitem><listitem><para>A precache RESPMOD adaptation service has aborted. <code>{flags.dont_retry}</code> set in <code>{ServerStateData::handleAdaptationAborted}</code>. </para></listitem><listitem><para>A precache RESPMOD adaptation service has blocked the response. <code>{flags.dont_retry}</code> set in <code>{ServerStateData::handleAdaptationBlocked}</code>. </para></listitem><listitem><para>Squid FTP code has started STOR data transfer to the origin server.<code>{flags.dont_retry}</code> set in <code>{FtpStateData::readStor}</code>. </para></listitem><listitem><para>Squid has consumed some of the <emphasis>request</emphasis> body while trying to send the request to the next hop. This may happen if the request body is larger that the maximum Squid request buffer size: Squid has to consume at least some of the request body bytes in order to receive (and forward) more body bytes. There may be other cases when Squid nibbles at the request body. <code>{request-&gt;bodyNibbled}</code>. </para></listitem><listitem><para>Squid has successfully established a connection but did not receive HTTP response headers and the request is not &quot;Safe&quot; or &quot;Idempotent&quot; as defined in RFC 2619 Section 9.1. <code>{flags.connected_okay &amp;&amp; !checkRetriable}</code>. </para></listitem><listitem><para>Squid has no alternative destinations to try. Please note that alternative destinations may include multiple next hop IP addresses and multiple peers. </para></listitem><listitem><para><ulink url="http://www.squid-cache.org/Doc/config/retry_on_error#">retry_on_error</ulink> is <emphasis>off</emphasis> and the received HTTP response status code is 403 (Forbidden), 500 (Internal Server Error), 501 (Not Implemented) or 503 (Service not available). </para></listitem><listitem><para>The received HTTP response status code is <emphasis>not</emphasis> one of the following codes: 403 (Forbidden), 500 (Internal Server Error), 501 (Not Implemented), 502 (Bad Gateway), 503 (Service not available), and 504 (Gateway Timeout). </para></listitem></itemizedlist><para>In other cases, Squid tries to re-forward the request. If the failure was caused by a persistent connection race, Squid retries using the same destination address. Otherwise, Squid goes to next origin server or peer address in the list of alternative destinations. </para><para>Please note that this section covers <emphasis>forwarding</emphasis> retries only. A transaction may fail before Squid tries to forward the request (e.g., an HTTP request itself may be malformed or denied by Squid) or after Squid is done receiving the response (e.g., the response may be denied by Squid). </para><para>This analysis is based primarily on <code>{FwdState::checkRetry}</code>, <code>{FwdState::reforward}</code>, and related forwarding source code. This text is based on Squid trunk revision 12993 dated 2013-08-29. Hard-coded logic may have changed since then. </para><!--rule (<hr>) is not applicable to DocBook--><para>Back to the <ulink url="https://wiki.squid-cache.org/SquidFaq/InnerWorkings/SquidFaq#">SquidFaq</ulink> </para></section></article>