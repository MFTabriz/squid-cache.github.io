<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>Features/MemPools</title><revhistory><revision><revnumber>4</revnumber><date>2017-01-09 08:55:20</date><authorinitials>AmosJeffries</authorinitials><revremark>merge text from Features/MemPoolsImprovements, and remove obsolete API docs (reference doxygen page instead).</revremark></revision><revision><revnumber>3</revnumber><date>2017-01-09 07:57:14</date><authorinitials>AmosJeffries</authorinitials><revremark>this is a feature, albeit a code feature for developers</revremark></revision><revision><revnumber>2</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 09:06:07</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>MemPools</title><itemizedlist><listitem><para><emphasis role="strong">Goal</emphasis>: Reduce memory fragmentation and provide detailed statistics </para></listitem><listitem><para><emphasis role="strong">Status</emphasis>: Done. </para></listitem><listitem><para><emphasis role="strong">Version</emphasis>: 2.0 </para></listitem></itemizedlist><itemizedlist><listitem><para><emphasis role="strong">More</emphasis>: </para><itemizedlist><listitem override="none"><para><ulink url="http://www.squid-cache.org/Doc/code/namespaceMem.html"/> </para></listitem><listitem override="none"><para><ulink url="http://www.squid-cache.org/Doc/code/group__MemPoolsAPI.html"/> </para></listitem></itemizedlist></listitem></itemizedlist></section><section><title>Details</title><para>MemPools is a set of pooled memory allocators running on top of malloc(). It's purpose is to reduce memory fragmentation and provide detailed statistics on memory consumption. </para><para>Preferably all memory allocations in Squid should be done using MemPools or one of the types built on top of it (i.e. cbdata). </para><para>MemPools are currently half-migrated towards proper C++, having been converted from C functions to static members of a C++ class. This leaves some issues open, such as initialization order. </para><para>Also, with the current advancements in malloc implementations one may want to link Squid against an alternaive malloc implementation: </para><itemizedlist><listitem><para><ulink url="http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html">Google tcmalloc</ulink> </para></listitem><listitem><para><ulink url="http://www.malloc.de/en/">Wolfram Gloger's ptmalloc3</ulink> </para></listitem></itemizedlist><section><title>Public API</title><para>See <ulink url="http://www.squid-cache.org/Doc/code/namespaceMem.html"/> and <ulink url="http://www.squid-cache.org/Doc/code/group__MemPoolsAPI.html"/> for the public API definitions. </para><section><title>MEMPROXY_CLASS Macro</title><para>This macro defines pooled <emphasis>new</emphasis> and <emphasis>delete</emphasis> operators for the class in which it is used. It should be your first choice of how to integrate a C++ class in Squid for dynamic allocation. Other API mechanisms are possible, but are designed for special use cases. </para><para>For easy reading and code maintenance it should be placed at the top of the class definition in the <emphasis>private</emphasis> area before any other API details and followed by an empty line then the 'public:' section definition. </para><screen><![CDATA[class Foo
{
    MEMPROXY_CLASS(Foo);
]]><![CDATA[
public:
   ...
};]]></screen><para>Classes which use the CBDATA_CLASS macro <emphasis role="strong">must not</emphasis> also use MEMPROXY_CLASS. That includes use in the direct line of inheritence within a class hierarchy. </para><!--rule (<hr>) is not applicable to DocBook--><para> <ulink url="https://wiki.squid-cache.org/Features/MemPools/CategoryFeature#">CategoryFeature</ulink> </para></section></section></section></article>