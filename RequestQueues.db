<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>RequestQueues</title><revhistory><revision><revnumber>3</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>2</revnumber><date>2007-03-17 11:13:29</date><authorinitials>AdrianChadd</authorinitials></revision><revision><revnumber>1</revnumber><date>2007-03-17 10:59:23</date><authorinitials>AdrianChadd</authorinitials></revision></revhistory></articleinfo><section><title>Request Queues</title><section><title>wha?</title><para>One of the things that has popped out of the storework branch is a need to bring sanity to how requests and replies are handled. One of the ideas I've had (which sounds like my clientlet/servlet from ~2000) is the idea of message and request queues. </para><para>In essence, instead of everything being completely callback driven the request/reply/data exchange is turned into something resembling queued messages and requests. A &quot;client&quot; and &quot;server&quot; are just endpoints of the request and can be chained with different processing layers to achieve Robert's clientstreams API. </para></section><section><title>How's it work ?</title><para>This is very C focused. Translating the ideas into C++ class abstractions wouldn't take too much effort. </para><section><title>Request</title><para>A request is a queueable entity. It has two endpoints - a client (ie, connecting/talking TO a server) and a server (ie, accepting/talking to a client). These are abstract message queues and callbacks (or for C++, class implementations) which implement the hard lifting. The idea here is to abstract out the notion of a network client and server; instead allowing servers to be local (eg, a cache) and clients to be local (eg, ESI processing.) </para><para>Requests are created by a server, representing a HTTP request. It doesn't -have- to just be a HTTP request but we're a HTTP proxy at the moment, so HTTP it is. It contains all the pertinent information from the server (method/url/version, client credentials, authentication credentials, etc). The request is queued into the &quot;New HTTP request&quot; queue. </para><para>A queue runner will scan the pending request queue and decide what to do. In the case of a proxy it'll want to find or create a client to satisfy the request. Once the request has been satisified somehow it'll be attached to a client, forming the other end of the data pipeline. The request moves to the &quot;In progress HTTP request&quot; queue and begins data exchange. The request is destroyed once both parties - client and server - have disassociated themselves from the request. </para></section><section><title>Messages</title><para>The general exchange should involve simple messages. There's a handful of message types: </para><itemizedlist><listitem><para>A &quot;request&quot; message type - method, URL, version </para></listitem><listitem><para>A &quot;reply&quot; message type - status </para></listitem><listitem><para>A &quot;headers&quot; message type </para></listitem><listitem><para>A &quot;request body chunk&quot; message type </para></listitem><listitem><para>A &quot;reply body chunk&quot; message type </para></listitem><listitem><para>A &quot;status&quot; message type - eg, REQUEST_OK, REPLY_OK, HEADERS_OK, REQBODY_OK, REPBODY_OK, REQBODY_EOF, REPBODY_EOF, REQBODY_WANTMORE, REPBODY_WANTMORE </para></listitem></itemizedlist><para>The request message type probably isn't required - the whole request information should be a part of the HTTP request itself and so is available for the client implementation when its asked to handle the request. </para><para>An example GET dataflow: </para><itemizedlist><listitem><para>client queues HTTP request </para></listitem><listitem><para>queue implementation(s) eventually associate the request with a server </para></listitem><listitem><para>server sends back a &quot;I'm here, welcome, lets do this&quot; message </para></listitem><listitem><para>client sends &quot;OK, lets do this&quot; message </para></listitem><listitem><para>server sends client a &quot;reply&quot; + &quot;headers&quot; + &quot;reply body chunk&quot; message </para></listitem><listitem><para>client sends server a &quot;reply ok&quot; + &quot;headers ok&quot; + &quot;reply body chunk ok&quot; + &quot;want more&quot; message </para></listitem><listitem><para>server sends a &quot;reply body chunk&quot; + &quot;reply body EOF&quot; message </para></listitem><listitem><para>client sends server a &quot;reply body OK&quot; + &quot;EOF OK&quot; + &quot;request completed&quot; message </para></listitem><listitem><para>server disassociates itself from the request </para></listitem><listitem><para>client disassociates itself from the request </para></listitem><listitem><para>request is dequeued </para></listitem></itemizedlist><para>An example POST dataflow (or anything with a request body) : </para><itemizedlist><listitem><para>client queues HTTP request </para></listitem><listitem><para>queue implementation(s) eventually associate the request with a server </para></listitem><listitem><para>server sends back a &quot;I'm here, welcome, lets do this&quot; message </para></listitem><listitem><para>client sends back &quot;OK, lets do this&quot; + &quot;request body chunk&quot; message </para></listitem><listitem><para>server sends back &quot;request body ok&quot; + &quot;want more&quot; message </para></listitem><listitem><para>client sends back &quot;request body chunk&quot; + &quot;request body EOF&quot; message </para></listitem><listitem><para>server sends back &quot;request body OK&quot; + &quot;request body EOF OK&quot; message </para></listitem><listitem><para>client is at this point waiting for a status message </para></listitem><listitem><para>server sends back &quot;reply&quot; + &quot;headers&quot; + &quot;reply body chunk&quot; + &quot;reply body EOF&quot; message </para></listitem><listitem><para>client sends back &quot;reply ok&quot; + &quot;headers OK&quot; + &quot;reply body chunk OK&quot; + &quot;reply bdy EOF OK&quot; + &quot;request completed&quot; message </para></listitem><listitem><para>server disassociates itself from the request </para></listitem><listitem><para>client disassociates itself from the request </para></listitem><listitem><para>request is dequeued </para></listitem></itemizedlist></section></section><section><title>Things to keep in mind</title><itemizedlist><listitem><para>It should be lightweight for small objects - try to include as much request body as possible in the first message, and include as much reply body with the reply status as much as possible. </para></listitem><listitem><para>Note that this is just the request - the client and server connections have to implement their own state engines to implement persistence, etc. </para></listitem><listitem><para>I haven't covered anything like pinned connection support but it wouldn't be hard to support (just have a &quot;this is pinned to this connection&quot; flag like Squid has.) </para></listitem></itemizedlist></section></section></article>