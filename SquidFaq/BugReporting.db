<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>SquidFaq/BugReporting</title><revhistory><revision><revnumber>20</revnumber><date>2018-11-06 17:16:47</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented how to get a stack trace from a running Squid without suspending the Squid process</revremark></revision><revision><revnumber>19</revnumber><date>2018-03-21 16:04:14</date><authorinitials>AmosJeffries</authorinitials><revremark>add better gdb signal handling and remove obsolete -D parameter from GDB scripts</revremark></revision><revision><revnumber>18</revnumber><date>2016-12-17 21:43:10</date><authorinitials>GarriDjavadyan</authorinitials><revremark>Added notes related to coredump generation and location in RHEL6 and systemd environments.</revremark></revision><revision><revnumber>17</revnumber><date>2016-10-27 10:45:37</date><authorinitials>GarriDjavadyan</authorinitials></revision><revision><revnumber>16</revnumber><date>2016-10-27 10:41:02</date><authorinitials>GarriDjavadyan</authorinitials></revision><revision><revnumber>15</revnumber><date>2016-10-27 10:22:46</date><authorinitials>GarriDjavadyan</authorinitials></revision><revision><revnumber>14</revnumber><date>2016-07-24 19:37:01</date><authorinitials>AlexRousskov</authorinitials><revremark>Ignore last premature commit (a FF bug). Hopefully restored old inconsistent headings to preserve old links. Fixed new section title spelling.</revremark></revision><revision><revnumber>13</revnumber><date>2016-07-24 19:25:43</date><authorinitials>AlexRousskov</authorinitials><revremark>Rest</revremark></revision><revision><revnumber>12</revnumber><date>2016-07-23 08:24:39</date><authorinitials>AmosJeffries</authorinitials><revremark>mention squidclient in preferene to third-party testing tools</revremark></revision><revision><revnumber>11</revnumber><date>2016-07-22 20:34:43</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented how to debug a single transaction. Polished heading capitalization.</revremark></revision><revision><revnumber>10</revnumber><date>2016-07-22 20:17:06</date><authorinitials>AlexRousskov</authorinitials><revremark>Fixed either outdated or simply bogus description of Squid debugging controls.</revremark></revision><revision><revnumber>9</revnumber><date>2014-02-12 09:23:22</date><authorinitials>AmosJeffries</authorinitials></revision><revision><revnumber>8</revnumber><date>2014-02-06 22:58:10</date><authorinitials>NikiGorchilov</authorinitials></revision><revision><revnumber>7</revnumber><date>2013-12-20 16:04:49</date><authorinitials>AlexRousskov</authorinitials><revremark>Added &quot;bt full&quot; as the preferred gdb backtrace extraction command.</revremark></revision><revision><revnumber>6</revnumber><date>2012-02-08 11:59:26</date><authorinitials>AmosJeffries</authorinitials><revremark>add section about attach detatch to a running worker.</revremark></revision><revision><revnumber>5</revnumber><date>2010-09-16 09:53:54</date><authorinitials>AmosJeffries</authorinitials><revremark>add sub-titiles to highlight the gdb tricks</revremark></revision><revision><revnumber>4</revnumber><date>2010-09-16 09:47:34</date><authorinitials>AmosJeffries</authorinitials><revremark>update gdb scripts to allow ignoring of -k shutdown and rotate signals.</revremark></revision><revision><revnumber>3</revnumber><date>2009-12-04 23:52:03</date><authorinitials>AmosJeffries</authorinitials><revremark>note about the non-symbol traces.</revremark></revision><revision><revnumber>2</revnumber><date>2009-09-22 11:45:34</date><authorinitials>AmosJeffries</authorinitials><revremark>tweak.</revremark></revision><revision><revnumber>1</revnumber><date>2009-09-22 11:44:50</date><authorinitials>AmosJeffries</authorinitials><revremark>Pull out of the troubleshooting FAQ page. This will be easier for people to find the specific reporting info.</revremark></revision></revhistory></articleinfo><section><title>Sending Bug Reports to the Squid Team</title><para>Bug reports for Squid should be registered in our <ulink url="http://bugs.squid-cache.org/">bug database</ulink>. </para><para>Any bug report must include </para><itemizedlist><listitem><para>The Squid release version </para></listitem><listitem><para>Your Operating System type and version </para></listitem><listitem><para>A clear description of the bug symptoms. </para></listitem><listitem><para>If your Squid crashes the report must include a coredumps stack trace as described below </para></listitem></itemizedlist><para>Please note that: </para><itemizedlist><listitem><para>bug reports are only processed if they can be reproduced or identified in the current STABLE or development versions of Squid. </para></listitem><listitem><para>If you are running an older version of Squid the first response will be to ask you to upgrade unless the developer who looks at your bug report immediately can identify that the bug also exists in the current versions. </para></listitem><listitem><para>It should also be noted that any patches provided by the Squid developer team will be to the current STABLE version even if you run an older version. </para></listitem></itemizedlist><section><title>crashes and core dumps</title><para>There are two conditions under which squid will exit abnormally and generate a coredump.  First, a SIGSEGV or SIGBUS signal will cause Squid to exit and dump core.  Second, many functions include consistency checks.  If one of those checks fail, Squid calls abort() to generate a core dump. </para><para>If you have a core dump file, then use gdb to extract a stack trace from the core using a &quot;bt full&quot; command (if supported) or a &quot;backtrace&quot; command (can be typed as &quot;bt&quot; and is always supported, but gives less information): </para><screen><![CDATA[% gdb /usr/local/squid/sbin/squid core
gdb> backtrace]]></screen><para>Many people report that Squid doesn't leave a coredump anywhere.  This may be due to one of the following reasons: </para><itemizedlist><listitem><para>Resource Limits </para><itemizedlist><listitem override="none"><para>The shell has limits on the size of a coredump file.  You may need to increase the limit using ulimit or a similar command (see below) </para></listitem></itemizedlist></listitem><listitem><para>Write Permissions </para><itemizedlist><listitem override="none"><para>The system user account for Squid (i.e. proxy, nobody, etc) needs write permissions to <link linkend="Coredump_Location">coredump destination directory</link> </para></listitem></itemizedlist></listitem><listitem><para>sysctl options </para><itemizedlist><listitem override="none"><para>On FreeBSD, you won't get a coredump from programs that call setuid() and/or setgid() (like Squid sometimes does) unless you enable this option: </para></listitem></itemizedlist></listitem></itemizedlist><screen><![CDATA[# sysctl -w kern.sugid_coredump=1]]></screen><itemizedlist><listitem><para>No debugging symbols </para><itemizedlist><listitem override="none"><para>The Squid binary must have debugging symbols in order to get a meaningful coredump. The debugging traces we need look something like this: </para></listitem></itemizedlist></listitem></itemizedlist><screen><![CDATA[Core was generated by `(squid) -D'.
Program terminated with signal 6, Aborted.
]]><![CDATA[
(gdb) bt
#0  0x006ad7a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
#1  0x006ed7a5 in raise () from /lib/tls/libc.so.6
#2  0x006ef209 in abort () from /lib/tls/libc.so.6
#3  0x0806b987 in xassert (msg=Could not find the frame base for "xassert".
) at debug.c:514
#4  0x0808170b in httpBuildRequestHeader (request=0x10791f40,
orig_request=0x10791f40, entry=0xfc6ba30, hdr_out=0xbfed04f0, flags=
      {proxying = 0, keepalive = 1, only_if_cached = 0, keepalive_broken = 0,
abuse_detected = 0, request_sent = 0, front_end_https = 0, originpeer = 0}) at
http.c:1195
...]]></screen><para>if you find the trace contains a lot of lines with <emphasis role="strong">??</emphasis> and mentions no symbols found. It is usually useless and you will need to run a version of Squid where the debug symbols have not been removed. </para><itemizedlist><listitem><para>Threads and Linux </para><itemizedlist><listitem override="none"><para>On Linux, threaded applications do not generate core dumps.  When you use the aufs cache_dir type, it uses threads and you can't get a coredump. </para></listitem></itemizedlist></listitem><listitem><para>It did leave a coredump file, you just can't find it. </para></listitem></itemizedlist></section><section><title>Resource Limits</title><para>These limits can usually be changed in shell scripts.  The command to change the resource limits is usually either <emphasis>ulimit</emphasis> or <emphasis>limits</emphasis>.  Sometimes it is a shell-builtin function, and sometimes it is a regular program.  Also note that you can set resource limits in the <emphasis>/etc/login.conf</emphasis> file on FreeBSD and maybe other systems. </para><para>To change the coredumpsize limit you might use a command like: </para><screen><![CDATA[limits coredump unlimited]]></screen><para>If Squid binary is started by RHEL6/CentOS6 init script, you may need to set variable <emphasis>DAEMON_COREFILE_LIMIT=&quot;unlimited&quot;</emphasis> in the init script or the script's configuration file (usually /etc/sysconfig/squid). </para><para>For systemd units the equivalent option is <emphasis>LimitCORE=infinity</emphasis>. </para></section><section><title>Debugging Symbols</title><para>To see if your Squid binary has debugging symbols, use this command: </para><screen><![CDATA[% nm /usr/local/squid/bin/squid | head]]></screen><para>The binary has debugging symbols if you see gobbledegook like this: </para><screen><![CDATA[0812abec B AS_tree_head
080a7540 D AclMatchedName
080a73fc D ActionTable
080908a4 r B_BYTES_STR
080908bc r B_GBYTES_STR
080908ac r B_KBYTES_STR
080908b4 r B_MBYTES_STR
080a7550 D Biggest_FD
08097c0c R CacheDigestHashFuncCount
08098f00 r CcAttrs]]></screen><para>There are no debugging symbols if you see this instead: </para><screen><![CDATA[/usr/local/squid/bin/squid: no symbols]]></screen><para>Debugging symbols may have been removed by your install program.  If you look at the squid binary from the source directory, then it might have the debugging symbols. </para></section><section><title>Coredump Location</title><para>The core dump file will be left in one of the following locations: </para><orderedlist numeration="arabic"><listitem><para>The <emphasis>coredump_dir</emphasis> directory, if you set that option. </para></listitem><listitem><para>The first <emphasis>cache_dir</emphasis> directory if you have used the <emphasis>cache_effective_user</emphasis> option. </para></listitem><listitem><para>The current directory when Squid was started </para></listitem></orderedlist><para>Recent versions of Squid report their current directory after starting, so look there first: </para><screen><![CDATA[2000/03/14 00:12:36| Set Current Directory to /usr/local/squid/cache]]></screen><para>If you cannot find a core file, then either Squid does not have permission to write in its current directory, or perhaps your shell limits are preventing the core file from being written. </para><para>Often you can get a coredump if you run Squid from the command line like this (csh shells and clones): </para><screen><![CDATA[% limit core un
% /usr/local/squid/bin/squid -NCd1]]></screen><para>Once you have located the core dump file, use a debugger such as <emphasis>dbx</emphasis> or <emphasis>gdb</emphasis> to generate a stack trace: </para><screen><![CDATA[% gdb /usr/local/squid/sbin/squid core
gdb> backtrace]]></screen><para>If possible, you might keep the coredump file around for a day or two.  It is often helpful if we can ask you to send additional debugger output, such as the contents of some variables. But please note that a core file is only useful if paired with the exact same binary as generated the corefile. If you recompile Squid then any coredumps from previous versions will be useless unless you have saved the corresponding Squid binaries, and any attempts to analyze such coredumps will most certainly give misleading information about the cause to the crash. </para><para>In some environments, coredump is handled by dedicated utility for management purposes. For example, in RHEL6/CentOS6 environment it may be <emphasis>abrtd</emphasis> with <emphasis>  abrt-addon-ccpp</emphasis> (man abrtd, man abrt-install-ccpp-hook). In systemd environments it is <emphasis>systemd-coredump</emphasis> (man systemd-coredump). You can check it by reading <emphasis>/proc/sys/kernel/core_pattern</emphasis> (man core): </para><screen><![CDATA[# cat /proc/sys/kernel/core_pattern 
|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e]]></screen><para>The core_pattern for systemd-coredump: </para><screen><![CDATA[# cat /proc/sys/kernel/core_pattern 
|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %e]]></screen><para>Therefore, you should be familiar with the handlers to control coredump generation and location. Or you can disable the handler and use usual methods to handle coredumps if a server is dedicated for Squid. For example, you can use following methods to disable aforementioned handlers: </para><screen><![CDATA[# chkconfig abrt-ccpp off
# service abrt-ccpp stop
# cat /proc/sys/kernel/core_pattern 
core]]></screen><para>To disable systemd-coredump: </para><screen><![CDATA[# echo kernel.core_pattern=core > /etc/sysctl.d/50-coredump.conf
# /usr/lib/systemd/systemd-sysctl --prefix kernel.core_pattern
# cat /proc/sys/kernel/core_pattern 
core]]></screen></section><section><title>Using gdb debugger on Squid</title><para>If you CANNOT get Squid to leave a core file for you then one of the following approaches can be used </para><para>First alternative is to start Squid under the contol of GDB </para><screen><![CDATA[% gdb /path/to/squid
handle SIGPIPE pass nostop noprint
handle SIGTERM pass nostop noprint
handle SIGUSR1 pass nostop noprint
handle SIGHUP  pass
handle SIGKILL pass
handle SIGSEGV stop
handle SIGABRT stop
run -NYCX
[wait for crash]
backtrace
quit]]></screen></section><section><title>Using gdb debugger on a live proxy (with minimal downtime)</title><para>The drawback from the above is that it isn't really suitable to run on a production system as Squid then won't restart automatically if it crashes. The good news is that it is fully possible to automate the process above to automatically get the stack trace and then restart Squid. Here is a short automated script that should work: </para><screen><![CDATA[trap "rm -f $$.gdb" 0
cat <<EOF >$$.gdb
handle SIGPIPE pass nostop noprint
handle SIGTERM pass nostop noprint
handle SIGUSR1 pass nostop noprint
handle SIGHUP  pass
handle SIGKILL pass
handle SIGSEGV stop
handle SIGABRT stop
run -NYCd3
backtrace
quit
EOF
while sleep 2; do
  gdb -x $$.gdb /path/to/squid 2>&1 | tee -a squid.out
done]]></screen><para>Other options if the above cannot be done is to: </para><orderedlist numeration="arabic"><listitem><para>Build Squid with the --enable-stacktraces option, if support exists for your OS (exists for Linux glibc on Intel, and Solaris with some extra libraries which seems rather impossible to find these days..) </para></listitem><listitem><para>Run Squid using the &quot;catchsegv&quot; tool. (Linux glibc Intel) </para><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> these approaches do not by far provide as much details as using gdb. </para></listitem></orderedlist></section><section><title>Attaching gdb debugger to and already running Squid</title><para>First locate the PID number for the particular Squid worker you are wanting to debug. </para><screen><![CDATA[% gdb /path/to/squid
handle SIGPIPE pass nostop noprint
handle SIGTERM pass nostop noprint
handle SIGUSR1 pass nostop noprint
handle SIGHUP  pass
handle SIGKILL pass
handle SIGSEGV stop
handle SIGABRT stop
]]><![CDATA[
attach [worker PID]
[wait for crash]
backtrace
detach
quit]]></screen></section><section><title>Getting the current stack of a live proxy (without downtime)</title><para>The following trick may be useful if you suspect that your Squid is stuck in a busy loop, and/or you want to know what your Squid is doing &quot;right now&quot;, but you do not want to suspect the Squid process. </para><orderedlist numeration="arabic"><listitem><para>To dump the current stack using gdb: </para><screen><![CDATA[sudo gdb -n -batch -ex backtrace -pid <PID>]]></screen><para>You may not need/want the <code>-n</code> (i.e. do not load gdb initialization files) option. Using <code>'backtrace full'</code> instead of <code>backtrace</code> will give even more info but might be a tad slower. </para></listitem><listitem><para>To dump the current stack using pstack(1): </para><screen><![CDATA[sudo pstack <PID>]]></screen></listitem><listitem><para>To quickly check whether Squid is waiting for a system call: </para><screen><![CDATA[sudo cat /proc/<PID>/stack]]></screen><para>This approach does not show Squid functions leading to a system call. </para></listitem></orderedlist><para>In the above commands, <code>&lt;PID&gt;</code> stands for a process ID of the Squid process you want to debug. It is usually a worker process, but it could also be another kid process or even the master process. </para></section></section><section><title>Debugging Squid</title><para>If you believe you have found a non-fatal bug (such as incorrect HTTP processing) please send us a section of your cache.log with debugging to demonstrate the problem.  The cache.log file can become very large, so alternatively, you may want to copy it to an FTP or HTTP server where we can download it. </para><para>Once you have the debugging captured to <emphasis>cache.log</emphasis>, take a look at it yourself and see if you can make sense of the behavior which you see.  If not, please feel free to send your debugging output to the <emphasis>squid-users</emphasis> or <emphasis>squid-bugs</emphasis> mailing lists. </para><section><title>Debugging a single transaction</title><para>Unfortunately, it is not yet possible to debug a single transaction, but the following procedure minimizes logging noise and may help developers to pinpoint the problem: </para><orderedlist numeration="arabic"><listitem><para>Locate your Squid log file or equivalent. In this example, we will call it <emphasis>cache.log</emphasis>. </para></listitem><listitem><para>Enable detailed (level-7) or full (level-9) debugging. See the sections below for details. </para></listitem><listitem><para>Start Squid if necessary. </para></listitem><listitem><para>Run &quot;tail -f cache.log &gt; partial-cache.log&quot;. This will start appending new debugging to the <emphasis>partial-cache.log</emphasis> file. </para></listitem><listitem><para>Reproduce the failing transaction, using a single request if possible. Please note that reloading a page in a browser often sends dozens or even hundreds of requests to Squid. Ideally, use <ulink url="https://wiki.squid-cache.org/SquidFaq/BugReporting/SquidClientTool#">squidclient</ulink>, wget, curl, or another &quot;single-request&quot; tool when possible. </para></listitem><listitem><para>Kill the &quot;tail&quot; command above. </para></listitem><listitem><para>Share the resulting partial-cache.log, compressing it if needed. Please note that it may contain sensitive information such as passwords. </para></listitem></orderedlist></section><section><title>Detailed Debug Output</title><para>It is easy to get level-7 debugging on a running squid process: </para><screen><![CDATA[squid -k debug]]></screen><para>The above command sends the running Squid version a signal which causes many (but not all) debug() statements in the source code to write to the <emphasis>cache.log</emphasis> file or equivalent. Repeating the same command restores the previous debugging level. </para><para>To debug what happens before &quot;squid -k debug&quot; starts working, see the <emphasis role="strong">-X</emphasis> command line option discussed below. </para></section><section><title>Full Debug Output</title><para>To enable full or level-9 debugging (i.e., to force every debugging statement in Squid to emit some output when reached), you have two options: </para><orderedlist numeration="arabic"><listitem><para>Set debug_options in squid.conf to ALL,9. Doing so will debug what happens after the configuration file is parsed. This is sufficient to triage most runtime problems. </para></listitem><listitem><para>Start Squid with the <emphasis role="strong">-X</emphasis> command line option. Doing so will debug what happens both before and after debug_options in the configuration file are parsed. </para></listitem></orderedlist><para>When started with -X (or -d) command-line option, before Squid opens cache.log or starts sending debugging to a logging daemon, Squid writes debugging lines to the standard error stream (stderr). When not started with those command-line options, very little or no debugging is produced until after Squid parses the configuration file and starts honoring the settings configured there. </para><para>Unfortunately, it is impossible enable full debugging on a running Squid process, but &quot;squid -k debug&quot; discussed above will enable level-7 debugging. </para></section><section><title>Debug Sections</title><para>To enable selective debugging (e.g. for one source file only), you need to edit <emphasis role="strong">squid.conf</emphasis> and add to the <emphasis role="strong">debug_options</emphasis> line. Every Squid source file is assigned a debugging <emphasis role="strong">section</emphasis>. The debugging section assignments can be found by looking at the top of individual source files, by reading the file <emphasis>debug-sections.txt</emphasis>, or looking at <ulink url="https://wiki.squid-cache.org/SquidFaq/BugReporting/KnowledgeBase/DebugSections#">KnowledgeBase/DebugSections</ulink>. </para></section><section><title>Debug Levels</title><para>You also specify the debugging <emphasis>level</emphasis> to control the amount of debugging.  Higher levels result in more debugging messages. For example, to enable full debugging of Access Control functions, you would use: </para><screen><![CDATA[debug_options 28,9]]></screen><para>Then you have to restart or reconfigure Squid. </para></section></section><section><title>Capturing packets</title><para>Sometimes, after inspecting coredump traces and debug output, developers may ask you to collect packets on both sides of Squid (Squid-to-origin and Squid-to-client). You can use powerful tool <emphasis role="strong">tcpdump</emphasis> to accomplish the operation. Below are presented some common examples and methods. </para><section><title>Collecting packets on intercepting proxy</title><para>In standard/common configuration, intercepting proxy has two network interfaces. One facing the Internet and second one facing the local network. So, to capture Squid-to-origin transactions you have to attach tcpdump to WAN interface and consequently to LAN interface for Squid-to-client transactions. You have to be in tcpdump group or be a root user to capture traffic on network interfaces. </para><para>Syntax: </para><screen><![CDATA[tcpdump -s 0 -i $nic -w /path/to/dump.pcap port $port and host $origin_ip [and host $client_ip]]]></screen><para>where <emphasis role="strong">$nic</emphasis> is WAN or LAN network interface, <emphasis role="strong">$port</emphasis> is intercepted port, <emphasis role="strong">$origin_ip</emphasis> is origin server IP, <emphasis role="strong">$client_ip</emphasis> is client IP in local network. The section 'and host $client_ip' applicable only for Squid-to-client transactions on NAT proxies. TProxy interception proxies can use the section for both transaction types. The argument <emphasis role="strong">-s 0</emphasis> required to instruct tcpdump to save full packet, <emphasis role="strong">-w</emphasis> specifies dump location. </para><para>For example, to capture Squid-to-origin transaction on NAT proxy: </para><screen><![CDATA[tcpdump -s 0 -i eth1 -w /tmp/squid-to-example.com.pcap port 80 and host 10.11.12.13]]></screen><para>To capture Squid-to-origin transaction on TProxy proxy: </para><screen><![CDATA[tcpdump -s 0 -i eth1 -w /tmp/squid-to-example.com.pcap port 80 and host 10.11.12.13 and host 172.16.1.100]]></screen><para>To capture Squid-to-client transaction: </para><screen><![CDATA[tcpdump -s 0 -i eth0 -w /tmp/squid-to-client100.pcap port 80 and host 10.11.12.13 and host 192.168.1.100]]></screen><para>To limit amount of collected traffic, immediately after you started both tcpdump instances, initiate the problem HTTP request. After you have got desired result, immediately stop both tcpdump instances. </para></section><section><title>Collecting packets on explicit proxy</title><para>The main difference between the methods is that Squid-to-client communication is explicit between Squid's IP/proxy port and client IP. So the syntax is: </para><screen><![CDATA[tcpdump -s 0 -i $nic -w /path/to/dump.pcap port $proxy_port and host $proxy_ip and host $client_ip]]></screen><para>where <emphasis role="strong">$proxy_port</emphasis> and <emphasis role="strong">$proxy_ip</emphasis> are values used by user agents (e.g. browsers) to access Squid. For example: </para><screen><![CDATA[tcpdump -s 0 -i eth0 -w /tmp/squid-to-client100.pcap port 3128 and host 192.168.1.1 and host 192.168.1.100]]></screen><para>Please note, that the capture would include all traffic to proxy server from the client. So try to limit the amount of active HTTP sessions on the client while capturing the traffic. </para></section><section><title>Collecting packets leading to Squid's crash</title><para>Sometimes Squid may crash due to the processing of packets to/from known destination, so we have to capture the problem traffic for analysis. To do so you have an option to capture the traffic for long time until you encounter a crash. As packet dump can easily become very large for that operation, so it is better to enable dump file rotation. For example: </para><screen><![CDATA[tcpdump -s 0 -i eth0 -G 300 -w /tmp/squid-to-client100-%Y-%m-%d_%H:%M:%S.pcap port 3128 and host 192.168.1.1 and host 192.168.1.100]]></screen><para>where <emphasis role="strong">-G</emphasis> specifies rotation interval in seconds, and the flexible string like <emphasis role="strong">%Y-%m-%d_%H:%M:%S</emphasis> in filename exposes to date (man strftime) when the rotation occurred. </para><para>In above example, tcpdump will rotate the dump file every 5 minutes. Once you have found that Squid crashed and got exact time of the failure, you can easily find interesting 5-minutes part of the packet dump. The target directory for the dumps should be big enough to accommodate continuous capture. If tcpdump drops its privileges to ordinary user (usually tcpdump), the user should have write access to target directory. </para><para>If you have size-limited capture storage, you can use rotating buffer option of tcpdump. It allows to reserve fixed storage size for captures. For example: </para><screen><![CDATA[tcpdump -s 0 -i eth1 -w /tmp/squid-to-example.com.pcap -W 10 -C 100 port 80 and host 10.11.12.13]]></screen><para>where <emphasis role="strong">-W</emphasis> specifies maximum number of dump files and <emphasis role="strong">-C</emphasis> specifies maximum size in (MB) for a dump file. </para><para>In the above example, tcpdump will rotate a dump file and append suffix to the filename when it reaches 100MB. It will overwrite the oldest dump file when it reaches configured maximum number of the files. In this configuration the maximum capture storage size will be 1GB. The drawback of the method, is that you have to periodically monitor for Squid's activity and stop the capture as soon as possible when you detect an assertion. Otherwise, the interesting file dump would be overwritten. </para><!--rule (<hr>) is not applicable to DocBook--><para>Back to the <ulink url="https://wiki.squid-cache.org/SquidFaq/BugReporting/SquidFaq#">SquidFaq</ulink> </para></section></section></article>