<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>RequestUseCases</title><revhistory><revision><revnumber>9</revnumber><date>2008-05-18 19:38:56</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>8</revnumber><date>2007-03-02 17:16:53</date><authorinitials>kinkie</authorinitials><revremark>Fixed Markup</revremark></revision><revision><revnumber>7</revnumber><date>2006-10-03 12:41:10</date><authorinitials>rpivato</authorinitials><revremark>corrected typing mistake</revremark></revision><revision><revnumber>6</revnumber><date>2006-09-02 22:35:24</date><authorinitials>RobertCollins</authorinitials><revremark>redraft</revremark></revision><revision><revnumber>5</revnumber><date>2006-09-02 11:48:32</date><authorinitials>RobertCollins</authorinitials><revremark>better object names</revremark></revision><revision><revnumber>4</revnumber><date>2006-09-02 11:29:09</date><authorinitials>RobertCollins</authorinitials><revremark>make reference types clearer</revremark></revision><revision><revnumber>3</revnumber><date>2006-09-02 10:37:58</date><authorinitials>RobertCollins</authorinitials><revremark>formatting</revremark></revision><revision><revnumber>2</revnumber><date>2006-09-02 10:37:10</date><authorinitials>RobertCollins</authorinitials><revremark>wheee</revremark></revision><revision><revnumber>1</revnumber><date>2006-09-02 09:28:07</date><authorinitials>RobertCollins</authorinitials><revremark>start notes, DRAFT do not read or thou shalt go insane</revremark></revision></revhistory></articleinfo><para>This is an attempt to document how the various parts of squid <emphasis role="strong">should</emphasis> interact for a number of use cases. </para><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> Currently draft, read in fear for your mind </para><section><title>Guiding principles</title><itemizedlist><listitem><para>Objects that need to make arbitrary calls on other objects should hold <code>RefCountReferences</code> </para></listitem><listitem><para>Objects that need to inform of completion of events should hold <code>CallbackReferences</code> </para></listitem><listitem><para>One Class, One Mission </para></listitem><listitem><para>Clear Owners - try to have only clear owners for objects. </para></listitem></itemizedlist></section><section><title>General Ownership notes(draft still)</title><itemizedlist><listitem><para>On the client side of squid, there are listening sockets and individual client sockets. The squid configuration owns the listening client side sockets - it determines lifetime. The OS also owns those sockets, but no events from it will cause closedown in the normal run of things, so there are two owners: the squid config and the os. For individual client sockets, there is only one owner - the remote client, which is represented in our process by the OS. </para></listitem><listitem><para>Requests on a client side connection are owned by the connection. </para></listitem><listitem><para>The data source from the store or upstream to satisfy a connection is owned by the request. </para></listitem><listitem><para>Upstream requests are owned by the requestor - the client request when the request is not being diverted to the store, and the store when it is being copied to cache. </para></listitem><listitem><para>The server-side connection is owned by the OS - it must remain a valid object while the FD is open Its also owned by a protocol dispatcher for that protocol - one that puts a series of requests onto it. </para></listitem><listitem><para>The protocol dispatcher is a global resource owned by the configuration and all current requests going through it. </para></listitem><listitem><para>The store is a global resource owned by the configuration. it owns requests it is making on behalf of the client side.  </para></listitem><listitem><para>a store client is owned by the client reading data from it, </para></listitem></itemizedlist></section><section><title>Use Cases</title><section><title>Request that is not parsable</title><para>In this example, Socket refers to an object representing a single OS Socket - an fd on unix, a HANDLE on windows. </para><para><code>HttpClientConnection</code> refers to a single <code>HttpClientConnection</code> object - which represents the use of a single socket for HTTP.  </para><orderedlist numeration="arabic"><listitem><para>OS reports new socket available. </para><itemizedlist><listitem><para>Comms layer constructs Socket object. </para></listitem><listitem><para>Comms layer holds <code>RefCountReference</code> to Socket (comms layer stands in for the OS here) - it cannot be freed until the OS is notified etc. </para></listitem><listitem><para>Socket holds <code>CallbackReference</code> to the comms layer to notify it of close. </para></listitem></itemizedlist></listitem><listitem><para>New Socket is passed to the listening factory for the port it was recieved on. </para><itemizedlist><listitem><para>Factory constructs <code>HttpClientConnection</code> to represent the Socket at the protocol layer. </para></listitem><listitem><para>Factory cals <code>Socket.setClient(HttpClientConnection)</code> </para></listitem><listitem><para>Socket holds <code>RefCountReference</code> to the <code>HttpClientConnection</code> (which subclasses <code>SocketClient</code>). </para></listitem><listitem><para><code>HttpClientConnection</code> holds <code>CallbackReference</code> to the Socket. </para></listitem></itemizedlist></listitem><listitem><para><code>HttpClientConnection</code> calls read() on the Socket </para><itemizedlist><listitem><para>For some systems, the read is scheduled on the socket now. For others, when the next event loop occurs, the read willl be done. </para></listitem><listitem><para>Socket gets a <code>RefCount</code> reference to the dispatcher. </para></listitem></itemizedlist></listitem><listitem><para>Socket requests read from the OS (if it was not already scheduled) </para></listitem><listitem><para>read completes </para><itemizedlist><listitem><para>Socket hands the <code>HttpClientConnection</code> and the read result to the dispatcher. </para></listitem><listitem><para>Dispatcher holds <code>CallbackReference</code> to <code>HttpClientConnection</code> </para></listitem></itemizedlist></listitem><listitem><para>Dispatcher calls back <code>HttpClientConnection</code> </para><itemizedlist><listitem><para><code>HttpClientConnection</code> fails to parse the request. </para></listitem></itemizedlist></listitem><listitem><para><code>HttpClientConnection</code> calls write on the Socket to send an error page </para><itemizedlist><listitem><para>depending on the socket logic, a write may be issued immediately, or it may wait for the next event loop. </para></listitem><listitem><para>Socket gets a <code>RefCountReference</code> to the dispatcher </para></listitem></itemizedlist></listitem><listitem><para>Socket issues a write to the OS (if not issued immediately) </para></listitem><listitem><para>write completes </para><itemizedlist><listitem><para>Socket hands <code>HttpClientConnection</code> and the write result to the dispatcher </para></listitem><listitem><para>Dispatcher holds <code>CallbackReference</code> to <code>HttpClientConnection</code> </para></listitem></itemizedlist></listitem><listitem><para>Dispatcher calls back <code>HttpClientConnection</code> with write status </para><itemizedlist><listitem><para>Dispatch drops its <code>CallbackReference</code> </para></listitem></itemizedlist></listitem><listitem><para><code>HttpClientConnection</code> calls clean_close on Socket </para><itemizedlist><listitem><para>The Socket checks for outstanding reads or writes </para></listitem></itemizedlist></listitem><listitem><para>Socket calls shutdown(SD_SEND) to the os </para><itemizedlist><listitem><para>Socket calls 'socket_detached' on <code>HttpClientConnection</code> informing it that it has been released. </para></listitem><listitem><para>Socket drops its <code>CallbackReference</code> to the <code>HttpClientConnection</code> </para></listitem></itemizedlist></listitem><listitem><para><code>HttpClientConnection</code> has no <code>RefCountReferences</code> held on it, and so frees. </para></listitem><listitem><para>Socket calls setClient on itself with a <code>LingerCloseSocketClient</code>. </para><itemizedlist><listitem><para>Socket holds <code>RefCountReference</code> to the <code>LingerCloseSocketClient</code> </para></listitem></itemizedlist></listitem><listitem><para><code>LingerCloseSocketClient</code> calls read on the socket to detect EOF </para><itemizedlist><listitem><para>socket schedules read to the OS now </para></listitem></itemizedlist></listitem><listitem><para><code>LingerCloseSocketClient</code> registers a callback for time now + LINGERDELAY </para><itemizedlist><listitem><para><code>EventScheduler</code> holds a <code>CallbackReference</code> to the <code>LingerCloseSocketClient</code> and dispatcher </para></listitem></itemizedlist></listitem><listitem><para>Or Socket may schedule read to the OS now, on the next event loop. </para></listitem></orderedlist><para>Case 1: the read gets EOF first (the shutdown was acked by the far end) </para><orderedlist numeration="arabic"><listitem><para>the read completes </para><itemizedlist><listitem><para>Socket marks its read channel as closed. </para></listitem><listitem><para>Socket hands the <code>LingerCloseSocketClient</code> and the read result to the dispatcher. </para></listitem><listitem><para>Dispatcher holds <code>CallbackReference</code> to <code>LingerSocketClient</code> </para></listitem></itemizedlist></listitem><listitem><para>Dispatch hands read result to <code>LingerSocketClient</code> </para><itemizedlist><listitem><para><code>LingerSocketClient</code> sees that EOF has been reached. </para></listitem></itemizedlist></listitem><listitem><para><code>LingerSocket</code> calls close on Socket. </para><itemizedlist><listitem><para>Socket does sd_shutdown(SD_BOTH) and close(fd). </para></listitem></itemizedlist></listitem><listitem><para>Socket calls back the comms layer callback noting its finished with </para><itemizedlist><listitem><para>Comms layer drops its <code>RefCountReference</code> to the socket.  </para></listitem></itemizedlist></listitem><listitem><para>Socket frees due to no references </para><itemizedlist><listitem><para>Socket calls 'socket_detached' on the <code>LingerSocketClient</code>. </para></listitem></itemizedlist></listitem><listitem><para><code>LingerSocketClient</code> frees due to no references. </para></listitem></orderedlist><para>Case 2: the Linger timeout fires. </para><orderedlist numeration="arabic"><listitem><para>the <code>EventScheduler</code> puts the <code>LingerSocketClient</code> into the dispatch queue. </para><itemizedlist><listitem><para>Dispatcher holds <code>CallbackReference</code> to the <code>LingerSocketClient</code> </para></listitem><listitem><para><code>EventScheduler</code> drops its <code>CallbackReference</code> to the <code>LingerSocketClient</code> </para></listitem></itemizedlist></listitem><listitem><para>Dispatcher fires event to <code>LingerSocketClient</code> </para><itemizedlist><listitem><para>Dispatcher drops <code>CallbackReference</code> to the <code>LingerSocketClient</code> </para></listitem></itemizedlist></listitem><listitem><para><code>LingerSocketClient</code> calls socket.force_close() </para><itemizedlist><listitem><para>Socket does sd_shutdown(SD_BOTH) and close(fd). </para></listitem></itemizedlist></listitem><listitem><para>Socket calls back the comms layer callback noting its finished with </para><itemizedlist><listitem><para>Comms layer drops its <code>RefCountReference</code> to the socket.  </para></listitem></itemizedlist></listitem><listitem><para>Socket frees due to no references </para><itemizedlist><listitem><para>Socket calls 'socket_detached' on the <code>LingerSocketClient</code>. </para></listitem></itemizedlist></listitem><listitem><para><code>LingerSocketClient</code> frees due to no references. </para></listitem></orderedlist></section><section><title>Internal Request</title><orderedlist numeration="arabic"><listitem><para>listening socket factory creates <code>SocketClient</code> object for an opened socket: </para><itemizedlist><listitem><para>Socket owns the <code>SocketClient</code> via <code>RefCount</code>. </para></listitem><listitem><para>Socket is owned by the comms layer. If FD based, its in a table. If HANDLE based its put into a set of open sockets. </para></listitem><listitem><para><code>SocketClient</code> has a weak reference to the Socket: It  new Client owns the socket. Nothing owns the Client. Socket has callback to the client to notify on events : <code>ReadPossible</code>(data has arrived), Close(by request or external occurence). Other events get callbacks as each is queued - ask the socket to read and hand the callback to be called in. This could be 'this' if we structure the ap well, or it could be some other thing. <emphasis role="strong">XXX</emphasis> needs more detail/care. </para></listitem></itemizedlist></listitem><listitem><para>Client parses the URL into a normalised request using its native protocol : an HTTPClient will parse the URL using HTTP rules, a FTP client would do whatever FTP proxies do to get a target server etc. </para><para>This creates a new object, to handle that one request - a <code>ClientRequest</code>. The <code>SocketClient</code> registers itself with the <code>ClientRequest</code>, at which point the <code>ClientRequest</code> may initiate its request from the core: Socket has callbacks to <code>SocketClient</code> <code>SocketClient</code> owns Socket, and owns the <code>ClientRequest</code> it has created. </para></listitem><listitem><para><code>SocketClient</code> calls <code>ClientRequest</code>.at<code>ReadFront</code>() to indicate the <code>ClientRequest</code> is now at the front of the queue for the socket and is able to start reading body data if it wants to. Socket has callbacks to <code>SocketClient</code> <code>SocketClient</code> owns Socket, and owns the <code>ClientRequest</code> it has created. <code>ClientRequest</code> has a callback handle to <code>SocketClient</code> </para></listitem><listitem><para><code>ClientRequest</code> calls <code>SocketClient</code>.finishedReadingRequest() to indicate it will not read any more data from the <code>SocketClient</code>, and that the next request can be parsed. </para></listitem><listitem><para><code>SocketClient</code> calls <code>ClientRequest</code>.atWriteFront() to indicate the <code>ClientRequest</code> is now at the front of the queue for the socket <code>ClientRequest</code> has callbacks to <code>SocketClient</code> to call on events: <code>WillNotReadAnyMore</code>, <code>SocketMustBeClosed</code>, <code>SocketMustBeReset</code>. Socket has callbacks to <code>SocketClient</code> <code>SocketClient</code> owns Socket, and owns the <code>ClientRequest</code> it has created. <code>ClientRequest</code> has callbacks to <code>SocketClient</code> to call on events: <code>WillNotReadAnyMore</code>, <code>SocketMustBeClosed</code>, <code>SocketMustBeReset</code>, and </para></listitem><listitem><para><code>ClientRequest</code> asks for a response to this normalised request from the URL mapper at the core of squid Socket has callbacks to <code>SocketClient</code> <code>SocketClient</code> owns Socket, and owns the <code>ClientRequest</code> it has created. <code>ClientRequest</code> has calbacks to <code>SocketClient</code> to call on events: <code>WillNotReadAnyMore</code>, <code>SocketMustBeClosed</code>, <code>SocketMustBeReset</code>. </para></listitem><listitem><para>the URL mapper determines (based on the scheme or url path) that the request is for an internal resource </para></listitem><listitem><para>The request is forwarded to the internal resource to satisfy. An object is given to the Client which represents the 'source' of the data - this has methods on it to allow requesting the response headers, pulling of the data stream, signalling cancellation of the clients request. </para></listitem><listitem><para>The internal resource object is called by the client to initiate transfer, it then delivers the internal headers, and the internally generated data. </para></listitem><listitem><para>The internal resource signals end of file to the client in its last request to read data. </para></listitem><listitem><para>the client </para></listitem></orderedlist></section><section><title>Uncacheable request</title></section><section><title>Tunnel request</title></section><section><title>Cachable request</title></section></section></article>