<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>ProgrammingGuide/ClientStreams</title><revhistory><revision><revnumber>5</revnumber><date>2008-05-18 19:38:55</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>4</revnumber><date>2007-10-09 15:59:59</date><authorinitials>AlexRousskov</authorinitials><revremark>Moved Delay Pools from ClientStreams page</revremark></revision><revision><revnumber>3</revnumber><date>2007-10-09 15:04:06</date><authorinitials>AlexRousskov</authorinitials><revremark>Explained who lifeless in the transcript is</revremark></revision><revision><revnumber>2</revnumber><date>2007-10-09 14:50:39</date><authorinitials>AlexRousskov</authorinitials><revremark>Added a link to the famous IRC chat transcript. Removed an empty section.</revremark></revision><revision><revnumber>1</revnumber><date>2006-08-21 08:09:07</date><authorinitials>kinkie</authorinitials></revision></revhistory></articleinfo><section><title>Client Streams</title><section><title>Introduction</title><para>A clientStream is a uni-directional loosely coupled pipe. Each node consists of four methods - read, callback, detach, and status, along with the stream housekeeping variables (a dlink node and pointer to the head of the list), context data for the node, and read request parameters - readbuf, readlen and readoff (in the body). clientStream is the basic unit for scheduling, and the clientStreamRead and clientStreamCallback calls allow for deferred scheduled activity if desired. Theory on stream operation: </para><itemizedlist><listitem><para>Something creates a pipeline. At a minimum it needs a head with a status method and a read method, and a tail with a callback method and a valid initial read request. </para></listitem><listitem><para>Other nodes may be added into the pipeline. </para></listitem><listitem><para>The tail-1th node's read method is called. </para></listitem><listitem><para>for each node going up the pipeline, the node either: </para></listitem><listitem><para>satisfies the read request, or </para></listitem><listitem><para>inserts a new node above it and calls clientStreamRead, or </para></listitem><listitem><para>calls clientStreamRead </para></listitem></itemizedlist><para>There is no requirement for the Read parameters from different nodes to have any correspondence, as long as the callbacks provided are correct. </para><itemizedlist><listitem><para>The first node that satisfies the read request MUST generate an httpReply to be passed down the pipeline. Body data MAY be provided. </para></listitem><listitem><para>On the first callback a node MAY insert further downstream nodes in the pipeline, but MAY NOT do so thereafter. </para></listitem><listitem><para>the callbacks progress down the pipeline until a node makes further reads instead of satisfying the callback (go to 4) or the end of the pipe line is reached, where a new read sequence may be scheduled. </para></listitem></itemizedlist></section><section><title>Implementation notes</title><para>ClientStreams have been implemented for the client side reply logic, starting with either a client socket (tail of the list is clientSocketRecipient) or a custom handler for in-squid requests, and with the pipeline HEAD being clientGetMoreData, which uses clientSendMoreData to send data down the pipeline. client POST bodies do not use a pipeline currently, they use the previous code to send the data. This is a TODO when time permits. </para></section><section><title>Whats in a node</title><para>Each node must have:  </para><itemizedlist><listitem><para>read method - to allow loose coupling in the pipeline. (The reader may therefore change if the pipeline is altered, even mid-flow). </para></listitem><listitem><para>callback method - likewise. </para></listitem><listitem><para>status method - likewise. </para></listitem><listitem><para>detach method - used to ensure all resources are cleaned up properly. </para></listitem><listitem><para>dlink head pointer - to allow list inserts and deletes from within a node. </para></listitem><listitem><para>context data - to allow the called back nodes to maintain their private information. </para></listitem><listitem><para>read request parameters - For two reasons: </para><itemizedlist><listitem><para>To allow a node to determine the requested data offset, length and target buffer dynamically. Again, this is to promote loose coupling. </para></listitem><listitem><para>Because of the callback nature of squid, every node would have to keep these parameters in their context anyway, so this reduces programmer overhead. </para></listitem></itemizedlist></listitem></itemizedlist></section><section><title>Method details</title><para>The first parameter is always the 'this' reference for the client stream - a clientStreamNode *. </para><section><title>Read</title><para>Parameters: </para><itemizedlist><listitem><para>clientHttpRequest * - superset of request data, being winnowed down over time. MUST NOT be NULL. </para></listitem><listitem><para>offset, length, buffer - what, how much and where. </para></listitem></itemizedlist><para>Side effects: Triggers a read of data that satisfies the httpClientRequest  metainformation and (if appropriate) the offset,length and buffer parameters. </para></section><section><title>Callback</title><para>Parameters: </para><itemizedlist><listitem><para>clientHttpRequest * - superset of request data, being winnowed down over time. MUST NOT be NULL. </para></listitem><listitem><para>httpReply * - not NULL on the first call back only. Ownership is passed down the pipeline. Each node may alter the reply if appropriate. </para></listitem><listitem><para>buffer, length - where and how much. </para></listitem></itemizedlist><para>Side effects: Return data to the next node in the stream. The data may be returned immediately, or may be delayed for a later scheduling cycle. </para></section><section><title>Detach</title><para>Parameters: </para><itemizedlist><listitem><para>clienthttpRequest * - MUST NOT be NULL. </para></listitem></itemizedlist><para>Side effects: </para><itemizedlist><listitem><para>Removes this node from a clientStream. The stream infrastructure handles the removal. This node MUST have cleaned up all context data, UNLESS scheduled callbacks will take care of that. </para></listitem><listitem><para>Informs the prev node in the list of this nodes detachment. </para></listitem></itemizedlist></section><section><title>Status</title><para>Parameters: </para><itemizedlist><listitem><para>clienthttpRequest * - MUST NOT be NULL. </para></listitem></itemizedlist><para>Side effects: Allows nodes to query the upstream nodes for : </para><itemizedlist><listitem><para>stream ABORTS - request cancelled for some reason. upstream will not accept further reads(). </para></listitem><listitem><para>stream COMPLETION - upstream has completed and will not accept further reads(). </para></listitem><listitem><para>stream UNPLANNED COMPLETION - upstream has completed, but not at a pre-planned location (used for keepalive checking), and will not accept further reads(). </para></listitem><listitem><para>stream NONE - no special status, further reads permitted. </para></listitem></itemizedlist></section><section><title>Abort</title><para>Parameters: </para><itemizedlist><listitem><para>clienthttpRequest * - MUST NOT be NULL. </para></listitem></itemizedlist><para>Side effects: Detachs the tail of the stream. CURRENTLY DOES NOT clean up the tail node data - this must be done separately. Thus Abort may ONLY be called by the tail node. </para></section></section><section><title>More information</title><para>The <ulink url="https://wiki.squid-cache.org/ProgrammingGuide/ClientStreams/ClientStreams#">transcript</ulink> of the Squid IRC chat with Robert Collins (aka <emphasis>lifeless</emphasis>) discusses how to use ClientStreams for content analysis. </para></section></section></article>