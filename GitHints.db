<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>GitHints</title><revhistory><revision><revnumber>15</revnumber><date>2018-05-11 22:21:38</date><authorinitials>AlexRousskov</authorinitials><revremark>Added a command to block accidental upstream pushes; essential for GitHub repo writers and potentially useful (due to slightly more informative error messages) for everybody</revremark></revision><revision><revnumber>14</revnumber><date>2018-02-24 23:19:50</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented how to sync origin/master with upstream/master. Useful for preliminary pull request reviews within development teams.</revremark></revision><revision><revnumber>13</revnumber><date>2017-10-22 22:30:18</date><authorinitials>AlexRousskov</authorinitials><revremark>Mentioned &quot;git cherry-pick&quot; as a simpler solution for use cases that do not need feature branch rebasing.</revremark></revision><revision><revnumber>12</revnumber><date>2017-10-18 16:26:09</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented a typical branch backporting step.</revremark></revision><revision><revnumber>11</revnumber><date>2017-10-12 14:58:55</date><authorinitials>AlexRousskov</authorinitials><revremark>Added more details about getting GitHub ssh authentication to work.</revremark></revision><revision><revnumber>10</revnumber><date>2017-09-15 04:12:54</date><authorinitials>AlexRousskov</authorinitials><revremark>Documented a newly discovered problem with (and solution for) cutting squashing conners using `git rebase --interactive`.</revremark></revision><revision><revnumber>9</revnumber><date>2017-08-08 18:59:01</date><authorinitials>AlexRousskov</authorinitials><revremark>Reduced text duplication in instructions for publishing PRs.</revremark></revision><revision><revnumber>8</revnumber><date>2017-08-08 17:23:14</date><authorinitials>AlexRousskov</authorinitials><revremark>Simplified &quot;git push&quot; instructions. The current local branch name is the default remote branch name.</revremark></revision><revision><revnumber>7</revnumber><date>2017-08-07 02:34:30</date><authorinitials>AlexRousskov</authorinitials><revremark>Explained how to get bzr metadata in git logs.</revremark></revision><revision><revnumber>6</revnumber><date>2017-08-03 00:36:35</date><authorinitials>AlexRousskov</authorinitials><revremark>Clarified that squashing and rebasing commands were given from the current branch p.o.v.</revremark></revision><revision><revnumber>5</revnumber><date>2017-08-03 00:03:22</date><authorinitials>AlexRousskov</authorinitials><revremark>Explained that the old (and often useful) commit messages are not yet lost _during_ squashing.</revremark></revision><revision><revnumber>4</revnumber><date>2017-08-02 23:25:47</date><authorinitials>AlexRousskov</authorinitials><revremark>Added a branch rebasing hint.</revremark></revision><revision><revnumber>3</revnumber><date>2017-08-02 22:36:55</date><authorinitials>AlexRousskov</authorinitials><revremark>Added a commit squashing hint.</revremark></revision><revision><revnumber>2</revnumber><date>2017-08-02 15:57:39</date><authorinitials>AlexRousskov</authorinitials><revremark>Addressed external review comments.</revremark></revision><revision><revnumber>1</revnumber><date>2017-08-02 06:36:16</date><authorinitials>AlexRousskov</authorinitials><revremark>Started documenting git recipes. Initial authorization setup details are missing. Somebody else (with fresh experience) should document them.</revremark></revision></revhistory></articleinfo><section><title>Git Hints</title><para>This page archives git recipes that may be useful in the context of Squid development. It is not meant as a guide to git or GitHub. Most of the recipes here target <emphasis>developers</emphasis> that will eventually submit pull requests back to the Squid Project. </para><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> Many later recipes rely on the setup (partially) shown in earlier recipes. Your setup may be different; git-related naming conventions vary a lot. If you start in the middle, make sure you understand what you are doing before copy-pasting any commands! </para><section><title>When a recipe is missing</title><para>Use a search engine to solve git and GitHub problems. Virtually all basic questions about git and GitHub (and many advanced ones) are answered on the web. Git mastery helps, but is not required to do Squid development. Git manipulations required for typical Squid development are hardly rocket science. </para></section><section><title>Create your public Squid repository on GitHub</title><orderedlist numeration="arabic"><listitem><para>Login to GitHub. </para></listitem><listitem><para>Navigate to the official Squid <ulink url="https://github.com/squid-cache/squid">repository</ulink>. </para></listitem><listitem><para>Click the &quot;Fork&quot; button. <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> If you are a part of an organization, that organization may already have a Squid repository fork that you should use instead. </para></listitem></orderedlist></section><section><title>Create your local Squid work area</title><para>Your git work area will be a combination of your public Squid repository (a.k.a. &quot;origin&quot; remote), the official Squid repository (a.k.a. &quot;upstream&quot; remote), and your private (unpublished) Squid branches. </para><orderedlist numeration="arabic"><listitem><para>Clone your public Squid repository on GitHub into your local work area. By default, git will refer to your public repository as &quot;origin&quot;. This is where you will publish your development branches. To get the right repository .git address for the first command, click the &quot;clone or download&quot; button while looking at your repository on GitHub. The &quot;clone or download&quot; button offers https and ssh protocols; for development work, you may find ssh authentication easier to work with. The example below uses an ssh address. <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> You may need to upload your publish ssh key to your GitHub account first.</para><screen><![CDATA[$ git clone git@github.com:YOUR_GITHUB_LOGIN/squid.git
$ cd squid
$ git remote -v # Should show you the origin repository address]]></screen></listitem><listitem><para>Point git to the official Squid repository on GitHub. These instructions call that repository &quot;upstream&quot;, but the name of the remote is up to you. You will never push into this repository, but you will submit pull requests against it.</para><screen><![CDATA[$ git remote add -m master upstream git@github.com:squid-cache/squid.git
$ git remote -v # Should show you the origin and upstream repository addresses
$ git remote set-url --push upstream upstream-push-disabled # prevents and highlights accidental pushes]]></screen></listitem><listitem><para>Optionally, load git <ulink url="http://alblue.bandlem.com/2011/11/git-tip-of-week-git-notes.html">notes</ulink> to see original Bazaar revision numbers, --fixes URLs, and more co-author names in git logs:</para><screen><![CDATA[$ git fetch upstream refs/notes/commits:refs/notes/commits]]></screen><para> <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> If you are a part of an organization, that organization may provide its own Squid annotations that you should load instead or in addition to the official ones.</para></listitem></orderedlist></section><section><title>Start working on a feature or change</title><para>Most stand-alone code changes need a dedicated git branch. If you want to submit your changes for the official inclusion, you must create a dedicated branch for each such submission (a.k.a. pull request or PR). Git branches are cheap. Each branch is little more than a named pointer to the latest commit on the branch. </para><para>These commands assume that your changes are based on the latest <ulink url="https://github.com/squid-cache/squid">official master branch</ulink>. </para><orderedlist numeration="arabic"><listitem><para>Make sure your upstream master is up to date:</para><screen><![CDATA[$ git fetch upstream master]]></screen></listitem><listitem><para>Create a new local feature branch based on the the very tip of the upstream master. This example uses &quot;support-foobar&quot; as the branch name.</para><screen><![CDATA[$ git checkout -b support-foobar upstream/master]]></screen></listitem></orderedlist><para>You can now make and commit changes to your local feature branch. </para></section><section><title>Compare your changes with the official code</title><orderedlist numeration="arabic"><listitem><para>To compare with the official code that you have previously fetched:</para><screen><![CDATA[$ git diff upstream/master]]></screen></listitem><listitem><para>To compare with the official code as it existed when you created your feature branch:</para><screen><![CDATA[$ fork_point=$(git merge-base --fork-point upstream/master support-foobar)
$ git diff $fork_point]]></screen></listitem></orderedlist><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> Use <emphasis>git diff --check ...</emphasis> to check for basic whitespace problems. </para></section><section><title>Squash all the feature branch changes into a single commit</title><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> These commands rewrite branch history. Rewriting history may mess up or even permanently destroy your work! Consider pushing all changes to your GitHub repository <emphasis>before</emphasis> squashing your local tree and do <emphasis>not</emphasis> publish the squashed branch until you are sure it ends up with the same code as the last pushed commit. </para><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> If you need to both rebase and squash your feature branch, you may use interactive <link linkend="Rebase_your_feature_branch_to_be_in_sync_with_the_current_upstream_master">rebase</link> and replace the default &quot;pick&quot; with &quot;squash&quot; commands there. The resulting squashed commit will get the metadata such as Date from the first feature branch commit, confusing readers and some tools (especially on long-lived feature branches), but you can fix that using something like  <emphasis>git commit --amend --date=&quot;$(date)&quot;</emphasis>. Doing two things at once (i.e., squashing and rebasing) is faster when things go smoothly, but it is more difficult to discover and fix problems. Also, rebasing an already <emphasis>squashed</emphasis> branch may reduce the number of conflicts but may also create more complex conflicts. Pick your poison. </para><orderedlist numeration="arabic"><listitem><para>Switch to the local up-to-date feature branch you want to squash:</para><screen><![CDATA[$ git checkout support-foobar]]></screen></listitem><listitem><para>Find the master commit from which your feature branch originated, either by examining <emphasis>git log support-foobar</emphasis> or by using the following trick (which <ulink url="https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git">reportedly</ulink> fails in some cases):</para><screen><![CDATA[$ fork_point=$(git merge-base --fork-point upstream/master support-foobar)]]></screen></listitem><listitem><para>Double check that you found the right forking point before making any changes. For example:</para><screen><![CDATA[$ git show $fork_point]]></screen><para> and/or </para><screen><![CDATA[$ git log | less +/$fork_point]]></screen></listitem><listitem><para>Undo all feature branch commits up to the forking point while keeping their cumulative results, staged in your working directory:</para><screen><![CDATA[$ git reset --soft $fork_point]]></screen></listitem><listitem><para>Re-commit the staged results with a new commit message summarizing all the changes on the feature branch:</para><screen><![CDATA[$ git commit]]></screen><para> If you need to see your old commit messages, and you have published your unsquashed changes on GitHub as recommended earlier, then you can still easily get them from</para><screen><![CDATA[$ git log origin/support-foobar]]></screen></listitem><listitem><para>Double check that the squashed result is identical to the published feature branch:</para><screen><![CDATA[$ git diff --exit-code origin/support-foobar || echo 'Start panicking!']]></screen></listitem><listitem><para>When comfortable, publish your squashed changes, permanently deleting the old feature branch commits:</para><screen><![CDATA[$ git push # will fail, giving you the last change to check its intended destination before you add --force]]></screen></listitem></orderedlist></section><section><title>Rebase your feature branch to be in sync with the current upstream master</title><para><inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> These commands rewrite branch history. Rewriting history may mess up or even permanently destroy your work! Consider pushing all changes to your GitHub repository <emphasis>before</emphasis> rebasing your local tree. </para><para><inlinemediaobject><imageobject><imagedata depth="16" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/icon-info.png" width="16"/></imageobject><textobject><phrase>{i}</phrase></textobject></inlinemediaobject> If you need to both rebase and squash your feature branch, you may use the interactive rebase command shown below and replace the default &quot;pick&quot; with &quot;squash&quot; commands there. The resulting squashed commit will get the metadata such as Date from the first feature branch commit, confusing readers and some tools (especially on long-lived feature branches), but you can fix that using something like  <emphasis>git commit --amend --date=&quot;$(date)&quot;</emphasis>. Doing two things at once (i.e., squashing and rebasing) is faster when things go smoothly, but it is more difficult to discover and fix problems. Also, rebasing an already <link linkend="Squash_all_the_feature_branch_changes_into_a_single_commit">squashed</link>  branch may reduce the number of conflicts but may also create more complex conflicts. Pick your poison. </para><orderedlist numeration="arabic"><listitem><para>Make sure your upstream master is up to date:</para><screen><![CDATA[$ git fetch upstream master]]></screen></listitem><listitem><para>Switch to the to the local up-to-date feature branch you want to rebase:</para><screen><![CDATA[$ git checkout support-foobar]]></screen></listitem><listitem><para>Start the interactive rebase process. The command below should start your editor so that you can tell git what to do with each of the listed commits. The default &quot;pick&quot; action works well for simple cases.</para><screen><![CDATA[$ git rebase --interactive upstream/master]]></screen></listitem><listitem><para>When comfortable, publish your rebased feature branch, permanently deleting the old feature branch commits:</para><screen><![CDATA[$ git push # will fail, giving you the last change to check its intended destination before you add --force]]></screen></listitem></orderedlist></section><section><title>Submit a pull request</title><orderedlist numeration="arabic"><listitem><para>Publish your feature branch in your GitHub repository:</para><screen><![CDATA[$ git push --set-upstream origin]]></screen></listitem><listitem><para>When you are <ulink url="https://wiki.squid-cache.org/GitHints/MergeProcedure#Submission_Checklist">ready</ulink>: </para><orderedlist numeration="loweralpha"><listitem><para>either go to <ulink url="https://www.github.com/">GitHub</ulink>, navigate to the support-foobar branch in your repository, and click the &quot;new pull request&quot; button next to the branch name </para></listitem><listitem><para>or use a console pull request submission tool of your choice. This example uses <ulink url="https://hub.github.com/">hub</ulink>:</para><screen><![CDATA[$ hub pull-request]]></screen></listitem></orderedlist></listitem></orderedlist></section><section><title>Update a previously submitted pull request</title><orderedlist numeration="arabic"><listitem><para>When you are <ulink url="https://wiki.squid-cache.org/GitHints/MergeProcedure#Submission_Checklist">ready</ulink>, publish your updates in your GitHub repository:</para><screen><![CDATA[$ git push]]></screen></listitem><listitem><para>GitHub will notice the updates in your public repository and reflect them in your pull request in the official repository. Now it is time to go through the reviewer comments inside the pull request and respond to those you have addressed with &quot;Done&quot;, &quot;Fixed&quot;, or another comment, as appropriate. </para></listitem></orderedlist><para>If you rebased your local feature branch or otherwise altered its previously published history, then you will need to force-push your changes. Forced pushes are normally OK for feature branches that you have not knowingly shared with anybody (other than via pull requests). In most other cases, force pushes are a <emphasis>very bad idea</emphasis>, so make sure you know what you are doing! </para></section><section><title>Rebase your feature branch to another official branch</title><para>A feature branch that was branched off master often needs to be rebased on top of a versioned Squid branch (e.g., v4.0) so that the feature can be backported to a specific Squid release series. A similar need arises when you were developing a, say, v3.5 fix but then realized that the Squid Project wants you to submit a pull request against the <emphasis>master</emphasis> branch instead. <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> To simply cherry pick officially committed changes into a new feature porting branch, see &quot;git cherry-pick --help&quot;. This section covers more complex (and relatively rare) use cases where rebasing the old feature branch is more appropriate than cheery picking individual commits into a new feature branch. </para><orderedlist numeration="arabic"><listitem><para>Here is a possible first step to switch the base of your feature branch:</para><screen><![CDATA[git rebase --fork-point upstream/master --interactive --onto upstream/v4.0]]></screen><para> The above command switches the base branch from the official master branch to the official branch called v4.0. <inlinemediaobject><imageobject><imagedata depth="15" fileref="https://wiki.squid-cache.org/wiki/squidtheme/img/alert.png" width="15"/></imageobject><textobject><phrase>/!\</phrase></textobject></inlinemediaobject> If, prior to rebase, your feature branch is not up to date with its official base branch, then you will need to use <emphasis>HEAD~1</emphasis> or a similar reference/SHA to identify the right fork point (i.e., the last official commit on your feature branch). Please note that this example assumes that all your feature branch commits sit on top of its base branch already. If that assumption is false in your use case, then you will need to rebase your branch commits on top of its base branch before switching the base branches (there is another <link linkend="Rebase_your_feature_branch_to_be_in_sync_with_the_current_upstream_master">hint</link> about that).</para></listitem><listitem><para>Changing the base branch often leads to conflicts that you will need to resolve. A <emphasis>git rebase --continue</emphasis> command will move you forward with the rebase process. Moreover, even without conflicts, you may need to modify your code to actually work well in another code base. This hint does <emphasis>not</emphasis> cover those common complications. </para></listitem><listitem><para>This example does not contain a final &quot;git push&quot; command that makes your changes public (after all conflicts are resolved, and the feature is tested on the new base branch). There are two primary options to publish your rebased feature: </para><itemizedlist><listitem><para>Either push to the old origin feature branch (obliterating old public changes in that branch and updating any pull requests tied to that feature branch). Force-pushing is required here. </para></listitem><listitem><para>Or you can create a new origin feature branch dedicated to this backport (and then submit a brand new pull request based on that newly created feature branch). No force pushing is required. </para></listitem></itemizedlist></listitem></orderedlist><para>It may be tempting to let git figure out the fork point for you. In most cases dealing with switching between official base branches, git will find a fork point where the target official branch (i.e., v4.0 in the above example) forked off the other official branch (i.e., master in the above example), resulting in your rebased branch containing hundreds of unwanted official commits instead of just your feature changes. This is why the above example explicitly sets the fork point! Fortunately, feature branch commits are easy to isolate (e.g., by looking at the branch log) when all of those commits are already sitting on top of the current base branch (which is a prerequisite for a less painful switch anyway). </para></section><section><title>What happens to origin/master?</title><para>The primary purpose of having your own public repository on GitHub is so that you can submit pull requests and share code with your collaborators or users. The copies of official branches in your forked repository will become stale because neither you nor anybody else need them (everybody should go upstream for the current official code). Unless you forked the official Squid repository to create a splinter project, you can safely ignore the copies of the official branches in your public Squid repository on GitHub. You may pull upstream changes into origin once in a while, as shown below, but many developers do not bother to do that. </para><screen><![CDATA[$ git push origin upstream/master:master]]></screen></section></section></article>