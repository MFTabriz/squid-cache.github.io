<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article  PUBLIC '-//OASIS//DTD DocBook XML V4.4//EN'  'http://www.docbook.org/xml/4.4/docbookx.dtd'><article><articleinfo><title>StoreAPI</title><revhistory><revision><revnumber>5</revnumber><date>2008-05-18 19:39:01</date><authorinitials>localhost</authorinitials><revremark>converted to 1.6 markup</revremark></revision><revision><revnumber>4</revnumber><date>2004-12-30 13:27:35</date><authorinitials>RobertCollins</authorinitials><revremark>forgot the second structure example</revremark></revision><revision><revnumber>3</revnumber><date>2004-12-30 13:25:57</date><authorinitials>RobertCollins</authorinitials><revremark>added two replacement policy scenarios</revremark></revision><revision><revnumber>2</revnumber><date>2004-12-30 13:19:16</date><authorinitials>RobertCollins</authorinitials><revremark>add some diagrams</revremark></revision><revision><revnumber>1</revnumber><date>2004-12-28 10:29:38</date><authorinitials>RobertCollins</authorinitials><revremark>start documenting the Store API</revremark></revision></revhistory></articleinfo><para>Draft Store API. </para><screen><![CDATA[class StoreSearch : RefCountable
{
    /* callback upon a new StoreEntry being available */
    virtual void next(void (callback)(void *cbdata), void *cbdata) = 0;
    /* return true if a new StoreEntry is immediately available */
    virtual bool next() = 0;
    /* has an error occured ? */
    virtual bool error() const = 0;
    /* are we at the end of the iterator ? */
    virtual bool isDone() const = 0;
    /* retrieve the current store entry */
    virtual StoreEntry *currentItem() = 0;
};
]]><![CDATA[
class Store :  RefCountable
{
public:
    RefCount<StoreSearch> search (String const url, HttpRequest * request) = 0;
};]]></screen><para>Current class hierarchy. </para><screen><![CDATA[Store ----- StoreController
       +--- StoreHashIndex
       +--- SwapDir
       +--- UFSSwapDir
       +--- CossSwapDir
       +--- NullSwapDir]]></screen><para>The current squid 2.5 capabilities are not yet changed. They are implemented by constructing the following memory structure of class instances </para><screen><![CDATA[Store::Root() -- StoreController
                    |
                 StoreHashIndex
                    |
        +-----------+----+------+
        |
     UFSSwapDir   ...   ... .... ...]]></screen><para>= Replacement policies =  </para><section><title>as decorators</title><itemizedlist><listitem><para>first a new class </para></listitem></itemizedlist><screen><![CDATA[class StoreLRU : public Store;]]></screen><itemizedlist><listitem><para>And when we build the in memory structure: </para></listitem></itemizedlist><screen><![CDATA[Store::Root() -- StoreController
                    |
                 StoreHashIndex
                    |
        +-----------+-----------+
        |           |
     StoreLru    StoreHeap ....
        |           |
     UFSSwapDir  UfsSwapDir ...]]></screen><para>alternatively </para><screen><![CDATA[Store::Root() -- StoreController
                    |
                 StoreLru
                    |
                 StoreHashIndex
                    |
        +-----------+-----------+
        |           |
     UFSSwapDir  UfsSwapDir ...]]></screen></section></article>